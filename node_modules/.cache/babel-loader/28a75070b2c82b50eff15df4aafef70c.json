{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = evaluateExpressions;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _asyncIterator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncIterator\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _withWebId = _interopRequireDefault(require(\"./withWebId\"));\n\nvar _util = require(\"../util\");\n\nvar _queryLdflex = _interopRequireDefault(require(\"@solid/query-ldflex\"));\n\nvar evaluatorQueue = (0, _util.createTaskQueue)();\n/**\n * Higher-order component that evaluates LDflex expressions in properties\n * and passes their results to the wrapped component.\n */\n\nfunction evaluateExpressions(valueProps, listProps, Component) {\n  // Shift the optional listProps parameter when not specified\n  if (!Component) {\n    Component = listProps;\n    listProps = [];\n  }\n\n  var EvaluateExpressions =\n  /*#__PURE__*/\n  function (_react$default$Compon) {\n    _inherits(EvaluateExpressions, _react$default$Compon);\n\n    function EvaluateExpressions(props) {\n      var _this;\n\n      _classCallCheck(this, EvaluateExpressions);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(EvaluateExpressions).call(this, props));\n      _this.state = {\n        pending: true\n      };\n      _this.pending = {};\n      _this.cancel = false;\n      _this.valueProps = valueProps || [];\n\n      _this.valueProps.forEach(function (p) {\n        return _this.state[p] = undefined;\n      });\n\n      _this.listProps = listProps || [];\n\n      _this.listProps.forEach(function (p) {\n        return _this.state[p] = [];\n      });\n\n      return _this;\n    }\n\n    _createClass(EvaluateExpressions, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.evaluateExpressions(this.valueProps, this.listProps);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        var _this2 = this;\n\n        // A property needs to be re-evaluated if it changed\n        // or, if it is a string expression, when the user has changed\n        // (which might influence the expression's evaluation).\n        var userChanged = this.props.webId !== prevProps.webId;\n\n        var propChanged = function propChanged(name) {\n          return _this2.props[name] !== prevProps[name] || userChanged && typeof _this2.props[name] === 'string';\n        }; // Re-evaluate changed singular values and lists\n\n\n        var changedValues = this.valueProps.filter(propChanged);\n        var changedLists = this.listProps.filter(propChanged);\n        if (changedValues.length > 0 || changedLists.length > 0) this.evaluateExpressions(changedValues, changedLists);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        // Avoid state updates from pending evaluators\n        this.pending = {};\n        this.cancel = true;\n        evaluatorQueue.clear(this);\n      }\n      /** Evaluates the property expressions into the state. */\n\n    }, {\n      key: \"evaluateExpressions\",\n      value: function () {\n        var _evaluateExpressions = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee(values, lists) {\n          var _this3 = this;\n\n          var pendingState, evaluators, statuses;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  // Create evaluators for each property, and mark them as pending\n                  pendingState = {\n                    error: undefined,\n                    pending: true\n                  };\n                  evaluators = evaluatorQueue.schedule([].concat(_toConsumableArray(values.map(function (name) {\n                    pendingState[name] = undefined;\n                    return function () {\n                      return _this3.evaluateValueExpression(name);\n                    };\n                  })), _toConsumableArray(lists.map(function (name) {\n                    pendingState[name] = [];\n                    return function () {\n                      return _this3.evaluateListExpression(name);\n                    };\n                  }))), this);\n                  this.setState(pendingState); // Wait until all evaluators are done (or one of them errors)\n\n                  _context.prev = 3;\n                  _context.next = 6;\n                  return Promise.all(evaluators);\n\n                case 6:\n                  _context.next = 11;\n                  break;\n\n                case 8:\n                  _context.prev = 8;\n                  _context.t0 = _context[\"catch\"](3);\n                  this.setState({\n                    error: _context.t0\n                  });\n\n                case 11:\n                  _context.next = 13;\n                  return Promise.all(evaluators.map(function (e) {\n                    return e.catch(function (error) {\n                      console.warn('@solid/react-components', 'Expression evaluation failed.', error);\n                      return true;\n                    });\n                  }));\n\n                case 13:\n                  statuses = _context.sent;\n\n                  if (!this.cancel) {\n                    _context.next = 16;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\");\n\n                case 16:\n                  // Reset the pending state if all are done and no others are pending\n                  if (!statuses.some(function (done) {\n                    return !done;\n                  }) && Object.keys(this.pending).length === 0) this.setState({\n                    pending: false\n                  });\n\n                case 17:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[3, 8]]);\n        }));\n\n        function evaluateExpressions(_x, _x2) {\n          return _evaluateExpressions.apply(this, arguments);\n        }\n\n        return evaluateExpressions;\n      }()\n      /** Evaluates the property expression as a singular value. */\n\n    }, {\n      key: \"evaluateValueExpression\",\n      value: function () {\n        var _evaluateValueExpression = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee2(name) {\n          var promise, value;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  // Obtain and await the promise\n                  promise = this.resolveExpression(name, 'then');\n                  this.pending[name] = promise;\n                  _context2.prev = 2;\n                  _context2.next = 5;\n                  return promise;\n\n                case 5:\n                  value = _context2.sent;\n\n                  if (!(this.pending[name] !== promise)) {\n                    _context2.next = 8;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\", false);\n\n                case 8:\n                  this.setState(_defineProperty({}, name, value));\n\n                case 9:\n                  _context2.prev = 9;\n                  if (this.pending[name] === promise) delete this.pending[name];\n                  return _context2.finish(9);\n\n                case 12:\n                  return _context2.abrupt(\"return\", true);\n\n                case 13:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this, [[2,, 9, 12]]);\n        }));\n\n        function evaluateValueExpression(_x3) {\n          return _evaluateValueExpression.apply(this, arguments);\n        }\n\n        return evaluateValueExpression;\n      }()\n      /** Evaluates the property expression as a list. */\n\n    }, {\n      key: \"evaluateListExpression\",\n      value: function () {\n        var _evaluateListExpression = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee3(name) {\n          var _this4 = this;\n\n          var iterable, items, update, stateQueue, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, item, needsUpdate;\n\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  // Create the iterable\n                  iterable = this.resolveExpression(name, Symbol.asyncIterator);\n\n                  if (iterable) {\n                    _context3.next = 3;\n                    break;\n                  }\n\n                  return _context3.abrupt(\"return\", true);\n\n                case 3:\n                  this.pending[name] = iterable; // Read the iterable\n\n                  items = [];\n\n                  update = function update() {\n                    return _this4.cancel || _this4.setState(_defineProperty({}, name, [].concat(items)));\n                  };\n\n                  stateQueue = (0, _util.createTaskQueue)({\n                    timeBetween: 100,\n                    drop: true\n                  });\n                  _context3.prev = 7;\n                  _iteratorNormalCompletion = true;\n                  _didIteratorError = false;\n                  _context3.prev = 10;\n                  _iterator = (0, _asyncIterator2.default)(iterable);\n\n                case 12:\n                  _context3.next = 14;\n                  return _iterator.next();\n\n                case 14:\n                  _step = _context3.sent;\n                  _iteratorNormalCompletion = _step.done;\n                  _context3.next = 18;\n                  return _step.value;\n\n                case 18:\n                  _value = _context3.sent;\n\n                  if (_iteratorNormalCompletion) {\n                    _context3.next = 28;\n                    break;\n                  }\n\n                  item = _value; // Stop if another evaluator took over in the meantime (component update)\n\n                  if (!(this.pending[name] !== iterable)) {\n                    _context3.next = 23;\n                    break;\n                  }\n\n                  return _context3.abrupt(\"return\", false);\n\n                case 23:\n                  items.push(item);\n                  stateQueue.schedule(update);\n\n                case 25:\n                  _iteratorNormalCompletion = true;\n                  _context3.next = 12;\n                  break;\n\n                case 28:\n                  _context3.next = 34;\n                  break;\n\n                case 30:\n                  _context3.prev = 30;\n                  _context3.t0 = _context3[\"catch\"](10);\n                  _didIteratorError = true;\n                  _iteratorError = _context3.t0;\n\n                case 34:\n                  _context3.prev = 34;\n                  _context3.prev = 35;\n\n                  if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                    _context3.next = 39;\n                    break;\n                  }\n\n                  _context3.next = 39;\n                  return _iterator.return();\n\n                case 39:\n                  _context3.prev = 39;\n\n                  if (!_didIteratorError) {\n                    _context3.next = 42;\n                    break;\n                  }\n\n                  throw _iteratorError;\n\n                case 42:\n                  return _context3.finish(39);\n\n                case 43:\n                  return _context3.finish(34);\n\n                case 44:\n                  _context3.prev = 44;\n                  needsUpdate = stateQueue.clear();\n\n                  if (this.pending[name] === iterable) {\n                    if (needsUpdate) update();\n                    delete this.pending[name];\n                  }\n\n                  return _context3.finish(44);\n\n                case 48:\n                  return _context3.abrupt(\"return\", true);\n\n                case 49:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this, [[7,, 44, 48], [10, 30, 34, 44], [35,, 39, 43]]);\n        }));\n\n        function evaluateListExpression(_x4) {\n          return _evaluateListExpression.apply(this, arguments);\n        }\n\n        return evaluateListExpression;\n      }()\n      /** Resolves the property into an LDflex path. */\n\n    }, {\n      key: \"resolveExpression\",\n      value: function resolveExpression(name, expectedProperty) {\n        // If the property is an LDflex string expression, resolve it\n        var expr = this.props[name];\n        if (!expr) return '';\n        var resolved = typeof expr === 'string' ? _queryLdflex.default.resolve(expr) : expr; // Ensure that the resolved value is an LDflex path\n\n        if (!resolved || typeof resolved[expectedProperty] !== 'function') throw new Error(\"\".concat(name, \" should be an LDflex path or string but is \").concat(expr));\n        return resolved;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return _react.default.createElement(Component, (0, _extends2.default)({}, this.props, this.state));\n      }\n    }]);\n\n    return EvaluateExpressions;\n  }(_react.default.Component);\n\n  (0, _defineProperty2.default)(EvaluateExpressions, \"displayName\", \"EvaluateExpressions(\".concat((0, _util.getDisplayName)(Component), \")\"));\n  return (0, _withWebId.default)(EvaluateExpressions);\n}","map":null,"metadata":{},"sourceType":"script"}