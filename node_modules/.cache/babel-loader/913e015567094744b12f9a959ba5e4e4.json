{"ast":null,"code":"\"use strict\";\n/*! @license MIT Â©2013-2016 Ruben Verborgh, Ghent University - imec */\n\n/* Single-function HTTP(S) request module for browsers */\n\n/* Translated from https://github.com/LinkedDataFragments/Client.js/blob/master/lib/browser/Request.js */\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar parseLink = require(\"parse-link-header\");\n\nvar stream_1 = require(\"stream\"); // Headers we cannot send (see https://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method)\n\n\nvar UNSAFE_REQUEST_HEADERS = {\n  'accept-encoding': true,\n  'user-agent': true,\n  'referer': true\n};\n\nvar Requester =\n/*#__PURE__*/\nfunction () {\n  function Requester() {\n    _classCallCheck(this, Requester);\n\n    this.negotiatedResources = {};\n  } // Creates an HTTP request with the given settings\n\n\n  _createClass(Requester, [{\n    key: \"createRequest\",\n    value: function createRequest(settings) {\n      var _this = this;\n\n      // PERFORMANCE HACK:\n      // Reduce OPTIONS preflight requests by removing the Accept-Datetime header\n      // on requests for resources that are presumed to have been time-negotiated\n      if (this.negotiatedResources[this.removeQuery(settings.url)]) {\n        delete settings.headers['accept-datetime'];\n      } // Create the actual XMLHttpRequest\n\n\n      var request = new XMLHttpRequest();\n      var reqHeaders = settings.headers;\n      request.open(settings.method, settings.url, true);\n      request.timeout = settings.timeout;\n\n      for (var header in reqHeaders) {\n        if (!(header in UNSAFE_REQUEST_HEADERS) && reqHeaders[header]) {\n          request.setRequestHeader(header, reqHeaders[header]);\n        }\n      } // Create a proxy for the XMLHttpRequest\n\n\n      var requestProxy = new events_1.EventEmitter();\n\n      requestProxy.abort = function () {\n        request.abort();\n      }; // Handle the arrival of a response\n\n\n      request.onload = function () {\n        // Convert the response into an iterator\n        var response = new stream_1.Readable();\n        response.push(request.responseText || '');\n        response.push(null);\n        response.statusCode = request.status;\n        response.responseUrl = request.responseURL; // Parse the response headers\n\n        response.headers = {};\n        var resHeaders = response.headers;\n        var rawHeaders = request.getAllResponseHeaders() || '';\n        var headerMatcher = /^([^:\\n\\r]+):[ \\t]*([^\\r\\n]*)$/mg;\n        var match = headerMatcher.exec(rawHeaders);\n\n        while (match) {\n          resHeaders[match[1].toLowerCase()] = match[2];\n          match = headerMatcher.exec(rawHeaders);\n        } // Emit the response\n\n\n        requestProxy.emit('response', response); // If the resource was time-negotiated, store its queryless URI\n        // to enable the PERFORMANCE HACK explained above\n\n        if (reqHeaders['accept-datetime'] && resHeaders['memento-datetime']) {\n          var resource = _this.removeQuery(resHeaders['content-location'] || settings.url);\n\n          if (!_this.negotiatedResources[resource]) {\n            // Ensure the resource is not a timegate\n            var links = resHeaders.link && parseLink(resHeaders.link);\n\n            var timegate = _this.removeQuery(links && links.timegate && links.timegate.url);\n\n            if (resource !== timegate) {\n              _this.negotiatedResources[resource] = true;\n            }\n          }\n        }\n      }; // Report errors and timeouts\n\n\n      request.onerror = function () {\n        requestProxy.emit('error', new Error('Error requesting ' + settings.url));\n      };\n\n      request.ontimeout = function () {\n        requestProxy.emit('error', new Error('Timeout requesting ' + settings.url));\n      }; // Execute the request\n\n\n      request.send();\n      return requestProxy;\n    } // Removes the query string from a URL\n\n  }, {\n    key: \"removeQuery\",\n    value: function removeQuery(url) {\n      return url ? url.replace(/\\?.*$/, '') : '';\n    }\n  }]);\n\n  return Requester;\n}();\n\nexports.default = Requester;","map":null,"metadata":{},"sourceType":"script"}