{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DataFactory = require(\"@rdfjs/data-model\");\n\nvar rdf_string_1 = require(\"rdf-string\");\n\nvar Factory =\n/*#__PURE__*/\nfunction () {\n  function Factory(dataFactory) {\n    _classCallCheck(this, Factory);\n\n    this.dataFactory = dataFactory || DataFactory;\n    this.stringType = this.createTerm('http://www.w3.org/2001/XMLSchema#string');\n  }\n\n  _createClass(Factory, [{\n    key: \"createAlt\",\n    value: function createAlt(left, right) {\n      return {\n        type: 'alt',\n        left: left,\n        right: right\n      };\n    }\n  }, {\n    key: \"createAsk\",\n    value: function createAsk(input) {\n      return {\n        type: 'ask',\n        input: input\n      };\n    }\n  }, {\n    key: \"createBoundAggregate\",\n    value: function createBoundAggregate(variable, aggregate, expression, distinct, separator) {\n      var result = this.createAggregateExpression(aggregate, expression, distinct, separator);\n      result.variable = variable;\n      return result;\n    }\n  }, {\n    key: \"createBgp\",\n    value: function createBgp(patterns) {\n      return {\n        type: 'bgp',\n        patterns: patterns\n      };\n    }\n  }, {\n    key: \"createConstruct\",\n    value: function createConstruct(input, template) {\n      return {\n        type: 'construct',\n        input: input,\n        template: template\n      };\n    }\n  }, {\n    key: \"createDescribe\",\n    value: function createDescribe(input, terms) {\n      return {\n        type: 'describe',\n        input: input,\n        terms: terms\n      };\n    }\n  }, {\n    key: \"createDistinct\",\n    value: function createDistinct(input) {\n      return {\n        type: 'distinct',\n        input: input\n      };\n    }\n  }, {\n    key: \"createExtend\",\n    value: function createExtend(input, variable, expression) {\n      return {\n        type: 'extend',\n        input: input,\n        variable: variable,\n        expression: expression\n      };\n    }\n  }, {\n    key: \"createFrom\",\n    value: function createFrom(input, def, named) {\n      return {\n        type: 'from',\n        input: input,\n        default: def,\n        named: named\n      };\n    }\n  }, {\n    key: \"createFilter\",\n    value: function createFilter(input, expression) {\n      return {\n        type: 'filter',\n        input: input,\n        expression: expression\n      };\n    }\n  }, {\n    key: \"createGraph\",\n    value: function createGraph(input, name) {\n      return {\n        type: 'graph',\n        input: input,\n        name: name\n      };\n    }\n  }, {\n    key: \"createGroup\",\n    value: function createGroup(input, variables, aggregates) {\n      return {\n        type: 'group',\n        input: input,\n        variables: variables,\n        aggregates: aggregates\n      };\n    }\n  }, {\n    key: \"createInv\",\n    value: function createInv(path) {\n      return {\n        type: 'inv',\n        path: path\n      };\n    }\n  }, {\n    key: \"createJoin\",\n    value: function createJoin(left, right) {\n      return {\n        type: 'join',\n        left: left,\n        right: right\n      };\n    }\n  }, {\n    key: \"createLeftJoin\",\n    value: function createLeftJoin(left, right, expression) {\n      if (expression) return {\n        type: 'leftjoin',\n        left: left,\n        right: right,\n        expression: expression\n      };\n      return {\n        type: 'leftjoin',\n        left: left,\n        right: right\n      };\n    }\n  }, {\n    key: \"createLink\",\n    value: function createLink(iri) {\n      return {\n        type: 'link',\n        iri: iri\n      };\n    }\n  }, {\n    key: \"createMinus\",\n    value: function createMinus(left, right) {\n      return {\n        type: 'minus',\n        left: left,\n        right: right\n      };\n    }\n  }, {\n    key: \"createNps\",\n    value: function createNps(iris) {\n      return {\n        type: 'nps',\n        iris: iris\n      };\n    }\n  }, {\n    key: \"createOneOrMorePath\",\n    value: function createOneOrMorePath(path) {\n      return {\n        type: 'OneOrMorePath',\n        path: path\n      };\n    }\n  }, {\n    key: \"createOrderBy\",\n    value: function createOrderBy(input, expressions) {\n      return {\n        type: 'orderby',\n        input: input,\n        expressions: expressions\n      };\n    }\n  }, {\n    key: \"createPath\",\n    value: function createPath(subject, predicate, object, graph) {\n      if (graph) return {\n        type: 'path',\n        subject: subject,\n        predicate: predicate,\n        object: object,\n        graph: graph\n      };\n      return {\n        type: 'path',\n        subject: subject,\n        predicate: predicate,\n        object: object,\n        graph: this.dataFactory.defaultGraph()\n      };\n    }\n  }, {\n    key: \"createPattern\",\n    value: function createPattern(subject, predicate, object, graph) {\n      var pattern;\n      if (graph) pattern = this.dataFactory.quad(subject, predicate, object, graph);else pattern = this.dataFactory.triple(subject, predicate, object);\n      pattern.type = 'pattern';\n      return pattern;\n    }\n  }, {\n    key: \"createProject\",\n    value: function createProject(input, variables) {\n      return {\n        type: 'project',\n        input: input,\n        variables: variables\n      };\n    }\n  }, {\n    key: \"createReduced\",\n    value: function createReduced(input) {\n      return {\n        type: 'reduced',\n        input: input\n      };\n    }\n  }, {\n    key: \"createSeq\",\n    value: function createSeq(left, right) {\n      return {\n        type: 'seq',\n        left: left,\n        right: right\n      };\n    }\n  }, {\n    key: \"createService\",\n    value: function createService(input, name, silent) {\n      return {\n        type: 'service',\n        input: input,\n        name: name,\n        silent: silent\n      };\n    }\n  }, {\n    key: \"createSlice\",\n    value: function createSlice(input, start, length) {\n      if (start === undefined) start = 0;\n      if (length !== undefined) return {\n        type: 'slice',\n        input: input,\n        start: start,\n        length: length\n      };\n      return {\n        type: 'slice',\n        input: input,\n        start: start\n      };\n    }\n  }, {\n    key: \"createUnion\",\n    value: function createUnion(left, right) {\n      return {\n        type: 'union',\n        left: left,\n        right: right\n      };\n    }\n  }, {\n    key: \"createValues\",\n    value: function createValues(variables, bindings) {\n      return {\n        type: 'values',\n        variables: variables,\n        bindings: bindings\n      };\n    }\n  }, {\n    key: \"createZeroOrMorePath\",\n    value: function createZeroOrMorePath(path) {\n      return {\n        type: 'ZeroOrMorePath',\n        path: path\n      };\n    }\n  }, {\n    key: \"createZeroOrOnePath\",\n    value: function createZeroOrOnePath(path) {\n      return {\n        type: 'ZeroOrOnePath',\n        path: path\n      };\n    }\n  }, {\n    key: \"createAggregateExpression\",\n    value: function createAggregateExpression(aggregator, expression, distinct, separator) {\n      if (separator) return {\n        type: 'expression',\n        expressionType: 'aggregate',\n        aggregator: aggregator,\n        expression: expression,\n        separator: separator,\n        distinct: distinct\n      };\n      return {\n        type: 'expression',\n        expressionType: 'aggregate',\n        aggregator: aggregator,\n        expression: expression,\n        distinct: distinct\n      };\n    }\n  }, {\n    key: \"createExistenceExpression\",\n    value: function createExistenceExpression(not, input) {\n      return {\n        type: 'expression',\n        expressionType: 'existence',\n        not: not,\n        input: input\n      };\n    }\n  }, {\n    key: \"createNamedExpression\",\n    value: function createNamedExpression(name, args) {\n      return {\n        type: 'expression',\n        expressionType: 'named',\n        name: name,\n        args: args\n      };\n    }\n  }, {\n    key: \"createOperatorExpression\",\n    value: function createOperatorExpression(operator, args) {\n      return {\n        type: 'expression',\n        expressionType: 'operator',\n        operator: operator,\n        args: args\n      };\n    }\n  }, {\n    key: \"createTermExpression\",\n    value: function createTermExpression(term) {\n      return {\n        type: 'expression',\n        expressionType: 'term',\n        term: term\n      };\n    }\n  }, {\n    key: \"createTerm\",\n    value: function createTerm(str) {\n      return rdf_string_1.stringToTerm(str, this.dataFactory);\n    }\n  }]);\n\n  return Factory;\n}();\n\nexports.default = Factory;","map":null,"metadata":{},"sourceType":"script"}