{"ast":null,"code":"\"use strict\";\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _defineProperty = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar E = require(\"../expressions/Expressions\");\n\nvar Err = require(\"../util/Errors\");\n\nvar Transformation_1 = require(\"../Transformation\");\n/**\n * Evaluator that does not support EXISTS, AGGREGATES or custom Named operators.\n * Evaluates everything sync.\n */\n\n\nvar SimpleEvaluator =\n/*#__PURE__*/\nfunction () {\n  function SimpleEvaluator(algExpr) {\n    var _this$evaluators;\n\n    _classCallCheck(this, SimpleEvaluator);\n\n    this.algExpr = algExpr; // tslint:disable-next-line:member-ordering\n\n    this.evaluators = (_this$evaluators = {}, _defineProperty(_this$evaluators, E.ExpressionType.Term, this.evalTerm), _defineProperty(_this$evaluators, E.ExpressionType.Variable, this.evalVariable), _defineProperty(_this$evaluators, E.ExpressionType.Operator, this.evalOperator), _defineProperty(_this$evaluators, E.ExpressionType.SpecialOperator, this.evalSpecialOperator), _defineProperty(_this$evaluators, E.ExpressionType.Named, this.evalNamed), _defineProperty(_this$evaluators, E.ExpressionType.Existence, this.evalExistence), _defineProperty(_this$evaluators, E.ExpressionType.Aggregate, this.evalAggregate), _this$evaluators);\n    this.expr = Transformation_1.transformAlgebra(algExpr);\n  }\n\n  _createClass(SimpleEvaluator, [{\n    key: \"evaluate\",\n    value: function evaluate(mapping) {\n      var result = this.evalRecursive(this.expr, mapping);\n      return log(result).toRDF();\n    }\n  }, {\n    key: \"evaluateAsEBV\",\n    value: function evaluateAsEBV(mapping) {\n      var result = this.evalRecursive(this.expr, mapping);\n      return log(result).coerceEBV();\n    }\n  }, {\n    key: \"evaluateAsInternal\",\n    value: function evaluateAsInternal(mapping) {\n      return this.evalRecursive(this.expr, mapping);\n    }\n  }, {\n    key: \"evalRecursive\",\n    value: function evalRecursive(expr, mapping) {\n      var evaluator = this.evaluators[expr.expressionType];\n\n      if (!evaluator) {\n        throw new Err.InvalidExpressionType(expr);\n      }\n\n      return evaluator.bind(this)(expr, mapping);\n    }\n  }, {\n    key: \"evalTerm\",\n    value: function evalTerm(expr, mapping) {\n      return expr;\n    }\n  }, {\n    key: \"evalVariable\",\n    value: function evalVariable(expr, mapping) {\n      var term = mapping.get(expr.name);\n\n      if (!term) {\n        throw new Err.UnboundVariableError(expr.name, mapping);\n      }\n\n      return Transformation_1.transformTerm({\n        term: term,\n        type: 'expression',\n        expressionType: 'term'\n      });\n    }\n  }, {\n    key: \"evalOperator\",\n    value: function evalOperator(expr, mapping) {\n      var _this = this;\n\n      var args = expr.args.map(function (arg) {\n        return _this.evalRecursive(arg, mapping);\n      });\n      return expr.apply(args);\n    }\n  }, {\n    key: \"evalSpecialOperator\",\n    value: function evalSpecialOperator(expr, mapping) {\n      var evaluate = this.evalRecursive.bind(this);\n      var context = {\n        args: expr.args,\n        mapping: mapping,\n        evaluate: evaluate\n      };\n      return expr.applySync(context);\n    }\n  }, {\n    key: \"evalNamed\",\n    value: function evalNamed(expr, mapping) {\n      var _this2 = this;\n\n      var args = expr.args.map(function (arg) {\n        return _this2.evalRecursive(arg, mapping);\n      });\n      return expr.apply(args);\n    }\n  }, {\n    key: \"evalExistence\",\n    value: function evalExistence(expr, mapping) {\n      throw new UnsupportedOperation('EXISTS');\n    }\n  }, {\n    key: \"evalAggregate\",\n    value: function evalAggregate(expr, mapping) {\n      throw new UnsupportedOperation(\"aggregate \".concat(expr.name));\n    }\n  }]);\n\n  return SimpleEvaluator;\n}();\n\nexports.SimpleEvaluator = SimpleEvaluator;\n\nfunction log(val) {\n  // console.log(val);\n  return val;\n}\n\nvar UnsupportedOperation =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(UnsupportedOperation, _Error);\n\n  function UnsupportedOperation(operation) {\n    _classCallCheck(this, UnsupportedOperation);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UnsupportedOperation).call(this, \"Operation '\".concat(operation, \"' is unsupported in SimpleEvaluator\")));\n  }\n\n  return UnsupportedOperation;\n}(_wrapNativeSuper(Error));\n\nexports.UnsupportedOperation = UnsupportedOperation;","map":null,"metadata":{},"sourceType":"script"}