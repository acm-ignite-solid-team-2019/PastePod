{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DataFactory = require(\"@rdfjs/data-model\");\n/**\n * All available quad term names.\n * @type {[string , string , string , string]}\n */\n\n\nexports.QUAD_TERM_NAMES = ['subject', 'predicate', 'object', 'graph'];\n/**\n * All available triple term names.\n * @type {[string , string , string]}\n */\n\nexports.TRIPLE_TERM_NAMES = ['subject', 'predicate', 'object'];\n/**\n * Get all terms in the given quad.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,\n *                                     this term will not be returned in the array.\n *                                     (default: false)\n * @return {Term[]} The available terms in the quad.\n */\n\nfunction getTerms(quad, ignoreDefaultGraph) {\n  if (ignoreDefaultGraph && quad.graph.termType === 'DefaultGraph') {\n    return [quad.subject, quad.predicate, quad.object];\n  }\n\n  return [quad.subject, quad.predicate, quad.object, quad.graph];\n}\n\nexports.getTerms = getTerms;\n/**\n * Convert the given quad to an array of named terms.\n * This is the reverse operation of {@link collectNamedTerms}.\n * @param {BaseQuad} quad An RDFJS quad.\n * @return {INamedTerm[]} An array of named terms.\n */\n\nfunction getNamedTerms(quad) {\n  return [{\n    key: 'subject',\n    value: quad.subject\n  }, {\n    key: 'predicate',\n    value: quad.predicate\n  }, {\n    key: 'object',\n    value: quad.object\n  }, {\n    key: 'graph',\n    value: quad.graph\n  }];\n}\n\nexports.getNamedTerms = getNamedTerms;\n/**\n * Convert an array of named terms to an RDFJS quad.\n * This is the reverse operation of {@link getNamedTerms}.\n * @param {INamedTerm[]} namedTerms An array of named terms.\n * @param {(termName: QuadTermName) => Term} defaultCb An optional callback for when\n *                                                     certain terms are not available in the array.\n * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.\n * @return {Q} The resulting RDFJS quad.\n * @template Q The type of quad to output, defaults to RDF.Quad.\n */\n\nfunction collectNamedTerms(namedTerms, defaultCb, dataFactory) {\n  var elements = {};\n  namedTerms.forEach(function (namedTerm) {\n    return elements[namedTerm.key] = namedTerm.value;\n  });\n\n  if (defaultCb) {\n    elements.subject = elements.subject || defaultCb('subject');\n    elements.predicate = elements.predicate || defaultCb('predicate');\n    elements.object = elements.object || defaultCb('object');\n    elements.graph = elements.graph || defaultCb('graph');\n  }\n\n  return (dataFactory || DataFactory).quad(elements.subject, elements.predicate, elements.object, elements.graph);\n}\n\nexports.collectNamedTerms = collectNamedTerms;\n/**\n * Iterats over each term.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} cb A callback function.\n */\n\nfunction forEachTerms(quad, cb) {\n  cb(quad.subject, 'subject');\n  cb(quad.predicate, 'predicate');\n  cb(quad.object, 'object');\n  cb(quad.graph, 'graph');\n}\n\nexports.forEachTerms = forEachTerms;\n/**\n * Get all terms in the given quad that return true on the given filter function.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName) => boolean} filter A filter callback.\n * @return {Term[]} The list of matching terms.\n */\n\nfunction filterTerms(quad, filter) {\n  var terms = [];\n\n  if (filter(quad.subject, 'subject')) {\n    terms.push(quad.subject);\n  }\n\n  if (filter(quad.predicate, 'predicate')) {\n    terms.push(quad.predicate);\n  }\n\n  if (filter(quad.object, 'object')) {\n    terms.push(quad.object);\n  }\n\n  if (filter(quad.graph, 'graph')) {\n    terms.push(quad.graph);\n  }\n\n  return terms;\n}\n\nexports.filterTerms = filterTerms;\n/**\n * Get all quad term names in the given quad that return true on the given filter function.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName, all: INamedTerm[]) => boolean} filter A filter callback.\n * @return {QuadTermName[]} The list of matching quad term names.\n */\n\nfunction filterQuadTermNames(quad, filter) {\n  var names = [];\n\n  if (filter(quad.subject, 'subject')) {\n    names.push('subject');\n  }\n\n  if (filter(quad.predicate, 'predicate')) {\n    names.push('predicate');\n  }\n\n  if (filter(quad.object, 'object')) {\n    names.push('object');\n  }\n\n  if (filter(quad.graph, 'graph')) {\n    names.push('graph');\n  }\n\n  return names;\n}\n\nexports.filterQuadTermNames = filterQuadTermNames;\n/**\n * Map all terms of a quad.\n * @param {Quad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName) => Term} mapper A mapper function.\n * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.\n * @return {Quad} A new RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\n\nfunction mapTerms(quad, mapper, dataFactory) {\n  return (dataFactory || DataFactory).quad(mapper(quad.subject, 'subject'), mapper(quad.predicate, 'predicate'), mapper(quad.object, 'object'), mapper(quad.graph, 'graph'));\n}\n\nexports.mapTerms = mapTerms;\n/**\n * Reduce all terms of a quad.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(previousValue: U, currentValue: Term, key: QuadTermName) => U} reducer A reduce function.\n * @param {U} initialValue The initial value.\n * @return {U} The final value.\n */\n\nfunction reduceTerms(quad, reducer, initialValue) {\n  var value = initialValue;\n  value = reducer(value, quad.subject, 'subject');\n  value = reducer(value, quad.predicate, 'predicate');\n  value = reducer(value, quad.object, 'object');\n  return reducer(value, quad.graph, 'graph');\n}\n\nexports.reduceTerms = reduceTerms;\n/**\n * Determines whether all terms satisfy the specified test.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @return {boolean} If all terms satisfy the specified test.\n */\n\nfunction everyTerms(quad, checker) {\n  return checker(quad.subject, 'subject') && checker(quad.predicate, 'predicate') && checker(quad.object, 'object') && checker(quad.graph, 'graph');\n}\n\nexports.everyTerms = everyTerms;\n/**\n * Determines whether at least one term satisfies the specified test.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @return {boolean} If at least one term satisfies the specified test.\n */\n\nfunction someTerms(quad, checker) {\n  return checker(quad.subject, 'subject') || checker(quad.predicate, 'predicate') || checker(quad.object, 'object') || checker(quad.graph, 'graph');\n}\n\nexports.someTerms = someTerms;","map":null,"metadata":{},"sourceType":"script"}