{"ast":null,"code":"\"use strict\"; // TODO: Find a library for this\n\nvar _slicedToArray = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * TODO: Fix decently\n * Parses float datatypes (double, float).\n *\n * All invalid lexical values return undefined.\n *\n * @param value the string to interpret as a number\n */\n\nfunction parseXSDFloat(value) {\n  var numb = Number(value);\n\n  if (isNaN(numb)) {\n    if (value === 'NaN') {\n      return NaN;\n    }\n\n    if (value === 'INF') {\n      return Infinity;\n    }\n\n    if (value === '-INF') {\n      return -Infinity;\n    }\n\n    return undefined;\n  }\n\n  return numb;\n}\n\nexports.parseXSDFloat = parseXSDFloat;\n/**\n * Parses decimal datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\n\nfunction parseXSDDecimal(value) {\n  if (/^(\\-|\\+)?([0-9]+(\\.[0-9]+)?)$/.test(value)) {\n    var numb = Number(value);\n    return isNaN(numb) ? undefined : numb;\n  }\n\n  return undefined;\n}\n\nexports.parseXSDDecimal = parseXSDDecimal;\n/**\n * Parses integer datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\n\nfunction parseXSDInteger(value) {\n  if (/^(\\-|\\+)?([0-9]+)$/.test(value)) {\n    var numb = Number(value);\n    return isNaN(numb) ? undefined : numb;\n  }\n\n  return undefined;\n}\n\nexports.parseXSDInteger = parseXSDInteger;\n/**\n * Parses ISO date time strings into it's parts.\n * I found no lib providing this functionality online, but it's needed heavily\n * by the spec (functions on dates), using any form of JS DateTime will lose the\n * original timezone notation.\n *\n * Example strings:\n *  - \"2011-01-10T14:45:13.815-05:00\"\n *  - \"2011-01-10T14:45:13.815Z\"\n *  - \"2011-01-10T14:45:13Z\"\n * @param value the ISO date time string\n */\n\nfunction parseXSDDateTime(value) {\n  var _value$split = value.split('T'),\n      _value$split2 = _slicedToArray(_value$split, 2),\n      date = _value$split2[0],\n      timeAndTimeZone = _value$split2[1];\n\n  var _date$split = date.split('-'),\n      _date$split2 = _slicedToArray(_date$split, 3),\n      year = _date$split2[0],\n      month = _date$split2[1],\n      day = _date$split2[2];\n\n  var _timeAndTimeZone$spli = timeAndTimeZone.split(/[\\+\\-Z]/),\n      _timeAndTimeZone$spli2 = _slicedToArray(_timeAndTimeZone$spli, 2),\n      time = _timeAndTimeZone$spli2[0],\n      _timeZoneChopped = _timeAndTimeZone$spli2[1];\n\n  var _time$split = time.split(':'),\n      _time$split2 = _slicedToArray(_time$split, 3),\n      hours = _time$split2[0],\n      minutes = _time$split2[1],\n      seconds = _time$split2[2];\n\n  var timezoneOrNull = new RegExp(/([\\+\\-Z].*)/).exec(timeAndTimeZone);\n  var timezone = timezoneOrNull ? timezoneOrNull[0] : '';\n  return {\n    year: year,\n    month: month,\n    day: day,\n    hours: hours,\n    minutes: minutes,\n    seconds: seconds,\n    timezone: timezone\n  };\n}\n\nexports.parseXSDDateTime = parseXSDDateTime;","map":null,"metadata":{},"sourceType":"script"}