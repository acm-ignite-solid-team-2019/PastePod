{"ast":null,"code":"var XSD_INTEGER = 'http://www.w3.org/2001/XMLSchema#integer';\n\nfunction Generator(options, prefixes) {\n  this._options = options = options || {};\n  prefixes = prefixes || {};\n  this._prefixByIri = {};\n  var prefixIris = [];\n\n  for (var prefix in prefixes) {\n    var iri = prefixes[prefix];\n\n    if (isString(iri)) {\n      this._prefixByIri[iri] = prefix;\n      prefixIris.push(iri);\n    }\n  }\n\n  var iriList = prefixIris.join('|').replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n  this._prefixRegex = new RegExp('^(' + iriList + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n  this._usedPrefixes = {};\n  this._indent = isString(options.indent) ? options.indent : '  ';\n  this._newline = isString(options.newline) ? options.newline : '\\n';\n} // Converts the parsed query object into a SPARQL query\n\n\nGenerator.prototype.toQuery = function (q) {\n  var query = '';\n  if (q.queryType) query += q.queryType.toUpperCase() + ' ';\n  if (q.reduced) query += 'REDUCED ';\n  if (q.distinct) query += 'DISTINCT ';\n  if (q.variables) query += mapJoin(q.variables, undefined, function (variable) {\n    return isString(variable) ? this.toEntity(variable) : '(' + this.toExpression(variable.expression) + ' AS ' + variable.variable + ')';\n  }, this) + ' ';else if (q.template) query += this.group(q.template, true) + this._newline;\n  if (q.from) query += mapJoin(q.from.default || [], '', function (g) {\n    return 'FROM ' + this.toEntity(g) + this._newline;\n  }, this) + mapJoin(q.from.named || [], '', function (g) {\n    return 'FROM NAMED ' + this.toEntity(g) + this._newline;\n  }, this);\n  if (q.where) query += 'WHERE ' + this.group(q.where, true) + this._newline;\n  if (q.updates) query += mapJoin(q.updates, ';' + this._newline, this.toUpdate, this);\n  if (q.group) query += 'GROUP BY ' + mapJoin(q.group, undefined, function (it) {\n    var result = isString(it.expression) ? it.expression : '(' + this.toExpression(it.expression) + ')';\n    return it.variable ? '(' + result + ' AS ' + it.variable + ')' : result;\n  }, this) + this._newline;\n  if (q.having) query += 'HAVING (' + mapJoin(q.having, undefined, this.toExpression, this) + ')' + this._newline;\n  if (q.order) query += 'ORDER BY ' + mapJoin(q.order, undefined, function (it) {\n    var expr = '(' + this.toExpression(it.expression) + ')';\n    return !it.descending ? expr : 'DESC ' + expr;\n  }, this) + this._newline;\n  if (q.offset) query += 'OFFSET ' + q.offset + this._newline;\n  if (q.limit) query += 'LIMIT ' + q.limit + this._newline;\n  if (q.values) query += this.values(q); // stringify prefixes at the end to mark used ones\n\n  query = this.baseAndPrefixes(q) + query;\n  return query.trim();\n};\n\nGenerator.prototype.baseAndPrefixes = function (q) {\n  var base = q.base ? 'BASE <' + q.base + '>' + this._newline : '';\n  var prefixes = '';\n\n  for (var key in q.prefixes) {\n    if (this._options.allPrefixes || this._usedPrefixes[key]) prefixes += 'PREFIX ' + key + ': <' + q.prefixes[key] + '>' + this._newline;\n  }\n\n  return base + prefixes;\n}; // Converts the parsed SPARQL pattern into a SPARQL pattern\n\n\nGenerator.prototype.toPattern = function (pattern) {\n  var type = pattern.type || pattern instanceof Array && 'array' || (pattern.subject && pattern.predicate && pattern.object ? 'triple' : '');\n  if (!(type in this)) throw new Error('Unknown entry type: ' + type);\n  return this[type](pattern);\n};\n\nGenerator.prototype.triple = function (t) {\n  return this.toEntity(t.subject) + ' ' + this.toEntity(t.predicate) + ' ' + this.toEntity(t.object) + '.';\n};\n\nGenerator.prototype.array = function (items) {\n  return mapJoin(items, this._newline, this.toPattern, this);\n};\n\nGenerator.prototype.bgp = function (bgp) {\n  return this.encodeTriples(bgp.triples);\n};\n\nGenerator.prototype.encodeTriples = function (triples) {\n  if (!triples.length) return '';\n  var parts = [],\n      subject = '',\n      predicate = '';\n\n  for (var i = 0; i < triples.length; i++) {\n    var triple = triples[i]; // Triple with different subject\n\n    if (triple.subject !== subject) {\n      // Terminate previous triple\n      if (subject) parts.push('.' + this._newline);\n      subject = triple.subject;\n      predicate = triple.predicate;\n      parts.push(this.toEntity(subject), ' ', this.toEntity(predicate));\n    } // Triple with same subject but different predicate\n    else if (triple.predicate !== predicate) {\n        predicate = triple.predicate;\n        parts.push(';' + this._newline, this._indent, this.toEntity(predicate));\n      } // Triple with same subject and predicate\n      else {\n          parts.push(',');\n        }\n\n    parts.push(' ', this.toEntity(triple.object));\n  }\n\n  parts.push('.');\n  return parts.join('');\n};\n\nGenerator.prototype.graph = function (graph) {\n  return 'GRAPH ' + this.toEntity(graph.name) + ' ' + this.group(graph);\n};\n\nGenerator.prototype.group = function (group, inline) {\n  group = inline !== true ? this.array(group.patterns || group.triples) : this.toPattern(group.type !== 'group' ? group : group.patterns);\n  return group.indexOf(this._newline) === -1 ? '{ ' + group + ' }' : '{' + this._newline + this.indent(group) + this._newline + '}';\n};\n\nGenerator.prototype.query = function (query) {\n  return this.toQuery(query);\n};\n\nGenerator.prototype.filter = function (filter) {\n  return 'FILTER(' + this.toExpression(filter.expression) + ')';\n};\n\nGenerator.prototype.bind = function (bind) {\n  return 'BIND(' + this.toExpression(bind.expression) + ' AS ' + bind.variable + ')';\n};\n\nGenerator.prototype.optional = function (optional) {\n  return 'OPTIONAL ' + this.group(optional);\n};\n\nGenerator.prototype.union = function (union) {\n  return mapJoin(union.patterns, this._newline + 'UNION' + this._newline, function (p) {\n    return this.group(p, true);\n  }, this);\n};\n\nGenerator.prototype.minus = function (minus) {\n  return 'MINUS ' + this.group(minus);\n};\n\nGenerator.prototype.values = function (valuesList) {\n  // Gather unique keys\n  var keys = Object.keys(valuesList.values.reduce(function (keyHash, values) {\n    for (var key in values) {\n      keyHash[key] = true;\n    }\n\n    return keyHash;\n  }, {})); // Check whether simple syntax can be used\n\n  var lparen, rparen;\n\n  if (keys.length === 1) {\n    lparen = rparen = '';\n  } else {\n    lparen = '(';\n    rparen = ')';\n  } // Create value rows\n\n\n  return 'VALUES ' + lparen + keys.join(' ') + rparen + ' {' + this._newline + mapJoin(valuesList.values, this._newline, function (values) {\n    return '  ' + lparen + mapJoin(keys, undefined, function (key) {\n      return values[key] !== undefined ? this.toEntity(values[key]) : 'UNDEF';\n    }, this) + rparen;\n  }, this) + this._newline + '}';\n};\n\nGenerator.prototype.service = function (service) {\n  return 'SERVICE ' + (service.silent ? 'SILENT ' : '') + this.toEntity(service.name) + ' ' + this.group(service);\n}; // Converts the parsed expression object into a SPARQL expression\n\n\nGenerator.prototype.toExpression = function (expr) {\n  if (isString(expr)) return this.toEntity(expr);\n\n  switch (expr.type.toLowerCase()) {\n    case 'aggregate':\n      return expr.aggregation.toUpperCase() + '(' + (expr.distinct ? 'DISTINCT ' : '') + this.toExpression(expr.expression) + (expr.separator ? '; SEPARATOR = ' + this.toEntity('\"' + expr.separator + '\"') : '') + ')';\n\n    case 'functioncall':\n      return this.toEntity(expr.function) + '(' + mapJoin(expr.args, ', ', this.toExpression, this) + ')';\n\n    case 'operation':\n      var operator = expr.operator.toUpperCase(),\n          args = expr.args || [];\n\n      switch (expr.operator.toLowerCase()) {\n        // Infix operators\n        case '<':\n        case '>':\n        case '>=':\n        case '<=':\n        case '&&':\n        case '||':\n        case '=':\n        case '!=':\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n          return (isString(args[0]) ? this.toEntity(args[0]) : '(' + this.toExpression(args[0]) + ')') + ' ' + operator + ' ' + (isString(args[1]) ? this.toEntity(args[1]) : '(' + this.toExpression(args[1]) + ')');\n        // Unary operators\n\n        case '!':\n          return '!(' + this.toExpression(args[0]) + ')';\n        // IN and NOT IN\n\n        case 'notin':\n          operator = 'NOT IN';\n\n        case 'in':\n          return this.toExpression(args[0]) + ' ' + operator + '(' + (isString(args[1]) ? args[1] : mapJoin(args[1], ', ', this.toExpression, this)) + ')';\n        // EXISTS and NOT EXISTS\n\n        case 'notexists':\n          operator = 'NOT EXISTS';\n\n        case 'exists':\n          return operator + ' ' + this.group(args[0], true);\n        // Other expressions\n\n        default:\n          return operator + '(' + mapJoin(args, ', ', this.toExpression, this) + ')';\n      }\n\n    default:\n      throw new Error('Unknown expression type: ' + expr.type);\n  }\n}; // Converts the parsed entity (or property path) into a SPARQL entity\n\n\nGenerator.prototype.toEntity = function (value) {\n  // regular entity\n  if (isString(value)) {\n    switch (value[0]) {\n      // variable, * selector, or blank node\n      case '?':\n      case '$':\n      case '*':\n      case '_':\n        return value;\n      // literal\n\n      case '\"':\n        var match = value.match(/^\"([^]*)\"(?:(@.+)|\\^\\^(.+))?$/) || {},\n            lexical = match[1] || '',\n            language = match[2] || '',\n            datatype = match[3];\n        value = '\"' + lexical.replace(escape, escapeReplacer) + '\"' + language;\n\n        if (datatype) {\n          if (datatype === XSD_INTEGER && /^\\d+$/.test(lexical)) // Add space to avoid confusion with decimals in broken parsers\n            return lexical + ' ';\n          value += '^^' + this.encodeIRI(datatype);\n        }\n\n        return value;\n      // IRI\n\n      default:\n        return this.encodeIRI(value);\n    }\n  } // property path\n  else {\n      var items = value.items.map(this.toEntity, this),\n          path = value.pathType;\n\n      switch (path) {\n        // prefix operator\n        case '^':\n        case '!':\n          return path + items[0];\n        // postfix operator\n\n        case '*':\n        case '+':\n        case '?':\n          return '(' + items[0] + path + ')';\n        // infix operator\n\n        default:\n          return '(' + items.join(path) + ')';\n      }\n    }\n};\n\nvar escape = /[\"\\\\\\t\\n\\r\\b\\f]/g,\n    escapeReplacer = function escapeReplacer(c) {\n  return escapeReplacements[c];\n},\n    escapeReplacements = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n}; // Represent the IRI, as a prefixed name when possible\n\n\nGenerator.prototype.encodeIRI = function (iri) {\n  var prefixMatch = this._prefixRegex.exec(iri);\n\n  if (prefixMatch) {\n    var prefix = this._prefixByIri[prefixMatch[1]];\n    this._usedPrefixes[prefix] = true;\n    return prefix + ':' + prefixMatch[2];\n  }\n\n  return '<' + iri + '>';\n}; // Converts the parsed update object into a SPARQL update clause\n\n\nGenerator.prototype.toUpdate = function (update) {\n  switch (update.type || update.updateType) {\n    case 'load':\n      return 'LOAD' + (update.source ? ' ' + this.toEntity(update.source) : '') + (update.destination ? ' INTO GRAPH ' + this.toEntity(update.destination) : '');\n\n    case 'insert':\n      return 'INSERT DATA ' + this.group(update.insert, true);\n\n    case 'delete':\n      return 'DELETE DATA ' + this.group(update.delete, true);\n\n    case 'deletewhere':\n      return 'DELETE WHERE ' + this.group(update.delete, true);\n\n    case 'insertdelete':\n      return (update.graph ? 'WITH ' + this.toEntity(update.graph) + this._newline : '') + (update.delete.length ? 'DELETE ' + this.group(update.delete, true) + this._newline : '') + (update.insert.length ? 'INSERT ' + this.group(update.insert, true) + this._newline : '') + 'WHERE ' + this.group(update.where, true);\n\n    case 'add':\n    case 'copy':\n    case 'move':\n      return update.type.toUpperCase() + (update.source.default ? ' DEFAULT ' : ' ') + 'TO ' + this.toEntity(update.destination.name);\n\n    case 'clear':\n    case 'drop':\n      return update.type.toUpperCase() + (update.silent ? ' SILENT ' : ' ') + (update.graph.default ? 'DEFAULT' : update.graph.named ? 'NAMED' : update.graph.all ? 'ALL' : 'GRAPH ' + this.toEntity(update.graph.name));\n\n    default:\n      throw new Error('Unknown update query type: ' + update.type);\n  }\n}; // Indents each line of the string\n\n\nGenerator.prototype.indent = function (text) {\n  return text.replace(/^/gm, this._indent);\n}; // Checks whether the object is a string\n\n\nfunction isString(object) {\n  return typeof object === 'string';\n} // Maps the array with the given function, and joins the results using the separator\n\n\nfunction mapJoin(array, sep, func, self) {\n  return array.map(func, self).join(isString(sep) ? sep : ' ');\n}\n/**\n * @param options {\n *   allPrefixes: boolean,\n *   indentation: string,\n *   newline: string\n * }\n */\n\n\nmodule.exports = function SparqlGenerator(options) {\n  return {\n    stringify: function stringify(q) {\n      return new Generator(options, q.prefixes).toQuery(q);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}