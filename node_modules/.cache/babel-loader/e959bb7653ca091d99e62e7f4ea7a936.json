{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Algebra = require(\"./algebra\");\n\nvar SparqlGenerator = require('sparqljs').Generator;\n\nvar types = Algebra.types;\nvar eTypes = Algebra.expressionTypes;\nvar context;\n\nfunction toSparql(op) {\n  var generator = new SparqlGenerator();\n  return generator.stringify(toSparqlJs(op));\n}\n\nexports.toSparql = toSparql;\n\nfunction toSparqlJs(op) {\n  resetContext();\n  op = removeQuads(op);\n  var result = translateOperation(op);\n  if (result.type === 'group') return result.patterns[0];\n  return result;\n}\n\nexports.toSparqlJs = toSparqlJs;\n\nfunction flatten(s) {\n  var _Array$prototype;\n\n  return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, _toConsumableArray(s)).filter(function (x) {\n    return x;\n  });\n}\n\nfunction resetContext() {\n  context = {\n    project: false,\n    extend: [],\n    group: [],\n    aggregates: [],\n    order: []\n  };\n}\n\nfunction translateOperation(op) {\n  // this allows us to differentiate between BIND and SELECT when translating EXTEND\n  if (op.type !== types.EXTEND && op.type !== types.ORDER_BY) context.project = false;\n\n  switch (op.type) {\n    case types.EXPRESSION:\n      return translateExpression(op);\n\n    case types.ASK:\n      return translateProject(op, types.ASK);\n\n    case types.BGP:\n      return translateBgp(op);\n\n    case types.CONSTRUCT:\n      return translateConstruct(op);\n\n    case types.DESCRIBE:\n      return translateProject(op, types.DESCRIBE);\n\n    case types.DISTINCT:\n      return translateDistinct(op);\n\n    case types.EXTEND:\n      return translateExtend(op);\n\n    case types.FROM:\n      return translateFrom(op);\n\n    case types.FILTER:\n      return translateFilter(op);\n\n    case types.GRAPH:\n      return translateGraph(op);\n\n    case types.GROUP:\n      return translateGroup(op);\n\n    case types.JOIN:\n      return translateJoin(op);\n\n    case types.LEFT_JOIN:\n      return translateLeftJoin(op);\n\n    case types.MINUS:\n      return translateMinus(op);\n\n    case types.ORDER_BY:\n      return translateOrderBy(op);\n\n    case types.PATH:\n      return translatePath(op);\n\n    case types.PATTERN:\n      return translatePattern(op);\n\n    case types.PROJECT:\n      return translateProject(op, types.PROJECT);\n\n    case types.REDUCED:\n      return translateReduced(op);\n\n    case types.SERVICE:\n      return translateService(op);\n\n    case types.SLICE:\n      return translateSlice(op);\n\n    case types.UNION:\n      return translateUnion(op);\n\n    case types.VALUES:\n      return translateValues(op);\n  }\n\n  throw new Error('Unknown Operation type ' + op.type);\n}\n\nfunction translateExpression(expr) {\n  switch (expr.expressionType) {\n    case eTypes.AGGREGATE:\n      return translateAggregateExpression(expr);\n\n    case eTypes.EXISTENCE:\n      return translateExistenceExpression(expr);\n\n    case eTypes.NAMED:\n      return translateNamedExpression(expr);\n\n    case eTypes.OPERATOR:\n      return translateOperatorExpression(expr);\n\n    case eTypes.TERM:\n      return translateTermExpression(expr);\n  }\n\n  throw new Error('Unknown Expression Operation type ' + expr.expressionType);\n}\n\nfunction translatePathComponent(path) {\n  switch (path.type) {\n    case types.ALT:\n      return translateAlt(path);\n\n    case types.INV:\n      return translateInv(path);\n\n    case types.LINK:\n      return translateLink(path);\n\n    case types.NPS:\n      return translateNps(path);\n\n    case types.ONE_OR_MORE_PATH:\n      return translateOneOrMorePath(path);\n\n    case types.SEQ:\n      return translateSeq(path);\n\n    case types.ZERO_OR_MORE_PATH:\n      return translateZeroOrMorePath(path);\n\n    case types.ZERO_OR_ONE_PATH:\n      return translateZeroOrOnePath(path);\n  }\n\n  throw new Error('Unknown Path type ' + path.type);\n}\n\nfunction translateTerm(term) {\n  if (term.termType === 'BlankNode') return '_:' + term.value;\n\n  if (term.termType === 'Literal') {\n    // TODO: should check which safety checks are required\n    var lit = term;\n    var result = \"\\\"\".concat(term.value, \"\\\"\");\n    if (lit.language) result += '@' + lit.language;else if (lit.datatype && lit.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') result += '^^' + lit.datatype.value;\n    return result;\n  }\n\n  if (term.termType === 'NamedNode') return term.value;\n  if (term.termType === 'Variable') return '?' + term.value;\n  throw new Error('Unknown Term type ' + term.termType);\n} // ------------------------- EXPRESSIONS -------------------------\n\n\nfunction translateAggregateExpression(expr) {\n  var result = {\n    expression: translateExpression(expr.expression),\n    type: 'aggregate',\n    aggregation: expr.aggregator,\n    distinct: expr.distinct\n  };\n  if (expr.separator) result.separator = expr.separator;\n  return result;\n}\n\nfunction translateExistenceExpression(expr) {\n  return {\n    type: 'operation',\n    operator: expr.not ? 'notexists' : 'exists',\n    args: flatten([translateOperation(expr.input)])\n  };\n}\n\nfunction translateNamedExpression(expr) {\n  return {\n    type: 'functionCall',\n    function: translateTerm(expr.name),\n    args: expr.args.map(translateExpression)\n  };\n}\n\nfunction translateOperatorExpression(expr) {\n  if (expr.operator === 'desc') {\n    var _result = {\n      expression: translateExpression(expr.args[0])\n    };\n    _result.descending = true;\n    return _result;\n  }\n\n  var result = {\n    type: 'operation',\n    operator: expr.operator,\n    args: expr.args.map(translateExpression)\n  };\n  if (result.operator === 'in' || result.operator === 'notin') result.args = [result.args[0]].concat([result.args.slice(1)]);\n  return result;\n}\n\nfunction translateTermExpression(expr) {\n  return translateTerm(expr.term);\n} // ------------------------- OPERATIONS -------------------------\n// these get translated in the project function\n\n\nfunction translateBoundAggregate(op) {\n  return op;\n}\n\nfunction translateBgp(op) {\n  var patterns = op.patterns.map(translatePattern);\n  if (patterns.length === 0) return null;\n  return {\n    type: 'bgp',\n    triples: patterns\n  };\n}\n\nfunction translateConstruct(op) {\n  return {\n    type: 'query',\n    prefixes: {},\n    queryType: \"CONSTRUCT\",\n    template: op.template.map(translatePattern),\n    where: flatten([translateOperation(op.input)])\n  };\n}\n\nfunction translateDistinct(op) {\n  var result = translateOperation(op.input); // project is nested in group object\n\n  result.patterns[0].distinct = true;\n  return result;\n}\n\nfunction translateExtend(op) {\n  if (context.project) {\n    context.extend.push(op);\n    return translateOperation(op.input);\n  }\n\n  return flatten([translateOperation(op.input), {\n    type: 'bind',\n    variable: translateTerm(op.variable),\n    expression: translateExpression(op.expression)\n  }]);\n}\n\nfunction translateFrom(op) {\n  var result = translateOperation(op.input); // project is nested in group object\n\n  var obj = result.patterns[0];\n  obj.from = {\n    default: op.default.map(translateTerm),\n    named: op.named.map(translateTerm)\n  };\n  return result;\n}\n\nfunction translateFilter(op) {\n  return {\n    type: 'group',\n    patterns: flatten([translateOperation(op.input), {\n      type: 'filter',\n      expression: translateExpression(op.expression)\n    }])\n  };\n}\n\nfunction translateGraph(op) {\n  return {\n    type: 'graph',\n    patterns: flatten([translateOperation(op.input)]),\n    name: translateTerm(op.name)\n  };\n}\n\nfunction translateGroup(op) {\n  var _context$aggregates, _context$group;\n\n  var input = translateOperation(op.input);\n  var aggs = op.aggregates.map(translateBoundAggregate);\n\n  (_context$aggregates = context.aggregates).push.apply(_context$aggregates, _toConsumableArray(aggs)); // TODO: apply possible extends\n\n\n  (_context$group = context.group).push.apply(_context$group, _toConsumableArray(op.variables));\n\n  return input;\n}\n\nfunction translateJoin(op) {\n  return flatten([translateOperation(op.left), translateOperation(op.right)]);\n}\n\nfunction translateLeftJoin(op) {\n  var leftjoin = {\n    type: 'optional',\n    patterns: [translateOperation(op.right)]\n  };\n\n  if (op.expression) {\n    leftjoin.patterns.push({\n      type: 'filter',\n      expression: translateExpression(op.expression)\n    });\n  }\n\n  leftjoin.patterns = flatten(leftjoin.patterns);\n  return flatten([translateOperation(op.left), leftjoin]);\n}\n\nfunction translateMinus(op) {\n  var patterns = translateOperation(op.right);\n  if (patterns.type === 'group') patterns = patterns.patterns;\n  return flatten([translateOperation(op.left), {\n    type: 'minus',\n    patterns: patterns\n  }]);\n}\n\nfunction translateOrderBy(op) {\n  var _context$order;\n\n  (_context$order = context.order).push.apply(_context$order, _toConsumableArray(op.expressions));\n\n  return translateOperation(op.input);\n}\n\nfunction translatePath(op) {\n  // TODO: quads back to graph statement\n  return {\n    type: 'bgp',\n    triples: [{\n      subject: translateTerm(op.subject),\n      predicate: translatePathComponent(op.predicate),\n      object: translateTerm(op.object)\n    }]\n  };\n}\n\nfunction translatePattern(op) {\n  // TODO: quads back to graph statement\n  return {\n    subject: translateTerm(op.subject),\n    predicate: translateTerm(op.predicate),\n    object: translateTerm(op.object)\n  };\n}\n\nfunction replaceAggregatorVariables(s, map) {\n  if (typeof s === 'string') {\n    if (map[s]) return map[s];\n  } else if (Array.isArray(s)) {\n    s = s.map(function (e) {\n      return replaceAggregatorVariables(e, map);\n    });\n  } else {\n    var _arr = Object.keys(s);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var key = _arr[_i];\n      s[key] = replaceAggregatorVariables(s[key], map);\n    }\n  }\n\n  return s;\n}\n\nfunction translateProject(op, type) {\n  var result = {\n    type: 'query',\n    prefixes: {}\n  };\n\n  if (type === types.PROJECT) {\n    result.queryType = 'SELECT';\n    result.variables = op.variables.map(translateTerm);\n  } else if (type === types.ASK) {\n    result.queryType = 'ASK';\n  } else if (type === types.DESCRIBE) {\n    result.queryType = 'DESCRIBE';\n    result.variables = op.terms.map(translateTerm);\n  } // backup values in case of nested queries\n  // everything in extend, group, etc. is irrelevant for this project call\n\n\n  var extend = context.extend;\n  var group = context.group;\n  var aggregates = context.aggregates;\n  var order = context.order;\n  resetContext();\n  context.project = true;\n  var input = flatten([translateOperation(op.input)]);\n  if (input.length === 1 && input[0].type === 'group') input = input[0].patterns;\n  result.where = input;\n  var aggregators = {}; // these can not reference each other\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = context.aggregates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var agg = _step.value;\n      aggregators[translateTerm(agg.variable)] = translateExpression(agg);\n    } // do these in reverse order since variables in one extend might apply to an expression in an other extend\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var extensions = {};\n\n  for (var i = context.extend.length - 1; i >= 0; --i) {\n    var e = context.extend[i];\n    extensions[translateTerm(e.variable)] = replaceAggregatorVariables(translateExpression(e.expression), aggregators);\n  }\n\n  if (context.group.length > 0) result.group = context.group.map(translateTerm).map(function (v) {\n    if (extensions[v]) {\n      var _result2 = extensions[v];\n      delete extensions[v]; // make sure there is only 1 'AS' statement\n\n      return {\n        variable: v,\n        expression: _result2\n      };\n    }\n\n    return {\n      expression: v\n    };\n  }); // descending expressions will already be in the correct format due to the structure of those\n\n  if (context.order.length > 0) result.order = context.order.map(translateOperation).map(function (o) {\n    return o.descending ? o : {\n      expression: o\n    };\n  }); // this needs to happen after the group because it might depend on variables generated there\n\n  if (result.variables) {\n    result.variables = result.variables.map(function (v) {\n      if (extensions[v]) return {\n        variable: v,\n        expression: extensions[v]\n      };\n      return v;\n    }); // if the * didn't match any variables this would be empty\n\n    if (result.variables.length === 0) result.variables = ['*'];\n  } // convert filter to 'having' if it contains an aggregator variable\n  // could always convert, but is nicer to use filter when possible\n\n\n  if (result.where.length > 0 && result.where[result.where.length - 1].type === 'filter') {\n    var filter = result.where[result.where.length - 1];\n\n    if (objectContainsValues(filter, Object.keys(aggregators))) {\n      result.having = flatten([replaceAggregatorVariables(filter.expression, aggregators)]);\n      result.where.splice(-1);\n    }\n  }\n\n  context.extend = extend;\n  context.group = group;\n  context.aggregates = aggregates;\n  context.order = order; // subqueries need to be in a group\n\n  result = {\n    type: 'group',\n    patterns: [result]\n  };\n  return result;\n}\n\nfunction objectContainsValues(o, vals) {\n  if (Array.isArray(o)) return o.some(function (e) {\n    return objectContainsValues(e, vals);\n  });\n  if (o === Object(o)) return Object.keys(o).some(function (key) {\n    return objectContainsValues(o[key], vals);\n  });\n  return vals.indexOf(o) >= 0;\n}\n\nfunction translateReduced(op) {\n  var result = translateOperation(op.input); // project is nested in group object\n\n  result.patterns[0].reduced = true;\n  return result;\n}\n\nfunction translateService(op) {\n  var patterns = translateOperation(op.input);\n  if (patterns.type === 'group') patterns = patterns.patterns;\n  if (!Array.isArray(patterns)) patterns = [patterns];\n  return {\n    type: 'service',\n    name: translateTerm(op.name),\n    silent: op.silent,\n    patterns: patterns\n  };\n}\n\nfunction translateSlice(op) {\n  var result = translateOperation(op.input); // project is nested in group object\n\n  var obj = result.patterns[0];\n  if (op.start !== 0) obj.offset = op.start;\n  if (op.length !== undefined) obj.limit = op.length;\n  return result;\n}\n\nfunction translateUnion(op) {\n  return {\n    type: 'union',\n    patterns: flatten([translateOperation(op.left), translateOperation(op.right)])\n  };\n}\n\nfunction translateValues(op) {\n  // TODO: check if handled correctly when outside of select block\n  return {\n    type: 'values',\n    values: op.bindings.map(function (binding) {\n      var result = {};\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = op.variables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var v = _step2.value;\n          var s = '?' + v.value;\n          if (binding[s]) result[s] = translateTerm(binding[s]);else result[s] = undefined;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return result;\n    })\n  };\n} // PATH COMPONENTS\n\n\nfunction translateAlt(path) {\n  var left = translatePathComponent(path.left);\n  var right = translatePathComponent(path.right);\n\n  if (left.pathType === '!' && right.pathType === '!') {\n    return {\n      type: 'path',\n      pathType: '!',\n      items: [{\n        type: 'path',\n        pathType: '|',\n        items: [].concat(left.items, right.items)\n      }]\n    };\n  }\n\n  return {\n    type: 'path',\n    pathType: '|',\n    items: [left, right]\n  };\n}\n\nfunction translateInv(path) {\n  if (path.path.type === types.NPS) {\n    var npsPath = path.path;\n    var inv = npsPath.iris.map(function (iri) {\n      return {\n        type: 'path',\n        pathType: '^',\n        items: [translateTerm(iri)]\n      };\n    });\n    if (inv.length <= 1) return {\n      type: 'path',\n      pathType: '!',\n      items: inv\n    };\n    return {\n      type: 'path',\n      pathType: '!',\n      items: [{\n        type: 'path',\n        pathType: '|',\n        items: inv\n      }]\n    };\n  }\n\n  return {\n    type: 'path',\n    pathType: '^',\n    items: [translatePathComponent(path.path)]\n  };\n}\n\nfunction translateLink(path) {\n  return translateTerm(path.iri);\n}\n\nfunction translateNps(path) {\n  if (path.iris.length <= 1) return {\n    type: 'path',\n    pathType: '!',\n    items: path.iris.map(translateTerm)\n  };\n  return {\n    type: 'path',\n    pathType: '!',\n    items: [{\n      type: 'path',\n      pathType: '|',\n      items: path.iris.map(translateTerm)\n    }]\n  };\n}\n\nfunction translateOneOrMorePath(path) {\n  return {\n    type: 'path',\n    pathType: '+',\n    items: [translatePathComponent(path.path)]\n  };\n}\n\nfunction translateSeq(path) {\n  return {\n    type: 'path',\n    pathType: '/',\n    items: [translatePathComponent(path.left), translatePathComponent(path.right)]\n  };\n}\n\nfunction translateZeroOrMorePath(path) {\n  return {\n    type: 'path',\n    pathType: '*',\n    items: [translatePathComponent(path.path)]\n  };\n}\n\nfunction translateZeroOrOnePath(path) {\n  return {\n    type: 'path',\n    pathType: '?',\n    items: [translatePathComponent(path.path)]\n  };\n}\n\nfunction removeQuads(op) {\n  return removeQuadsRecursive(op, {});\n} // remove quads\n\n\nfunction removeQuadsRecursive(op, graphs) {\n  if (Array.isArray(op)) return op.map(function (sub) {\n    return removeQuadsRecursive(sub, graphs);\n  });\n  if (!op.type) return op;\n\n  if ((op.type === types.PATTERN || op.type === types.PATH) && op.graph && op.graph.value.length > 0) {\n    graphs[op.graph.value] = op.graph;\n    return op;\n  }\n\n  var result = {};\n  var keyGraphs = {};\n  var graphNames = {};\n\n  var _arr2 = Object.keys(op);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var _key = _arr2[_i2];\n    result[_key] = removeQuadsRecursive(op[_key], graphs);\n    var graphsArray = Object.keys(graphs);\n\n    if (graphsArray.length > 0) {\n      var graphName = graphsArray[0];\n      keyGraphs[_key] = graphs[graphName];\n      graphNames[keyGraphs[_key].value] = keyGraphs[_key];\n      delete graphs[graphName];\n    }\n  }\n\n  var graphNameSet = Object.keys(graphNames);\n\n  if (graphNameSet.length > 0) {\n    // also need to create graph statement if we are at the edge of the query\n    if (graphNameSet.length === 1 && op.type !== types.PROJECT) graphs[graphNameSet[0]] = graphNames[graphNameSet[0]];else {\n      // multiple graphs, need to create graph objects for them\n      var _arr3 = Object.keys(keyGraphs);\n\n      for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n        var key = _arr3[_i3];\n        result[key] = {\n          type: 'graph',\n          input: result[key],\n          name: keyGraphs[key]\n        };\n      }\n    }\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}