{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bus_http_1 = require(\"@comunica/bus-http\");\n\nrequire(\"isomorphic-fetch\");\n\nvar parseLink = require(\"parse-link-header\");\n/**\n * A comunica Memento Http Actor.\n */\n\n\nvar ActorHttpMemento =\n/*#__PURE__*/\nfunction (_bus_http_1$ActorHttp) {\n  _inherits(ActorHttpMemento, _bus_http_1$ActorHttp);\n\n  function ActorHttpMemento(args) {\n    _classCallCheck(this, ActorHttpMemento);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ActorHttpMemento).call(this, args));\n  }\n\n  _createClass(ActorHttpMemento, [{\n    key: \"test\",\n    value: function () {\n      var _test = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(action) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (action.context && action.context.has(exports.KEY_CONTEXT_DATETIME) && action.context.get(exports.KEY_CONTEXT_DATETIME) instanceof Date) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('This actor only handles request with a set valid datetime.');\n\n              case 2:\n                if (!(action.init && new Headers(action.init.headers || {}).has('accept-datetime'))) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error('The request already has a set datetime.');\n\n              case 4:\n                return _context.abrupt(\"return\", true);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function test(_x) {\n        return _test.apply(this, arguments);\n      }\n\n      return test;\n    }()\n  }, {\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(action) {\n        var init, headers, httpAction, result, links, followLink;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Duplicate the ActionHttp to append a datetime header to the request.\n                init = action.init ? Object.assign({}, action.init) : {};\n                headers = init.headers = new Headers(init.headers || {});\n\n                if (action.context && action.context.has(exports.KEY_CONTEXT_DATETIME)) {\n                  headers.append('accept-datetime', action.context.get(exports.KEY_CONTEXT_DATETIME).toUTCString());\n                }\n\n                httpAction = {\n                  context: action.context,\n                  input: action.input,\n                  init: init\n                }; // Execute the request and follow the timegate in the response (if any).\n\n                _context2.next = 6;\n                return this.mediatorHttp.mediate(httpAction);\n\n              case 6:\n                result = _context2.sent;\n\n                if (!(headers.has('accept-datetime') && result.headers && !result.headers.has('memento-datetime'))) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                // The links might have a timegate that can help us\n                links = result.headers.has('link') && parseLink(result.headers.get('link'));\n\n                if (!(links && links.timegate)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                result.body.cancel(); // Respond with a time-negotiated response from the timegate instead\n\n                followLink = {\n                  context: action.context,\n                  input: links.timegate.url,\n                  init: init\n                };\n                return _context2.abrupt(\"return\", this.mediatorHttp.mediate(followLink));\n\n              case 13:\n                return _context2.abrupt(\"return\", result);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function run(_x2) {\n        return _run.apply(this, arguments);\n      }\n\n      return run;\n    }()\n  }]);\n\n  return ActorHttpMemento;\n}(bus_http_1.ActorHttp);\n\nexports.ActorHttpMemento = ActorHttpMemento;\n/**\n * @type {string} Context entry for the desired datetime.\n */\n\nexports.KEY_CONTEXT_DATETIME = '@comunica/actor-http-memento:datetime';","map":null,"metadata":{},"sourceType":"script"}