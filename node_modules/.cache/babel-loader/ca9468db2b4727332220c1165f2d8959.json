{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bus_http_1 = require(\"@comunica/bus-http\");\n\nvar bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nvar bus_rdf_resolve_quad_pattern_1 = require(\"@comunica/bus-rdf-resolve-quad-pattern\");\n\nvar data_model_1 = require(\"@rdfjs/data-model\");\n\nvar asynciterator_1 = require(\"asynciterator\");\n\nvar asynciterator_promiseproxy_1 = require(\"asynciterator-promiseproxy\");\n\nvar rdf_terms_1 = require(\"rdf-terms\");\n\nvar sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nvar sparqljson_parse_1 = require(\"sparqljson-parse\");\n/**\n * A comunica SPARQL JSON RDF Resolve Quad Pattern Actor.\n */\n\n\nvar ActorRdfResolveQuadPatternSparqlJson =\n/*#__PURE__*/\nfunction (_bus_rdf_resolve_quad) {\n  _inherits(ActorRdfResolveQuadPatternSparqlJson, _bus_rdf_resolve_quad);\n\n  function ActorRdfResolveQuadPatternSparqlJson(args) {\n    _classCallCheck(this, ActorRdfResolveQuadPatternSparqlJson);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ActorRdfResolveQuadPatternSparqlJson).call(this, args));\n  }\n  /**\n   * Replace all blank nodes in a pattern with variables.\n   * If the pattern contains no blank nodes the original pattern gets returned.\n   * @param {RDF.BaseQuad} pattern A quad pattern.\n   * @return {RDF.BaseQuad} A quad pattern with no blank nodes.\n   */\n\n\n  _createClass(ActorRdfResolveQuadPatternSparqlJson, [{\n    key: \"test\",\n    value: function () {\n      var _test = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(action) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.hasContextSingleSource('sparql', action.context)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(this.name + ' requires a single source with a \\'sparql\\' endpoint to be present in the context.');\n\n              case 2:\n                return _context.abrupt(\"return\", true);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function test(_x) {\n        return _test.apply(this, arguments);\n      }\n\n      return test;\n    }()\n  }, {\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(action) {\n        var _this = this;\n\n        var endpoint, pattern, selectQuery, countQuery, metadata, data;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                endpoint = this.getContextSource(action.context).value;\n                pattern = ActorRdfResolveQuadPatternSparqlJson.replaceBlankNodes(action.pattern);\n                selectQuery = ActorRdfResolveQuadPatternSparqlJson.patternToSelectQuery(pattern);\n                countQuery = ActorRdfResolveQuadPatternSparqlJson.patternToCountQuery(pattern); // Create promise for the metadata containing the estimated count\n\n                metadata = function metadata() {\n                  return _this.queryBindings(endpoint, countQuery, action.context).then(function (bindingsStream) {\n                    return new Promise(function (resolve, reject) {\n                      bindingsStream.on('data', function (bindings) {\n                        var count = bindings.get('?count');\n\n                        if (count) {\n                          var totalItems = parseInt(count.value, 10);\n\n                          if (isNaN(totalItems)) {\n                            return resolve({\n                              totalItems: Infinity\n                            });\n                          }\n\n                          return resolve({\n                            totalItems: totalItems\n                          });\n                        } else {\n                          return resolve({\n                            totalItems: Infinity\n                          });\n                        }\n                      });\n                      bindingsStream.on('error', function () {\n                        return resolve({\n                          totalItems: Infinity\n                        });\n                      });\n                      bindingsStream.on('end', function () {\n                        return resolve({\n                          totalItems: Infinity\n                        });\n                      });\n                    });\n                  });\n                }; // Materialize the queried pattern using each found binding.\n\n\n                data = new asynciterator_promiseproxy_1.PromiseProxyIterator(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee2() {\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.next = 2;\n                          return _this.queryBindings(endpoint, selectQuery, action.context);\n\n                        case 2:\n                          _context2.t0 = function (bindings) {\n                            return rdf_terms_1.mapTerms(pattern, function (value) {\n                              if (value.termType === 'Variable') {\n                                var boundValue = bindings.get('?' + value.value);\n\n                                if (!boundValue) {\n                                  data.emit('error', new Error('The endpoint ' + endpoint + ' failed to provide a binding for ' + value.value));\n                                }\n\n                                return boundValue;\n                              }\n\n                              return value;\n                            });\n                          };\n\n                          return _context2.abrupt(\"return\", _context2.sent.map(_context2.t0));\n\n                        case 4:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, this);\n                })));\n                return _context3.abrupt(\"return\", {\n                  data: data,\n                  metadata: metadata\n                });\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function run(_x2) {\n        return _run.apply(this, arguments);\n      }\n\n      return run;\n    }()\n    /**\n     * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n     * @param {string} endpoint A SPARQL endpoint URL.\n     * @param {string} query A SPARQL query string.\n     * @param {ActionContext} context An optional context.\n     * @return {Promise<BindingsStream>} A promise resolving to a stream of bindings.\n     */\n\n  }, {\n    key: \"queryBindings\",\n    value: function () {\n      var _queryBindings = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(endpoint, query, context) {\n        var _this2 = this;\n\n        var bindingsStream, initialized, superRead;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // Parse each binding and push it in our buffered iterator\n                bindingsStream = new asynciterator_1.BufferedIterator({\n                  autoStart: false,\n                  maxBufferSize: Infinity\n                });\n                initialized = false;\n                superRead = bindingsStream._read;\n\n                bindingsStream._read = function (count, done) {\n                  if (!initialized) {\n                    initialized = true;\n\n                    _this2.fetchBindingsStream(endpoint, query, context).then(function (responseStream) {\n                      var rawBindingsStream = new sparqljson_parse_1.SparqlJsonParser({\n                        prefixVariableQuestionMark: true\n                      }).parseJsonResultsStream(responseStream);\n                      responseStream.on('error', function (error) {\n                        return rawBindingsStream.emit('error', error);\n                      });\n                      rawBindingsStream.on('error', function (error) {\n                        return bindingsStream.emit('error', error);\n                      });\n                      rawBindingsStream.on('data', function (rawBindings) {\n                        return bindingsStream._push(bus_query_operation_1.Bindings(rawBindings));\n                      });\n                      rawBindingsStream.on('end', function () {\n                        bindingsStream.close();\n                      });\n                      superRead(count, done);\n                    });\n                  } else {\n                    superRead(count, done);\n                  }\n                };\n\n                return _context4.abrupt(\"return\", bindingsStream);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function queryBindings(_x3, _x4, _x5) {\n        return _queryBindings.apply(this, arguments);\n      }\n\n      return queryBindings;\n    }()\n  }, {\n    key: \"fetchBindingsStream\",\n    value: function () {\n      var _fetchBindingsStream = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(endpoint, query, context) {\n        var url, headers, httpAction, httpResponse, responseStream;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                url = endpoint + '?query=' + encodeURIComponent(query); // Initiate request\n\n                headers = new Headers();\n                headers.append('Accept', 'application/sparql-results+json');\n                httpAction = {\n                  context: context,\n                  input: url,\n                  init: {\n                    headers: headers\n                  }\n                };\n                _context5.next = 6;\n                return this.mediatorHttp.mediate(httpAction);\n\n              case 6:\n                httpResponse = _context5.sent;\n                // Wrap WhatWG readable stream into a Node.js readable stream\n                // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n                responseStream = bus_http_1.ActorHttp.toNodeReadable(httpResponse.body); // Emit an error if the server returned an invalid response\n\n                if (!httpResponse.ok) {\n                  setImmediate(function () {\n                    return responseStream.emit('error', new Error('Invalid SPARQL endpoint (' + endpoint + ') response: ' + httpResponse.statusText));\n                  });\n                }\n\n                return _context5.abrupt(\"return\", responseStream);\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function fetchBindingsStream(_x6, _x7, _x8) {\n        return _fetchBindingsStream.apply(this, arguments);\n      }\n\n      return fetchBindingsStream;\n    }()\n  }], [{\n    key: \"replaceBlankNodes\",\n    value: function replaceBlankNodes(pattern) {\n      var variableNames = rdf_terms_1.getVariables(rdf_terms_1.getTerms(pattern)).map(function (v) {\n        return v.value;\n      }); // track the names the blank nodes get mapped to (required if the name has to change)\n\n      var blankMap = {};\n      var changed = false; // for every position, convert to a variable if there is a blank node\n\n      var result = rdf_terms_1.mapTerms(pattern, function (term) {\n        if (term.termType === 'BlankNode') {\n          var name = term.value;\n\n          if (blankMap[name]) {\n            name = blankMap[name];\n          } else {\n            if (variableNames.indexOf(name) >= 0) {\n              // increase index added to name until we find one that is available (2 loops at most)\n              var idx = 0;\n\n              while (variableNames.indexOf(name + idx) >= 0) {\n                ++idx;\n              }\n\n              name = name + idx;\n            }\n\n            blankMap[term.value] = name;\n            variableNames.push(name);\n          }\n\n          changed = true;\n          return data_model_1.variable(name);\n        } else {\n          return term;\n        }\n      });\n      return changed ? result : pattern;\n    }\n    /**\n     * Convert a quad pattern to a BGP with only that pattern.\n     * @param {RDF.pattern} quad A quad pattern.\n     * @return {Bgp} A BGP.\n     */\n\n  }, {\n    key: \"patternToBgp\",\n    value: function patternToBgp(pattern) {\n      return ActorRdfResolveQuadPatternSparqlJson.FACTORY.createBgp([ActorRdfResolveQuadPatternSparqlJson.FACTORY.createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph)]);\n    }\n    /**\n     * Convert a quad pattern to a select query for this pattern.\n     * @param {RDF.Quad} pattern A quad pattern.\n     * @return {string} A select query string.\n     */\n\n  }, {\n    key: \"patternToSelectQuery\",\n    value: function patternToSelectQuery(pattern) {\n      var variables = rdf_terms_1.getVariables(rdf_terms_1.getTerms(pattern));\n      return sparqlalgebrajs_1.toSparql(ActorRdfResolveQuadPatternSparqlJson.FACTORY.createProject(ActorRdfResolveQuadPatternSparqlJson.patternToBgp(pattern), variables));\n    }\n    /**\n     * Convert a quad pattern to a count query for the number of matching triples for this pattern.\n     * @param {RDF.Quad} pattern A quad pattern.\n     * @return {string} A count query string.\n     */\n\n  }, {\n    key: \"patternToCountQuery\",\n    value: function patternToCountQuery(pattern) {\n      return sparqlalgebrajs_1.toSparql(ActorRdfResolveQuadPatternSparqlJson.FACTORY.createProject(ActorRdfResolveQuadPatternSparqlJson.FACTORY.createExtend(ActorRdfResolveQuadPatternSparqlJson.FACTORY.createGroup(ActorRdfResolveQuadPatternSparqlJson.patternToBgp(pattern), [], [ActorRdfResolveQuadPatternSparqlJson.FACTORY.createBoundAggregate(data_model_1.variable('var0'), 'count', ActorRdfResolveQuadPatternSparqlJson.FACTORY.createTermExpression(data_model_1.namedNode('*')), false)]), data_model_1.variable('count'), ActorRdfResolveQuadPatternSparqlJson.FACTORY.createTermExpression(data_model_1.variable('var0'))), [data_model_1.variable('count')]));\n    }\n  }]);\n\n  return ActorRdfResolveQuadPatternSparqlJson;\n}(bus_rdf_resolve_quad_pattern_1.ActorRdfResolveQuadPattern);\n\nActorRdfResolveQuadPatternSparqlJson.FACTORY = new sparqlalgebrajs_1.Factory();\nexports.ActorRdfResolveQuadPatternSparqlJson = ActorRdfResolveQuadPatternSparqlJson;","map":null,"metadata":{},"sourceType":"script"}