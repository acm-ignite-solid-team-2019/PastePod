{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bus_init_1 = require(\"@comunica/bus-init\");\n\nvar bus_rdf_resolve_quad_pattern_1 = require(\"@comunica/bus-rdf-resolve-quad-pattern\");\n\nvar core_1 = require(\"@comunica/core\");\n\nvar asyncreiterable_1 = require(\"asyncreiterable\");\n\nvar rdf_string_1 = require(\"rdf-string\");\n\nvar rdf_terms_1 = require(\"rdf-terms\");\n\nvar sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A browser-safe comunica SPARQL Init Actor.\n */\n\n\nvar ActorInitSparql =\n/*#__PURE__*/\nfunction (_bus_init_1$ActorInit) {\n  _inherits(ActorInitSparql, _bus_init_1$ActorInit);\n\n  function ActorInitSparql(args) {\n    _classCallCheck(this, ActorInitSparql);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ActorInitSparql).call(this, args));\n  }\n  /**\n   * Create a copy of the given operation in which all given bindings are applied.\n   * The bindings are applied to all quad patterns and path expressions.\n   *\n   * @param {Operation} operation An operation.\n   * @param {Bindings} initialBindings Bindings to apply.\n   * @return {Operation} A copy of the given operation where all given bindings are applied.\n   */\n\n\n  _createClass(ActorInitSparql, [{\n    key: \"test\",\n    value: function () {\n      var _test = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(action) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", true);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function test(_x) {\n        return _test.apply(this, arguments);\n      }\n\n      return test;\n    }()\n    /**\n     * Evaluate the given query\n     * @param {string} query A query string.\n     * @param context An optional query context.\n     * @return {Promise<IActorQueryOperationOutput>} A promise that resolves to the query output.\n     */\n\n  }, {\n    key: \"query\",\n    value: function () {\n      var _query2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(_query, context) {\n        var key, existingEntry, combinationPromise, queryFormat, operation, resolve;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Expand shortcuts\n                for (key in context) {\n                  if (this.contextKeyShortcuts[key]) {\n                    existingEntry = context[key];\n                    context[this.contextKeyShortcuts[key]] = existingEntry;\n                    delete context[key];\n                  }\n                } // Set the default logger if none is provided\n\n\n                if (!context[core_1.KEY_CONTEXT_LOG]) {\n                  context[core_1.KEY_CONTEXT_LOG] = this.logger;\n                } // Ensure sources are an async re-iterable\n\n\n                if (Array.isArray(context[bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES])) {\n                  context[bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES] = asyncreiterable_1.AsyncReiterableArray.fromFixedData(context[bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES]);\n                }\n\n                context = core_1.ActionContext(context); // Start, but don't await, context pre-processing\n\n                combinationPromise = this.mediatorContextPreprocess.mediate({\n                  context: context\n                }); // Parse query\n\n                queryFormat = 'sparql';\n\n                if (context && context.has(exports.KEY_CONTEXT_QUERYFORMAT)) {\n                  queryFormat = context.get(exports.KEY_CONTEXT_QUERYFORMAT);\n                  context = context.delete(exports.KEY_CONTEXT_QUERYFORMAT);\n                }\n\n                _context2.next = 9;\n                return this.mediatorSparqlParse.mediate({\n                  context: context,\n                  query: _query,\n                  queryFormat: queryFormat\n                });\n\n              case 9:\n                operation = _context2.sent.operation;\n                _context2.next = 12;\n                return combinationPromise;\n\n              case 12:\n                context = _context2.sent.context;\n\n                // Apply initial bindings in context\n                if (context.has(exports.KEY_CONTEXT_INITIALBINDINGS)) {\n                  operation = ActorInitSparql.applyInitialBindings(operation, context.get(exports.KEY_CONTEXT_INITIALBINDINGS));\n                } // Optimize the query operation\n\n\n                _context2.next = 16;\n                return this.mediatorOptimizeQueryOperation.mediate({\n                  context: context,\n                  operation: operation\n                });\n\n              case 16:\n                operation = _context2.sent.operation;\n                // Execute query\n                resolve = {\n                  context: context,\n                  operation: operation\n                };\n                _context2.next = 20;\n                return this.mediatorQueryOperation.mediate(resolve);\n\n              case 20:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 21:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function query(_x2, _x3) {\n        return _query2.apply(this, arguments);\n      }\n\n      return query;\n    }()\n    /**\n     * @param context An optional context.\n     * @return {Promise<{[p: string]: number}>} All available SPARQL (weighted) result media types.\n     */\n\n  }, {\n    key: \"getResultMediaTypes\",\n    value: function () {\n      var _getResultMediaTypes = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(context) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.mediatorSparqlSerializeMediaTypeCombiner.mediate({\n                  context: context,\n                  mediaTypes: true\n                });\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent.mediaTypes);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getResultMediaTypes(_x4) {\n        return _getResultMediaTypes.apply(this, arguments);\n      }\n\n      return getResultMediaTypes;\n    }()\n    /**\n     * Convert a query result to a string stream based on a certain media type.\n     * @param {IActorQueryOperationOutput} queryResult A query result.\n     * @param {string} mediaType A media type.\n     * @param {ActionContext} context An optional context.\n     * @return {Promise<IActorSparqlSerializeOutput>} A text stream.\n     */\n\n  }, {\n    key: \"resultToString\",\n    value: function () {\n      var _resultToString = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(queryResult, mediaType, context) {\n        var handle;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                context = core_1.ActionContext(context);\n\n                if (mediaType) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                _context4.t0 = queryResult.type;\n                _context4.next = _context4.t0 === 'bindings' ? 5 : _context4.t0 === 'quads' ? 7 : 9;\n                break;\n\n              case 5:\n                mediaType = 'application/json';\n                return _context4.abrupt(\"break\", 11);\n\n              case 7:\n                mediaType = 'application/trig';\n                return _context4.abrupt(\"break\", 11);\n\n              case 9:\n                mediaType = 'simple';\n                return _context4.abrupt(\"break\", 11);\n\n              case 11:\n                handle = queryResult;\n                handle.context = context;\n                _context4.next = 15;\n                return this.mediatorSparqlSerialize.mediate({\n                  context: context,\n                  handle: handle,\n                  handleMediaType: mediaType\n                });\n\n              case 15:\n                return _context4.abrupt(\"return\", _context4.sent.handle);\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function resultToString(_x5, _x6, _x7) {\n        return _resultToString.apply(this, arguments);\n      }\n\n      return resultToString;\n    }()\n    /**\n     * Invalidate all internal caches related to the given page URL.\n     * If no page URL is given, then all pages will be invalidated.\n     * @param {string} pageUrl The page URL to invalidate.\n     * @return {Promise<any>} A promise resolving when the caches have been invalidated.\n     */\n\n  }, {\n    key: \"invalidateHttpCache\",\n    value: function invalidateHttpCache(pageUrl) {\n      return this.mediatorHttpInvalidate.mediate({\n        pageUrl: pageUrl\n      });\n    }\n  }, {\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(action) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                throw new Error('ActorInitSparql#run is not supported in the browser.');\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function run(_x8) {\n        return _run.apply(this, arguments);\n      }\n\n      return run;\n    }()\n  }], [{\n    key: \"applyInitialBindings\",\n    value: function applyInitialBindings(operation, initialBindings) {\n      var copiedOperation = {};\n\n      var _arr = Object.keys(operation);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var key = _arr[_i];\n\n        if (Array.isArray(operation[key])) {\n          if (key === 'variables') {\n            copiedOperation[key] = operation[key].filter(function (variable) {\n              return initialBindings.keySeq().indexOf(rdf_string_1.termToString(variable)) < 0;\n            });\n          } else {\n            copiedOperation[key] = operation[key].map(function (subOperation) {\n              return ActorInitSparql.applyInitialBindings(subOperation, initialBindings);\n            });\n          }\n        } else if (ActorInitSparql.ALGEBRA_TYPES.indexOf(operation[key].type) >= 0) {\n          copiedOperation[key] = ActorInitSparql.applyInitialBindings(operation[key], initialBindings);\n        } else {\n          copiedOperation[key] = operation[key];\n        }\n\n        if (operation.type === sparqlalgebrajs_1.Algebra.types.PATTERN || operation.type === sparqlalgebrajs_1.Algebra.types.PATH) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = rdf_terms_1.QUAD_TERM_NAMES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var quadTerm = _step.value;\n\n              if (!(operation.type === sparqlalgebrajs_1.Algebra.types.PATH && quadTerm === 'predicate')) {\n                var term = operation[quadTerm];\n\n                if (term.termType === 'Variable') {\n                  var termString = rdf_string_1.termToString(term);\n                  var binding = initialBindings.get(termString);\n\n                  if (binding) {\n                    copiedOperation[quadTerm] = binding;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n\n      return copiedOperation;\n    }\n  }]);\n\n  return ActorInitSparql;\n}(bus_init_1.ActorInit);\n\nActorInitSparql.ALGEBRA_TYPES = Object.keys(sparqlalgebrajs_1.Algebra.types).map(function (key) {\n  return sparqlalgebrajs_1.Algebra.types[key];\n});\nexports.ActorInitSparql = ActorInitSparql;\nexports.KEY_CONTEXT_INITIALBINDINGS = '@comunica/actor-init-sparql:initialBindings';\nexports.KEY_CONTEXT_QUERYFORMAT = '@comunica/actor-init-sparql:queryFormat';","map":null,"metadata":{},"sourceType":"script"}