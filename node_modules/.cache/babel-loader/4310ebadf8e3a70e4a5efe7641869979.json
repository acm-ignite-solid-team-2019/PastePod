{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bus_rdf_resolve_quad_pattern_1 = require(\"@comunica/bus-rdf-resolve-quad-pattern\");\n\nvar data_model_1 = require(\"@rdfjs/data-model\");\n\nvar DataFactory = require(\"@rdfjs/data-model\");\n\nvar asynciterator_1 = require(\"asynciterator\");\n\nvar asynciterator_promiseproxy_1 = require(\"asynciterator-promiseproxy\");\n\nvar asynciterator_union_1 = require(\"asynciterator-union\");\n/**\n * A FederatedQuadSource can evaluate quad pattern queries over the union of different heterogeneous sources.\n * It will call the given mediator to evaluate each quad pattern query separately.\n */\n\n\nvar FederatedQuadSource =\n/*#__PURE__*/\nfunction () {\n  function FederatedQuadSource(mediatorResolveQuadPattern, context, emptyPatterns, skipEmptyPatterns) {\n    var _this = this;\n\n    _classCallCheck(this, FederatedQuadSource);\n\n    this.mediatorResolveQuadPattern = mediatorResolveQuadPattern;\n    this.sources = context.get(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES);\n    this.contextDefault = context.delete(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES);\n    this.emptyPatterns = emptyPatterns;\n    this.skipEmptyPatterns = skipEmptyPatterns; // Initialize sources in the emptyPatterns datastructure\n\n    if (this.skipEmptyPatterns) {\n      this.sources.iterator().on('data', function (source) {\n        if (!_this.emptyPatterns.has(source)) {\n          _this.emptyPatterns.set(source, []);\n        }\n      });\n    }\n  }\n  /**\n   * Check if the given RDF term is not bound to an exact value.\n   * I.e., if it is not a Variable.\n   * @param {RDF.Term} term An RDF term.\n   * @return {boolean} If it is not bound.\n   */\n\n\n  _createClass(FederatedQuadSource, [{\n    key: \"isSourceEmpty\",\n\n    /**\n     * If the given source is guaranteed to produce an empty result for the given pattern.\n     *\n     * This prediction is done based on the 'emptyPatterns' datastructure that is stored within this actor.\n     * Every time an empty pattern is passed, this pattern is stored in this datastructure for this source.\n     * If this pattern (or a more bound pattern) is queried, we know for certain that it will be empty again.\n     * This is under the assumption that sources will remain static during query evaluation.\n     *\n     * @param {IQuerySource} source\n     * @param {RDF.BaseQuad} pattern\n     * @return {boolean}\n     */\n    value: function isSourceEmpty(source, pattern) {\n      if (!this.skipEmptyPatterns) {\n        return false;\n      }\n\n      var emptyPatterns = this.emptyPatterns.get(source);\n\n      if (emptyPatterns) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = emptyPatterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var emptyPattern = _step.value;\n\n            if (FederatedQuadSource.isSubPatternOf(pattern, emptyPattern)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"matchLazy\",\n    value: function matchLazy(subject, predicate, object, graph) {\n      var _this2 = this;\n\n      if (subject instanceof RegExp || predicate instanceof RegExp || object instanceof RegExp || graph instanceof RegExp) {\n        throw new Error(\"FederatedQuadSource does not support matching by regular expressions.\");\n      } // Counters for our metadata\n\n\n      var metadata = {\n        totalItems: 0\n      };\n      var remainingSources = 1;\n      var sourcesCount = 0; // Anonymous function to handle totalItems from metadata\n\n      var checkEmitMetadata = function checkEmitMetadata(currentTotalItems, source, pattern, lastMetadata) {\n        if (_this2.skipEmptyPatterns && !currentTotalItems) {\n          // Because another call may have added more information in the meantime\n          if (!_this2.isSourceEmpty(source, pattern)) {\n            _this2.emptyPatterns.get(source).push(pattern);\n          }\n        }\n\n        if (!remainingSources) {\n          if (lastMetadata && sourcesCount === 1) {\n            // If we only had one source, emit the metadata as-is.\n            it.emit('metadata', lastMetadata);\n          } else {\n            it.emit('metadata', metadata);\n          }\n        }\n      };\n\n      var sourcesIt = this.sources.iterator();\n      var it = new asynciterator_union_1.RoundRobinUnionIterator(sourcesIt.map(function (source) {\n        remainingSources++;\n        sourcesCount++; // If we can predict that the given source will have no bindings for the given pattern,\n        // return an empty iterator.\n\n        var pattern = data_model_1.quad(FederatedQuadSource.nullToVariable(subject), FederatedQuadSource.nullToVariable(predicate), FederatedQuadSource.nullToVariable(object), FederatedQuadSource.nullToVariable(graph)); // Prepare the context for this specific source\n\n        var context = _this2.contextDefault.set(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCE, {\n          type: source.type,\n          value: source.value\n        });\n\n        return new asynciterator_promiseproxy_1.PromiseProxyIterator(\n        /*#__PURE__*/\n        _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee() {\n          var output;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (!_this2.isSourceEmpty(source, pattern)) {\n                    _context.next = 4;\n                    break;\n                  }\n\n                  output = {\n                    data: new asynciterator_1.EmptyIterator(),\n                    metadata: function metadata() {\n                      return Promise.resolve({\n                        totalItems: 0\n                      });\n                    }\n                  };\n                  _context.next = 7;\n                  break;\n\n                case 4:\n                  _context.next = 6;\n                  return _this2.mediatorResolveQuadPattern.mediate({\n                    pattern: pattern,\n                    context: context\n                  });\n\n                case 6:\n                  output = _context.sent;\n\n                case 7:\n                  if (output.metadata) {\n                    output.metadata().then(function (subMetadata) {\n                      if (!subMetadata.totalItems && subMetadata.totalItems !== 0 || !isFinite(subMetadata.totalItems)) {\n                        metadata.totalItems = Infinity;\n                        remainingSources = 0; // We're already at infinite, so ignore any later metadata\n\n                        checkEmitMetadata(Infinity, source, pattern, subMetadata);\n                      } else {\n                        metadata.totalItems += subMetadata.totalItems;\n                        remainingSources--;\n                        checkEmitMetadata(subMetadata.totalItems, source, pattern, subMetadata);\n                      }\n                    });\n                  } else {\n                    metadata.totalItems = Infinity;\n                    remainingSources = 0; // We're already at infinite, so ignore any later metadata\n\n                    checkEmitMetadata(Infinity, source, pattern);\n                  }\n\n                  return _context.abrupt(\"return\", output.data);\n\n                case 9:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        })));\n      }));\n      it.on('newListener', function (eventName) {\n        if (eventName === 'metadata') {\n          setImmediate(function () {\n            return it._fillBuffer();\n          });\n        }\n      }); // If we have 0 sources, immediately emit metadata\n\n      sourcesIt.on('end', function () {\n        if (! --remainingSources) {\n          it.emit('metadata', metadata);\n        }\n      });\n      return it;\n    }\n  }, {\n    key: \"match\",\n    value: function match(subject, predicate, object, graph) {\n      return this.matchLazy(subject, predicate, object, graph);\n    }\n  }], [{\n    key: \"isTermBound\",\n    value: function isTermBound(term) {\n      return term.termType !== 'Variable';\n    }\n    /**\n     * Checks if the given (child) pattern is a more bound version of the given (parent) pattern.\n     * This will also return true if the patterns are equal.\n     * @param {RDF.BaseQuad} child A child pattern.\n     * @param {RDF.BaseQuad} parent A parent pattern.\n     * @return {boolean} If child is a sub-pattern of parent\n     */\n\n  }, {\n    key: \"isSubPatternOf\",\n    value: function isSubPatternOf(child, parent) {\n      return (!FederatedQuadSource.isTermBound(parent.subject) || parent.subject.equals(child.subject)) && (!FederatedQuadSource.isTermBound(parent.predicate) || parent.predicate.equals(child.predicate)) && (!FederatedQuadSource.isTermBound(parent.object) || parent.object.equals(child.object)) && (!FederatedQuadSource.isTermBound(parent.graph) || parent.graph.equals(child.graph));\n    }\n    /**\n     * Converts falsy terms to variables.\n     * This is the reverse operation of {@link ActorRdfResolveQuadPatternSource#variableToNull}.\n     * @param {Term} term A term or null.\n     * @return {Term} A term.\n     */\n\n  }, {\n    key: \"nullToVariable\",\n    value: function nullToVariable(term) {\n      if (!term) {\n        return DataFactory.variable('v');\n      }\n\n      return term;\n    }\n  }]);\n\n  return FederatedQuadSource;\n}();\n\nexports.FederatedQuadSource = FederatedQuadSource;","map":null,"metadata":{},"sourceType":"script"}