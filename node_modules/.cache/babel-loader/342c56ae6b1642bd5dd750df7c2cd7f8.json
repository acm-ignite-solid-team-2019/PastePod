{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar data_model_1 = require(\"@rdfjs/data-model\");\n\nvar asynciterator_1 = require(\"asynciterator\");\n\nvar rdf_terms_1 = require(\"rdf-terms\");\n/**\n * Transforms a bindings stream into a quad stream given a quad template.\n *\n * This conforms to the SPARQL 1.1 spec on constructing triples:\n * https://www.w3.org/TR/sparql11-query/#rConstructTriples\n */\n\n\nvar BindingsToQuadsIterator =\n/*#__PURE__*/\nfunction (_asynciterator_1$Mult) {\n  _inherits(BindingsToQuadsIterator, _asynciterator_1$Mult);\n\n  function BindingsToQuadsIterator(template, bindingsStream) {\n    var _this;\n\n    _classCallCheck(this, BindingsToQuadsIterator);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BindingsToQuadsIterator).call(this, bindingsStream));\n    _this.template = template;\n    _this.blankNodeCounter = 0;\n    return _this;\n  }\n  /**\n   * Bind the given term.\n   * If the term is a variable and the variable is bound in the bindings object,\n   * return the bindings value.\n   * If the term is a variable and the variable is not bound in the bindings object,\n   * a falsy value is returned..\n   * Otherwise, the term itself is returned.\n   * @param {Bindings}  bindings A bindings object.\n   * @param {RDF.Term}  term     An RDF term.\n   * @return {RDF.Term}          If the given term is not a variable, the term itself is returned.\n   *                             If the given term is a variable, then the bound term is returned,\n   *                             or a falsy value if it did not exist in the bindings.\n   */\n\n\n  _createClass(BindingsToQuadsIterator, [{\n    key: \"_createTransformer\",\n    value: function _createTransformer(bindings) {\n      return new asynciterator_1.ArrayIterator(BindingsToQuadsIterator.bindTemplate(bindings, this.template, this.blankNodeCounter++));\n    }\n  }], [{\n    key: \"bindTerm\",\n    value: function bindTerm(bindings, term) {\n      if (term.termType === 'Variable') {\n        return bindings.get('?' + term.value);\n      }\n\n      return term;\n    }\n    /**\n     * Bind the given quad pattern.\n     * If one of the terms was a variable AND is not bound in the bindings,\n     * a falsy value will be returned.\n     * @param {Bindings} bindings A bindings object.\n     * @param {RDF.Quad} pattern  An RDF quad.\n     * @return {RDF.Quad}         A bound RDF quad or falsy.\n     */\n\n  }, {\n    key: \"bindQuad\",\n    value: function bindQuad(bindings, pattern) {\n      try {\n        return rdf_terms_1.mapTerms(pattern, function (term) {\n          var boundTerm = BindingsToQuadsIterator.bindTerm(bindings, term);\n\n          if (!boundTerm) {\n            throw new Error('Unbound term');\n          }\n\n          return boundTerm;\n        });\n      } catch (error) {\n        return null;\n      }\n    }\n    /**\n     * Convert a blank node to a unique blank node in the given context.\n     * If the given term is not a blank node, the term itself will be returned.\n     * @param             blankNodeCounter A counter value for the blank node.\n     * @param {RDF.Term}  term             The term that should be localized.\n     * @return {RDF.Term}                  A term.\n     */\n\n  }, {\n    key: \"localizeBlankNode\",\n    value: function localizeBlankNode(blankNodeCounter, term) {\n      if (term.termType === 'BlankNode') {\n        return data_model_1.blankNode(term.value + blankNodeCounter);\n      }\n\n      return term;\n    }\n    /**\n     * Convert the given quad to a quad that only contains unique blank nodes.\n     * @param            blankNodeCounter A counter value for the blank node.\n     * @param {RDF.BaseQuad} pattern          The pattern that should be localized.\n     * @return {RDF.BaseQuad}                 A quad.\n     */\n\n  }, {\n    key: \"localizeQuad\",\n    value: function localizeQuad(blankNodeCounter, pattern) {\n      return rdf_terms_1.mapTerms(pattern, function (term) {\n        return BindingsToQuadsIterator.localizeBlankNode(blankNodeCounter, term);\n      });\n    }\n    /**\n     * Convert the given template to a list of quads based on the given bindings.\n     * @param {Bindings}    bindings           A bindings object.\n     * @param {RDF.Quad[]}  template           A list of quad patterns.\n     * @param               blankNodeCounter   A counter value for the blank node.\n     * @return {RDF.Quad[]}                    A list of quads.\n     */\n\n  }, {\n    key: \"bindTemplate\",\n    value: function bindTemplate(bindings, template, blankNodeCounter) {\n      return template // Bind variables to bound terms\n      .map(BindingsToQuadsIterator.bindQuad.bind(null, bindings)) // Remove quads that contained unbound terms, i.e., variables.\n      .filter(function (q) {\n        return !!q;\n      }) // Make sure the multiple instantiations of the template contain different blank nodes, as required by SPARQL 1.1.\n      .map(BindingsToQuadsIterator.localizeQuad.bind(null, blankNodeCounter));\n    }\n  }]);\n\n  return BindingsToQuadsIterator;\n}(asynciterator_1.MultiTransformIterator);\n\nexports.BindingsToQuadsIterator = BindingsToQuadsIterator;","map":null,"metadata":{},"sourceType":"script"}