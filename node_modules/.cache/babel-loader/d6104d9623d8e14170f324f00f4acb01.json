{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nvar sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica From Query Operation Actor.\n */\n\n\nvar ActorQueryOperationFromQuad =\n/*#__PURE__*/\nfunction (_bus_query_operation_) {\n  _inherits(ActorQueryOperationFromQuad, _bus_query_operation_);\n\n  function ActorQueryOperationFromQuad(args) {\n    _classCallCheck(this, ActorQueryOperationFromQuad);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ActorQueryOperationFromQuad).call(this, args, 'from'));\n  }\n  /**\n   * Create a deep copy of the given operation.\n   * @param {Operation} operation An operation.\n   * @param {(subOperation: Operation) => Operation} recursiveCb A callback for recursive operation calls.\n   * @return {Operation} The copied operation.\n   */\n\n\n  _createClass(ActorQueryOperationFromQuad, [{\n    key: \"testOperation\",\n    value: function () {\n      var _testOperation = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(pattern, context) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", true);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function testOperation(_x, _x2) {\n        return _testOperation.apply(this, arguments);\n      }\n\n      return testOperation;\n    }()\n  }, {\n    key: \"runOperation\",\n    value: function () {\n      var _runOperation = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(pattern, context) {\n        var operation;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                operation = ActorQueryOperationFromQuad.createOperation(pattern);\n                return _context2.abrupt(\"return\", this.mediatorQueryOperation.mediate({\n                  operation: operation,\n                  context: context\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function runOperation(_x3, _x4) {\n        return _runOperation.apply(this, arguments);\n      }\n\n      return runOperation;\n    }()\n  }], [{\n    key: \"copyOperation\",\n    value: function copyOperation(operation, recursiveCb) {\n      var copiedOperation = {};\n\n      var _arr = Object.keys(operation);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var key = _arr[_i];\n\n        if (Array.isArray(operation[key])) {\n          if (key === 'variables') {\n            copiedOperation[key] = operation[key];\n          } else {\n            copiedOperation[key] = operation[key].map(recursiveCb);\n          }\n        } else if (ActorQueryOperationFromQuad.ALGEBRA_TYPES.indexOf(operation[key].type) >= 0) {\n          copiedOperation[key] = recursiveCb(operation[key]);\n        } else {\n          copiedOperation[key] = operation[key];\n        }\n      }\n\n      return copiedOperation;\n    }\n    /**\n     * Recursively transform the given operation to use the given graphs as default graph\n     * This will (possibly) create a new operation and not modify the given operation.\n     * @param {Operation} operation An operation.\n     * @param {RDF.Term[]} defaultGraphs Graph terms.\n     * @return {Operation} A new operation.\n     */\n\n  }, {\n    key: \"applyOperationDefaultGraph\",\n    value: function applyOperationDefaultGraph(operation, defaultGraphs) {\n      var _this = this;\n\n      // If the operation is a BGP or Path, change the graph.\n      if (operation.type === 'bgp' && operation.patterns.length || operation.type === 'path') {\n        if (operation.type === 'bgp') {\n          return ActorQueryOperationFromQuad.joinOperations(operation.patterns.map(function (pattern) {\n            if (pattern.graph.termType !== 'DefaultGraph') {\n              return ActorQueryOperationFromQuad.FACTORY.createBgp([pattern]);\n            }\n\n            var bgps = defaultGraphs.map(function (graph) {\n              return ActorQueryOperationFromQuad.FACTORY.createBgp([ActorQueryOperationFromQuad.FACTORY.createPattern(pattern.subject, pattern.predicate, pattern.object, graph)]);\n            });\n            return ActorQueryOperationFromQuad.unionOperations(bgps);\n          }));\n        } else {\n          if (operation.graph.termType !== 'DefaultGraph') {\n            return operation;\n          }\n\n          var paths = defaultGraphs.map(function (graph) {\n            return ActorQueryOperationFromQuad.FACTORY.createPath(operation.subject, operation.predicate, operation.object, graph);\n          });\n          return ActorQueryOperationFromQuad.joinOperations(paths);\n        }\n      }\n\n      return ActorQueryOperationFromQuad.copyOperation(operation, function (subOperation) {\n        return _this.applyOperationDefaultGraph(subOperation, defaultGraphs);\n      });\n    }\n    /**\n     * Recursively transform the given operation to use the given graphs as named graph\n     * This will (possibly) create a new operation and not modify the given operation.\n     * @param {Operation} operation An operation.\n     * @param {RDF.Term[]} namedGraphs Graph terms.\n     * @return {Operation} A new operation.\n     */\n\n  }, {\n    key: \"applyOperationNamedGraph\",\n    value: function applyOperationNamedGraph(operation, namedGraphs, defaultGraphs) {\n      var _this2 = this;\n\n      // If the operation is a BGP or Path, change the graph.\n      if (operation.type === 'bgp' && operation.patterns.length || operation.type === 'path') {\n        var patternGraph;\n\n        if (operation.type === 'bgp') {\n          // We assume that the BGP has at least one pattern and all have the same graph.\n          patternGraph = operation.patterns[0].graph;\n        } else {\n          patternGraph = operation.graph;\n        }\n\n        if (patternGraph.termType === 'DefaultGraph') {\n          // SPARQL spec (8.2) describes that when FROM NAMED's are used without a FROM, the default graph must be empty.\n          // The FROMs are transformed before this step to a named node, so this will not apply to this case anymore.\n          return {\n            type: 'bgp',\n            patterns: []\n          };\n        } else if (patternGraph.termType === 'Variable') {\n          if (namedGraphs.length === 1) {\n            var graph = namedGraphs[0]; // If the pattern graph is a variable, replace the graph and bind the variable using VALUES\n\n            var bindings = {};\n            bindings['?' + patternGraph.value] = graph;\n            var values = ActorQueryOperationFromQuad.FACTORY.createValues([patternGraph], [bindings]);\n            var pattern;\n\n            if (operation.type === 'bgp') {\n              pattern = ActorQueryOperationFromQuad.FACTORY.createBgp(operation.patterns.map(function (p) {\n                return ActorQueryOperationFromQuad.FACTORY.createPattern(p.subject, p.predicate, p.object, graph);\n              }));\n            } else {\n              pattern = ActorQueryOperationFromQuad.FACTORY.createPath(operation.subject, operation.predicate, operation.object, graph);\n            }\n\n            return ActorQueryOperationFromQuad.FACTORY.createJoin(values, pattern);\n          } else {\n            // If the pattern graph is a variable, take the union of the pattern applied to each available named graph\n            return ActorQueryOperationFromQuad.unionOperations(namedGraphs.map(function (graph) {\n              return ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, [graph], defaultGraphs);\n            }));\n          }\n        } else {\n          // The pattern's graph is defined (including the default graphs)\n          var isNamedGraphAvailable = require('lodash.find')(namedGraphs.concat(defaultGraphs), function (namedGraph) {\n            return namedGraph.equals(patternGraph);\n          });\n\n          if (isNamedGraphAvailable) {\n            // Return the pattern as-is if the pattern's graph was selected in a FROM NAMED\n            return operation;\n          } else {\n            // No-op if the pattern's graph was not selected in a FROM NAMED.\n            return {\n              type: 'bgp',\n              patterns: []\n            };\n          }\n        }\n      }\n\n      return ActorQueryOperationFromQuad.copyOperation(operation, function (subOperation) {\n        return _this2.applyOperationNamedGraph(subOperation, namedGraphs, defaultGraphs);\n      });\n    }\n    /**\n     * Transform the given array of operations into a join operation.\n     * @param {Operation[]} operations An array of operations, must contain at least one operation.\n     * @return {Join} A join operation.\n     */\n\n  }, {\n    key: \"joinOperations\",\n    value: function joinOperations(operations) {\n      if (operations.length === 1) {\n        return operations[0];\n      } else if (operations.length === 2) {\n        return ActorQueryOperationFromQuad.FACTORY.createJoin(operations[0], operations[1]);\n      } else if (operations.length > 2) {\n        return ActorQueryOperationFromQuad.FACTORY.createJoin(operations.shift(), this.joinOperations(operations));\n      } else {\n        throw new Error('A join can only be applied on at least one operation');\n      }\n    }\n    /**\n     * Transform the given array of operations into a union operation.\n     * @param {Operation[]} operations An array of operations, must contain at least one operation.\n     * @return {Union} A union operation.\n     */\n\n  }, {\n    key: \"unionOperations\",\n    value: function unionOperations(operations) {\n      if (operations.length === 1) {\n        return operations[0];\n      } else if (operations.length === 2) {\n        return ActorQueryOperationFromQuad.FACTORY.createUnion(operations[0], operations[1]);\n      } else if (operations.length > 2) {\n        return ActorQueryOperationFromQuad.FACTORY.createUnion(operations.shift(), this.unionOperations(operations));\n      } else {\n        throw new Error('A union can only be applied on at least one operation');\n      }\n    }\n    /**\n     * Transform an operation based on the default and named graphs in the pattern.\n     *\n     * FROM sets the default graph.\n     * If multiple are available, take the union of the operation for all of them at quad-pattern level.\n     *\n     * FROM NAMED indicates which named graphs are available.\n     * This will rewrite the query so that only triples from the given named graphs can be selected.\n     *\n     * @param {From} pattern A from operation.\n     * @return {Operation} The transformed operation.\n     */\n\n  }, {\n    key: \"createOperation\",\n    value: function createOperation(pattern) {\n      var operation = pattern.input;\n\n      if (pattern.default.length) {\n        operation = ActorQueryOperationFromQuad.applyOperationDefaultGraph(operation, pattern.default);\n      }\n\n      if (pattern.named.length) {\n        operation = ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, pattern.named, pattern.default);\n      }\n\n      return operation;\n    }\n  }]);\n\n  return ActorQueryOperationFromQuad;\n}(bus_query_operation_1.ActorQueryOperationTypedMediated);\n\nActorQueryOperationFromQuad.FACTORY = new sparqlalgebrajs_1.Factory();\nActorQueryOperationFromQuad.ALGEBRA_TYPES = Object.keys(sparqlalgebrajs_1.Algebra.types).map(function (key) {\n  return sparqlalgebrajs_1.Algebra.types[key];\n});\nexports.ActorQueryOperationFromQuad = ActorQueryOperationFromQuad;","map":null,"metadata":{},"sourceType":"script"}