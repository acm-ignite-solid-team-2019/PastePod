{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar RDFString = require(\"rdf-string\");\n\nvar sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nvar E = require(\"./expressions\");\n\nvar C = require(\"./util/Consts\");\n\nvar Err = require(\"./util/Errors\");\n\nvar P = require(\"./util/Parsing\");\n\nvar functions_1 = require(\"./functions\");\n\nvar Consts_1 = require(\"./util/Consts\");\n\nfunction transformAlgebra(expr) {\n  var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!expr) {\n    throw new Err.InvalidExpression(expr);\n  }\n\n  var types = sparqlalgebrajs_1.Algebra.expressionTypes;\n\n  switch (expr.expressionType) {\n    case types.TERM:\n      return transformTerm(expr);\n\n    case types.OPERATOR:\n      return transformOperator(expr);\n\n    case types.NAMED:\n      return transformNamed(expr);\n\n    case types.EXISTENCE:\n      return transformExistence(expr, hooks.existence);\n\n    case types.AGGREGATE:\n      return transformAggregate(expr, hooks.aggregate);\n\n    default:\n      throw new Err.InvalidExpressionType(expr);\n  }\n}\n\nexports.transformAlgebra = transformAlgebra;\n\nfunction transformTerm(term) {\n  if (!term.term) {\n    throw new Err.InvalidExpression(term);\n  }\n\n  switch (term.term.termType) {\n    case 'Variable':\n      return new E.Variable(RDFString.termToString(term.term));\n\n    case 'Literal':\n      return transformLiteral(term.term);\n\n    case 'NamedNode':\n      return new E.NamedNode(term.term.value);\n\n    case 'BlankNode':\n      return new E.BlankNode(term.term.value);\n\n    default:\n      throw new Err.InvalidTermType(term);\n  }\n}\n\nexports.transformTerm = transformTerm; // TODO: Maybe do this with a map?\n// tslint:disable-next-line:no-any\n\nfunction transformLiteral(lit) {\n  if (!lit.datatype) {\n    return lit.language ? new E.LangStringLiteral(lit.value, lit.language) : new E.StringLiteral(lit.value);\n  }\n\n  switch (lit.datatype.value) {\n    case null:\n    case undefined:\n    case '':\n      {\n        return lit.language ? new E.LangStringLiteral(lit.value, lit.language) : new E.StringLiteral(lit.value);\n      }\n\n    case Consts_1.TypeURL.XSD_STRING:\n      return new E.StringLiteral(lit.value);\n\n    case Consts_1.TypeURL.RDF_LANG_STRING:\n      return new E.LangStringLiteral(lit.value, lit.language);\n\n    case Consts_1.TypeURL.XSD_DATE_TIME:\n      {\n        var val = new Date(lit.value);\n\n        if (isNaN(val.getTime())) {\n          return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n        }\n\n        return new E.DateTimeLiteral(new Date(lit.value), lit.value);\n      }\n\n    case Consts_1.TypeURL.XSD_BOOLEAN:\n      {\n        if (lit.value !== 'true' && lit.value !== 'false') {\n          return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n        }\n\n        return new E.BooleanLiteral(lit.value === 'true', lit.value);\n      }\n\n    case Consts_1.TypeURL.XSD_INTEGER:\n    case Consts_1.TypeURL.XSD_DECIMAL:\n    case Consts_1.TypeURL.XSD_NEGATIVE_INTEGER:\n    case Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER:\n    case Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER:\n    case Consts_1.TypeURL.XSD_POSITIVE_INTEGER:\n    case Consts_1.TypeURL.XSD_LONG:\n    case Consts_1.TypeURL.XSD_INT:\n    case Consts_1.TypeURL.XSD_SHORT:\n    case Consts_1.TypeURL.XSD_BYTE:\n    case Consts_1.TypeURL.XSD_UNSIGNED_LONG:\n    case Consts_1.TypeURL.XSD_UNSIGNED_INT:\n    case Consts_1.TypeURL.XSD_UNSIGNED_SHORT:\n    case Consts_1.TypeURL.XSD_UNSIGNED_BYTE:\n    case Consts_1.TypeURL.XSD_INT:\n      {\n        var _val = P.parseXSDDecimal(lit.value);\n\n        if (_val === undefined) {\n          return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n        }\n\n        return new E.NumericLiteral(_val, lit.datatype, lit.value);\n      }\n\n    case Consts_1.TypeURL.XSD_FLOAT:\n    case Consts_1.TypeURL.XSD_DOUBLE:\n      {\n        var _val2 = P.parseXSDFloat(lit.value);\n\n        if (_val2 === undefined) {\n          return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n        }\n\n        return new E.NumericLiteral(_val2, lit.datatype, lit.value);\n      }\n\n    default:\n      return new E.Literal(lit.value, lit.datatype, lit.value);\n  }\n}\n\nexports.transformLiteral = transformLiteral;\n\nfunction transformOperator(expr) {\n  if (C.SpecialOperators.contains(expr.operator)) {\n    var op = expr.operator;\n    var args = expr.args.map(function (a) {\n      return transformAlgebra(a);\n    });\n    var func = functions_1.specialFunctions.get(op);\n\n    if (!func.checkArity(args)) {\n      throw new Err.InvalidArity(args, op);\n    }\n\n    return new E.SpecialOperator(args, func.applyAsync, func.applySync);\n  } else {\n    if (!C.Operators.contains(expr.operator)) {\n      throw new Err.UnknownOperator(expr.operator);\n    }\n\n    var _op = expr.operator;\n\n    var _args = expr.args.map(function (a) {\n      return transformAlgebra(a);\n    });\n\n    var _func = functions_1.regularFunctions.get(_op);\n\n    if (!hasCorrectArity(_args, _func.arity)) {\n      throw new Err.InvalidArity(_args, _op);\n    }\n\n    return new E.Operator(_args, _func.apply);\n  }\n} // TODO: Support passing functions to override default behaviour;\n\n\nfunction transformNamed(expr) {\n  var funcName = expr.name.value;\n\n  if (!C.NamedOperators.contains(funcName)) {\n    throw new Err.UnknownNamedOperator(expr.name.value);\n  } // tslint:disable-next-line:no-any\n\n\n  var op = expr.name.value;\n  var args = expr.args.map(function (a) {\n    return transformAlgebra(a);\n  });\n  var func = functions_1.namedFunctions.get(op);\n  return new E.Named(expr.name, args, func.apply);\n}\n\nexports.transformNamed = transformNamed;\n\nfunction hasCorrectArity(args, arity) {\n  // Infinity is used to represent var-args, so it's always correct.\n  if (arity === Infinity) {\n    return true;\n  } // If the function has overloaded arity, the actual arity needs to be present.\n\n\n  if (Array.isArray(arity)) {\n    return arity.indexOf(args.length) >= 0;\n  }\n\n  return args.length === arity;\n}\n\nfunction transformAggregate(expr, hook) {\n  var name = expr.aggregator;\n\n  if (!hook) {\n    throw new Err.NoAggregator(name);\n  }\n\n  return new E.Aggregate(name, hook, expr);\n}\n\nexports.transformAggregate = transformAggregate;\n\nfunction transformExistence(expr, hook) {\n  if (!hook) {\n    throw new Err.NoExistenceHook();\n  }\n\n  return new E.Existence(hook, expr);\n}\n\nexports.transformExistence = transformExistence;","map":null,"metadata":{},"sourceType":"script"}