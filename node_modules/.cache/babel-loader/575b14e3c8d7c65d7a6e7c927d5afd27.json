{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"util\");\n/**\n * A mediator can mediate an action over a bus of actors.\n *\n * It does the following:\n * 1. Accepts an action in {@link Mediator#mediate}.\n * 2. Sends the action to the bus to test its applicability on all actors.\n * 3. It _mediates_ over these test results.\n * 4. It selects the _best_ actor.\n * 5. The action is run by the _best_ actor, and the result if returned.\n *\n * The _mediates_ and _best_ parts are filled in by subclasses of this abstract Mediator class.\n *\n * @template A The type of actor to mediator over.\n * @template I The input type of an actor.\n * @template T The test type of an actor.\n * @template O The output type of an actor.\n */\n\n\nvar Mediator =\n/*#__PURE__*/\nfunction () {\n  /**\n   * All enumerable properties from the `args` object are inherited to this mediator.\n   *\n   * @param {IMediatorArgs<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,\n   * O extends IActorOutput>} args Arguments object\n   * @param {string} args.name The name for this mediator.\n   * @param {Bus<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>} args.bus\n   *        The bus this mediator will mediate over.\n   * @throws When required arguments are missing.\n   */\n  function Mediator(args) {\n    _classCallCheck(this, Mediator);\n\n    require('lodash.assign')(this, args);\n  }\n  /**\n   * Publish the given action in the bus.\n   *\n   * This will send the test action on all actors in the bus.\n   * All actor replies will be returned.\n   *\n   * @param {I} action The action to mediate for.\n   * @return {IActorReply<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>[]}\n   * The list of actor replies.\n   */\n\n\n  _createClass(Mediator, [{\n    key: \"publish\",\n    value: function publish(action) {\n      // Test all actors in the bus\n      var actors = this.bus.publish(action);\n\n      if (!actors.length) {\n        throw new Error('No actors are able to reply to the message in the bus ' + this.bus.name + ': ' + util_1.inspect(action));\n      }\n\n      return actors;\n    }\n    /**\n     * Mediate for the given action to get an actor.\n     *\n     * This will send the test action on all actors in the bus.\n     * The actor that tests _best_ will be returned.\n     *\n     * @param {I} action The action to mediate for.\n     * @return {Promise<O extends IActorOutput>} A promise that resolves to the _best_ actor.\n     */\n\n  }, {\n    key: \"mediateActor\",\n    value: function () {\n      var _mediateActor = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(action) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.mediateWith(action, this.publish(action));\n\n              case 2:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function mediateActor(_x) {\n        return _mediateActor.apply(this, arguments);\n      }\n\n      return mediateActor;\n    }()\n    /**\n     * Mediate for the given action.\n     *\n     * This will send the test action on all actors in the bus.\n     * The action will be run on the actor that tests _best_,\n     * of which the result will be returned.\n     *\n     * @param {I} action The action to mediate for.\n     * @return {Promise<O extends IActorOutput>} A promise that resolves to the mediation result.\n     */\n\n  }, {\n    key: \"mediate\",\n    value: function () {\n      var _mediate = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(action) {\n        var actor;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.mediateActor(action);\n\n              case 2:\n                actor = _context2.sent;\n                return _context2.abrupt(\"return\", actor.runObservable(action));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function mediate(_x2) {\n        return _mediate.apply(this, arguments);\n      }\n\n      return mediate;\n    }()\n  }]);\n\n  return Mediator;\n}();\n\nexports.Mediator = Mediator;","map":null,"metadata":{},"sourceType":"script"}