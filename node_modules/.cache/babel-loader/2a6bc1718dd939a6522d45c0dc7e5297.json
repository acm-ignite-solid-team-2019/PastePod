{"ast":null,"code":"(function () {\n  var root;\n\n  if (typeof window === 'object' && window) {\n    root = window;\n  } else {\n    root = global;\n  }\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = root.Promise ? root.Promise : Promise;\n  } else if (!root.Promise) {\n    root.Promise = Promise;\n  } // Use polyfill for setImmediate for performance gains\n\n\n  var asap = root.setImmediate || function (fn) {\n    setTimeout(fn, 1);\n  }; // Polyfill for Function.prototype.bind\n\n\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  var isArray = Array.isArray || function (value) {\n    return Object.prototype.toString.call(value) === \"[object Array]\";\n  };\n\n  function Promise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = null;\n    this._value = null;\n    this._deferreds = [];\n    doResolve(fn, bind(resolve, this), bind(reject, this));\n  }\n\n  function handle(deferred) {\n    var me = this;\n\n    if (this._state === null) {\n      this._deferreds.push(deferred);\n\n      return;\n    }\n\n    asap(function () {\n      var cb = me._state ? deferred.onFulfilled : deferred.onRejected;\n\n      if (cb === null) {\n        (me._state ? deferred.resolve : deferred.reject)(me._value);\n        return;\n      }\n\n      var ret;\n\n      try {\n        ret = cb(me._value);\n      } catch (e) {\n        deferred.reject(e);\n        return;\n      }\n\n      deferred.resolve(ret);\n    });\n  }\n\n  function resolve(newValue) {\n    try {\n      //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === this) throw new TypeError('A promise cannot be resolved with itself.');\n\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n\n        if (typeof then === 'function') {\n          doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));\n          return;\n        }\n      }\n\n      this._state = true;\n      this._value = newValue;\n      finale.call(this);\n    } catch (e) {\n      reject.call(this, e);\n    }\n  }\n\n  function reject(newValue) {\n    this._state = false;\n    this._value = newValue;\n    finale.call(this);\n  }\n\n  function finale() {\n    for (var i = 0, len = this._deferreds.length; i < len; i++) {\n      handle.call(this, this._deferreds[i]);\n    }\n\n    this._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, resolve, reject) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n\n\n  function doResolve(fn, onFulfilled, onRejected) {\n    var done = false;\n\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        onFulfilled(value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        onRejected(reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      onRejected(ex);\n    }\n  }\n\n  Promise.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise.prototype.then = function (onFulfilled, onRejected) {\n    var me = this;\n    return new Promise(function (resolve, reject) {\n      handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));\n    });\n  };\n\n  Promise.all = function () {\n    var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);\n    return new Promise(function (resolve, reject) {\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n\n          args[i] = val;\n\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}