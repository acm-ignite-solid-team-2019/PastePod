{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar RDFDM = require(\"@rdfjs/data-model\");\n\nvar hash = require(\"create-hash\");\n\nvar uuid = require(\"uuid\");\n\nvar immutable_1 = require(\"immutable\");\n\nvar E = require(\"../expressions\");\n\nvar C = require(\"../util/Consts\");\n\nvar Err = require(\"../util/Errors\");\n\nvar P = require(\"../util/Parsing\");\n\nvar X = require(\"./XPathFunctions\");\n\nvar Consts_1 = require(\"../util/Consts\");\n\nvar Transformation_1 = require(\"../Transformation\");\n\nvar Helpers_1 = require(\"./Helpers\"); // ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// Begin definitions\n// ----------------------------------------------------------------------------\n// Operator Mapping\n// https://www.w3.org/TR/sparql11-query/#OperatorMapping\n// ----------------------------------------------------------------------------\n\n\nvar not = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(function (val) {\n    return Helpers_1.bool(!val.coerceEBV());\n  }).collect()\n};\nvar unaryPlus = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (val) {\n    return Helpers_1.number(val.typedValue, val.typeURL.value);\n  }).collect()\n};\nvar unaryMinus = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (val) {\n    return Helpers_1.number(-val.typedValue, val.typeURL.value);\n  }).collect()\n};\nvar multiplication = {\n  arity: 2,\n  overloads: Helpers_1.declare().arithmetic(function (left, right) {\n    return left * right;\n  }).collect()\n};\nvar division = {\n  arity: 2,\n  overloads: Helpers_1.declare().arithmetic(function (left, right) {\n    return left / right;\n  }).onBinaryTyped(['integer', 'integer'], function (left, right) {\n    if (right === 0) {\n      throw new Err.ExpressionError('Integer division by 0');\n    }\n\n    return Helpers_1.number(left / right, Consts_1.TypeURL.XSD_DECIMAL);\n  }).collect()\n};\nvar addition = {\n  arity: 2,\n  overloads: Helpers_1.declare().arithmetic(function (left, right) {\n    return left + right;\n  }).collect()\n};\nvar subtraction = {\n  arity: 2,\n  overloads: Helpers_1.declare().arithmetic(function (left, right) {\n    return left - right;\n  }).collect()\n}; // https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal\n\nvar equality = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest(function (left, right) {\n    return left === right;\n  }).stringTest(function (left, right) {\n    return left.localeCompare(right) === 0;\n  }).booleanTest(function (left, right) {\n    return left === right;\n  }).dateTimeTest(function (left, right) {\n    return left.getTime() === right.getTime();\n  }).set(['term', 'term'], function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        left = _ref2[0],\n        right = _ref2[1];\n\n    return Helpers_1.bool(RDFTermEqual(left, right));\n  }).collect()\n};\n\nfunction RDFTermEqual(_left, _right) {\n  var left = _left.toRDF();\n\n  var right = _right.toRDF();\n\n  var val = left.equals(right);\n\n  if (left.termType === 'Literal' && right.termType === 'Literal') {\n    throw new Err.RDFEqualTypeError([_left, _right]);\n  }\n\n  return val;\n}\n\nvar inequality = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest(function (left, right) {\n    return left !== right;\n  }).stringTest(function (left, right) {\n    return left.localeCompare(right) !== 0;\n  }).booleanTest(function (left, right) {\n    return left !== right;\n  }).dateTimeTest(function (left, right) {\n    return left.getTime() !== right.getTime();\n  }).set(['term', 'term'], function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        left = _ref4[0],\n        right = _ref4[1];\n\n    return Helpers_1.bool(!RDFTermEqual(left, right));\n  }).collect()\n};\nvar lesserThan = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest(function (left, right) {\n    return left < right;\n  }).stringTest(function (left, right) {\n    return left.localeCompare(right) === -1;\n  }).booleanTest(function (left, right) {\n    return left < right;\n  }).dateTimeTest(function (left, right) {\n    return left.getTime() < right.getTime();\n  }).collect()\n};\nvar greaterThan = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest(function (left, right) {\n    return left > right;\n  }).stringTest(function (left, right) {\n    return left.localeCompare(right) === 1;\n  }).booleanTest(function (left, right) {\n    return left > right;\n  }).dateTimeTest(function (left, right) {\n    return left.getTime() > right.getTime();\n  }).collect()\n};\nvar lesserThanEqual = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest(function (left, right) {\n    return left <= right;\n  }).stringTest(function (left, right) {\n    return left.localeCompare(right) !== 1;\n  }).booleanTest(function (left, right) {\n    return left <= right;\n  }).dateTimeTest(function (left, right) {\n    return left.getTime() <= right.getTime();\n  }).collect()\n};\nvar greaterThanEqual = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest(function (left, right) {\n    return left >= right;\n  }).stringTest(function (left, right) {\n    return left.localeCompare(right) !== -1;\n  }).booleanTest(function (left, right) {\n    return left >= right;\n  }).dateTimeTest(function (left, right) {\n    return left.getTime() >= right.getTime();\n  }).collect()\n}; // ----------------------------------------------------------------------------\n// Functions on RDF Terms\n// https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n// ----------------------------------------------------------------------------\n\nvar isIRI = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(function (term) {\n    return Helpers_1.bool(term.termType === 'namedNode');\n  }).collect()\n};\nvar isBlank = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(function (term) {\n    return Helpers_1.bool(term.termType === 'blankNode');\n  }).collect()\n};\nvar isLiteral = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(function (term) {\n    return Helpers_1.bool(term.termType === 'literal');\n  }).collect()\n};\nvar isNumeric = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (term) {\n    return Helpers_1.bool(true);\n  }).set(['nonlexical'], function (term) {\n    return Helpers_1.bool(false);\n  }).collect()\n};\nvar toString = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(function (term) {\n    return Helpers_1.string(term.str());\n  }).collect()\n};\nvar lang = {\n  arity: 1,\n  overloads: Helpers_1.declare().onLiteral1(function (lit) {\n    return Helpers_1.string(lit.language || '');\n  }).collect()\n};\nvar datatype = {\n  arity: 1,\n  overloads: Helpers_1.declare().onLiteral1(function (lit) {\n    return new E.NamedNode(lit.typeURL.value);\n  }).collect()\n}; // https://www.w3.org/TR/sparql11-query/#func-iri\n\nvar IRI = {\n  arity: 1,\n  overloads: Helpers_1.declare().unimplemented('IRI').collect()\n}; // https://www.w3.org/TR/sparql11-query/#func-bnode\n// id has to be distinct over all id's in dataset\n\nvar BNODE = {\n  arity: [0, 1],\n  overloads: Helpers_1.declare() // .set([], () => new E.BlankNode()) // TODO\n  .onString1Typed(function (val) {\n    return new E.BlankNode(val);\n  }).collect()\n};\nvar STRDT = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinary(['string', 'namedNode'], function (str, iri) {\n    var lit = RDFDM.literal(str.typedValue, RDFDM.namedNode(iri.value));\n    return Transformation_1.transformLiteral(lit);\n  }).collect()\n};\nvar STRLANG = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], function (val, language) {\n    return new E.LangStringLiteral(val, language);\n  }).collect()\n};\nvar UUID = {\n  arity: 0,\n  overloads: Helpers_1.declare().set([], function () {\n    return new E.NamedNode(\"urn:uuid:\".concat(uuid.v4()));\n  }).collect()\n};\nvar STRUUID = {\n  arity: 0,\n  overloads: Helpers_1.declare().set([], function () {\n    return Helpers_1.string(uuid.v4());\n  }).collect()\n}; // ----------------------------------------------------------------------------\n// Functions on strings\n// https://www.w3.org/TR/sparql11-query/#func-forms\n// ----------------------------------------------------------------------------\n\nvar STRLEN = {\n  arity: 1,\n  overloads: Helpers_1.declare().onLiteral1(function (lit) {\n    return Helpers_1.number(lit.typedValue.length, Consts_1.TypeURL.XSD_INTEGER);\n  }).collect()\n};\nvar SUBSTR = {\n  arity: [2, 3],\n  overloads: Helpers_1.declare().unimplemented('SUBSTR').collect()\n};\nvar UCASE = {\n  arity: 1,\n  overloads: Helpers_1.declare().unimplemented('UCASE').collect()\n};\nvar LCASE = {\n  arity: 1,\n  overloads: Helpers_1.declare().unimplemented('LCASE').collect()\n};\nvar STRSTARTS = {\n  arity: 2,\n  overloads: Helpers_1.declare().unimplemented('STRSTARTS').collect()\n};\nvar STRENDS = {\n  arity: 2,\n  overloads: Helpers_1.declare().unimplemented('STRENDS').collect()\n};\nvar CONTAINS = {\n  arity: 2,\n  overloads: Helpers_1.declare().unimplemented('CONTAINS').collect()\n};\nvar STRBEFORE = {\n  arity: 2,\n  overloads: Helpers_1.declare().unimplemented('STRBEFORE').collect()\n};\nvar STRAFTER = {\n  arity: 2,\n  overloads: Helpers_1.declare().unimplemented('STRAFTER').collect()\n};\nvar ENCODE_FOR_URI = {\n  arity: 1,\n  overloads: Helpers_1.declare().unimplemented('ENCODE_FOR_URI').collect()\n};\nvar CONCAT = {\n  arity: Infinity,\n  overloads: Helpers_1.declare().unimplemented('CONCAT').collect()\n};\nvar langmatches = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], function (tag, range) {\n    return Helpers_1.bool(X.langMatches(tag, range));\n  }).collect()\n};\n\nvar regex2 = function regex2(text, pattern) {\n  return Helpers_1.bool(X.matches(text, pattern));\n};\n\nvar regex3 = function regex3(text, pattern, flags) {\n  return Helpers_1.bool(X.matches(text, pattern, flags));\n};\n\nvar REGEX = {\n  arity: [2, 3],\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], regex2).onBinaryTyped(['langString', 'langString'], regex2).onTernaryTyped(['string', 'string', 'string'], regex3).onTernaryTyped(['langString', 'string', 'string'], regex3).collect()\n};\nvar REPLACE = {\n  arity: [3, 4],\n  overloads: Helpers_1.declare().unimplemented('REPLACE').collect()\n}; // ----------------------------------------------------------------------------\n// Functions on numerics\n// https://www.w3.org/TR/sparql11-query/#func-numerics\n// ----------------------------------------------------------------------------\n\nvar abs = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (num) {\n    return Helpers_1.number(Math.abs(num.typedValue), num.typeURL.value);\n  }).collect()\n};\nvar round = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (num) {\n    return Helpers_1.number(Math.round(num.typedValue), num.typeURL.value);\n  }).collect()\n};\nvar ceil = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (num) {\n    return Helpers_1.number(Math.ceil(num.typedValue), num.typeURL.value);\n  }).collect()\n};\nvar floor = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (num) {\n    return Helpers_1.number(Math.floor(num.typedValue), num.typeURL.value);\n  }).collect()\n};\nvar rand = {\n  arity: 0,\n  overloads: Helpers_1.declare().set([], function () {\n    return Helpers_1.number(Math.random(), Consts_1.TypeURL.XSD_DOUBLE);\n  }).collect()\n}; // ----------------------------------------------------------------------------\n// Functions on Dates and Times\n// https://www.w3.org/TR/sparql11-query/#func-date-time\n// ----------------------------------------------------------------------------\n\nfunction parseDate(dateLit) {\n  // TODO: This is assuming datelits always have a string\n  return P.parseXSDDateTime(dateLit.strValue);\n}\n\nvar now = {\n  arity: 0,\n  overloads: Helpers_1.declare().unimplemented('now').collect()\n};\nvar year = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(function (date) {\n    return Helpers_1.number(Number(parseDate(date).year), Consts_1.TypeURL.XSD_INTEGER);\n  }).collect()\n};\nvar month = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(function (date) {\n    return Helpers_1.number(Number(parseDate(date).month), Consts_1.TypeURL.XSD_INTEGER);\n  }).collect()\n};\nvar day = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(function (date) {\n    return Helpers_1.number(Number(parseDate(date).day), Consts_1.TypeURL.XSD_INTEGER);\n  }).collect()\n};\nvar hours = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(function (date) {\n    return Helpers_1.number(Number(parseDate(date).hours), Consts_1.TypeURL.XSD_INTEGER);\n  }).collect()\n};\nvar minutes = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(function (date) {\n    return Helpers_1.number(Number(parseDate(date).minutes), Consts_1.TypeURL.XSD_INTEGER);\n  }).collect()\n};\nvar seconds = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(function (date) {\n    return Helpers_1.number(Number(parseDate(date).seconds), Consts_1.TypeURL.XSD_DECIMAL);\n  }).collect()\n};\nvar timezone = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(function (date) {\n    var duration = X.formatDayTimeDuration(parseDate(date).timezone);\n\n    if (!duration) {\n      throw new Err.InvalidTimezoneCall(date.strValue);\n    }\n\n    return new E.Literal(duration, C.make(Consts_1.TypeURL.XSD_DAYTIME_DURATION), duration);\n  }).collect()\n};\nvar tz = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(function (date) {\n    return Helpers_1.string(parseDate(date).timezone);\n  }).collect()\n}; // ----------------------------------------------------------------------------\n// Hash functions\n// https://www.w3.org/TR/sparql11-query/#func-hash\n// ----------------------------------------------------------------------------\n\nvar MD5 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(function (str) {\n    return Helpers_1.string(hash('md5').update(str).digest('hex'));\n  }).collect()\n};\nvar SHA1 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(function (str) {\n    return Helpers_1.string(hash('sha1').update(str).digest('hex'));\n  }).collect()\n};\nvar SHA256 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(function (str) {\n    return Helpers_1.string(hash('sha256').update(str).digest('hex'));\n  }).collect()\n};\nvar SHA384 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(function (str) {\n    return Helpers_1.string(hash('sha384').update(str).digest('hex'));\n  }).collect()\n};\nvar SHA512 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(function (str) {\n    return Helpers_1.string(hash('sha512').update(str).digest('hex'));\n  }).collect()\n}; // End definitions.\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n/*\n * Collect all the definitions from above into an object\n */\n\nvar _definitions = {\n  // --------------------------------------------------------------------------\n  // Operator Mapping\n  // https://www.w3.org/TR/sparql11-query/#OperatorMapping\n  // --------------------------------------------------------------------------\n  '!': not,\n  'UPLUS': unaryPlus,\n  'UMINUS': unaryMinus,\n  '*': multiplication,\n  '/': division,\n  '+': addition,\n  '-': subtraction,\n  '=': equality,\n  '!=': inequality,\n  '<': lesserThan,\n  '>': greaterThan,\n  '<=': lesserThanEqual,\n  '>=': greaterThanEqual,\n  // --------------------------------------------------------------------------\n  // Functions on RDF Terms\n  // https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n  // --------------------------------------------------------------------------\n  'isiri': isIRI,\n  'isblank': isBlank,\n  'isliteral': isLiteral,\n  'isnumeric': isNumeric,\n  'str': toString,\n  'lang': lang,\n  'datatype': datatype,\n  'iri': IRI,\n  'uri': IRI,\n  'BNODE': BNODE,\n  'strdt': STRDT,\n  'strlang': STRLANG,\n  'uuid': UUID,\n  'struuid': STRUUID,\n  // --------------------------------------------------------------------------\n  // Functions on strings\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  'strlen': STRLEN,\n  'substr': SUBSTR,\n  'ucase': UCASE,\n  'lcase': LCASE,\n  'strstarts': STRSTARTS,\n  'strends': STRENDS,\n  'contains': CONTAINS,\n  'strbefore': STRBEFORE,\n  'strafter': STRAFTER,\n  'encode_for_uri': ENCODE_FOR_URI,\n  'concat': CONCAT,\n  'langmatches': langmatches,\n  'regex': REGEX,\n  'replace': REPLACE,\n  // --------------------------------------------------------------------------\n  // Functions on numerics\n  // https://www.w3.org/TR/sparql11-query/#func-numerics\n  // --------------------------------------------------------------------------\n  'abs': abs,\n  'round': round,\n  'ceil': ceil,\n  'floor': floor,\n  'rand': rand,\n  // --------------------------------------------------------------------------\n  // Functions on Dates and Times\n  // https://www.w3.org/TR/sparql11-query/#func-date-time\n  // --------------------------------------------------------------------------\n  'now': now,\n  'year': year,\n  'month': month,\n  'day': day,\n  'hours': hours,\n  'minutes': minutes,\n  'seconds': seconds,\n  'timezone': timezone,\n  'tz': tz,\n  // --------------------------------------------------------------------------\n  // Hash functions\n  // https://www.w3.org/TR/sparql11-query/#func-hash\n  // --------------------------------------------------------------------------\n  'md5': MD5,\n  'sha1': SHA1,\n  'sha256': SHA256,\n  'sha384': SHA384,\n  'sha512': SHA512\n};\nexports.definitions = immutable_1.Map(_definitions);","map":null,"metadata":{},"sourceType":"script"}