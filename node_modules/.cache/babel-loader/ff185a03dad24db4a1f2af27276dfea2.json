{"ast":null,"code":"\"use strict\";\n/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _slicedToArray = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar immutable_1 = require(\"immutable\");\n\nvar E = require(\"../expressions\");\n\nvar C = require(\"../util/Consts\");\n\nvar Err = require(\"../util/Errors\");\n\nvar Consts_1 = require(\"../util/Consts\");\n\nfunction declare() {\n  return new Builder();\n}\n\nexports.declare = declare;\n\nvar Builder =\n/*#__PURE__*/\nfunction () {\n  function Builder() {\n    _classCallCheck(this, Builder);\n\n    this.implementations = [];\n  }\n\n  _createClass(Builder, [{\n    key: \"collect\",\n    value: function collect() {\n      return map(this.implementations);\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      // tslint:disable-next-line:no-console\n      console.log(this.implementations);\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(impl) {\n      this.implementations.push(impl);\n      return this;\n    }\n  }, {\n    key: \"set\",\n    value: function set(argTypes, func) {\n      var types = immutable_1.List(argTypes);\n      return this.add(new Impl({\n        types: types,\n        func: func\n      }));\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(_ref) {\n      var from = _ref.from,\n          to = _ref.to;\n      var last = this.implementations.length - 1;\n\n      var _from = immutable_1.List(from);\n\n      for (var i = last; i >= 0; i--) {\n        var impl = this.implementations[i];\n\n        if (impl.get('types').equals(_from)) {\n          return this.set(to, impl.get('func'));\n        }\n      }\n\n      throw new Err.UnexpectedError('Tried to copy implementation, but types not found', {\n        from: from,\n        to: to\n      });\n    }\n  }, {\n    key: \"onUnary\",\n    value: function onUnary(type, op) {\n      return this.set([type], function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 1),\n            val = _ref3[0];\n\n        return op(val);\n      });\n    }\n  }, {\n    key: \"onUnaryTyped\",\n    value: function onUnaryTyped(type, op) {\n      return this.set([type], function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 1),\n            val = _ref5[0];\n\n        return op(val.typedValue);\n      });\n    }\n  }, {\n    key: \"onBinary\",\n    value: function onBinary(types, op) {\n      return this.set(types, function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n            left = _ref7[0],\n            right = _ref7[1];\n\n        return op(left, right);\n      });\n    }\n  }, {\n    key: \"onBinaryTyped\",\n    value: function onBinaryTyped(types, op) {\n      return this.set(types, function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            left = _ref9[0],\n            right = _ref9[1];\n\n        return op(left.typedValue, right.typedValue);\n      });\n    }\n  }, {\n    key: \"onTernaryTyped\",\n    value: function onTernaryTyped(types, op) {\n      return this.set(types, function (_ref10) {\n        var _ref11 = _slicedToArray(_ref10, 3),\n            a1 = _ref11[0],\n            a2 = _ref11[1],\n            a3 = _ref11[2];\n\n        return op(a1.typedValue, a2.typedValue, a3.typedValue);\n      });\n    }\n  }, {\n    key: \"unimplemented\",\n    value: function unimplemented(msg) {\n      for (var arity = 0; arity <= 5; arity++) {\n        var types = Array(arity).fill('term');\n\n        var func = function func(_args) {\n          throw new Err.UnimplementedError(msg);\n        };\n\n        this.set(types, func);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"onTerm1\",\n    value: function onTerm1(op) {\n      return this.set(['term'], function (_ref12) {\n        var _ref13 = _slicedToArray(_ref12, 1),\n            term = _ref13[0];\n\n        return op(term);\n      });\n    }\n  }, {\n    key: \"onLiteral1\",\n    value: function onLiteral1(op) {\n      return this.set(['literal'], function (_ref14) {\n        var _ref15 = _slicedToArray(_ref14, 1),\n            term = _ref15[0];\n\n        return op(term);\n      });\n    }\n  }, {\n    key: \"onBoolean1\",\n    value: function onBoolean1(op) {\n      return this.set(['boolean'], function (_ref16) {\n        var _ref17 = _slicedToArray(_ref16, 1),\n            lit = _ref17[0];\n\n        return op(lit);\n      });\n    }\n  }, {\n    key: \"onBoolean1Typed\",\n    value: function onBoolean1Typed(op) {\n      return this.set(['boolean'], function (_ref18) {\n        var _ref19 = _slicedToArray(_ref18, 1),\n            lit = _ref19[0];\n\n        return op(lit.typedValue);\n      });\n    }\n  }, {\n    key: \"onString1\",\n    value: function onString1(op) {\n      return this.set(['string'], function (_ref20) {\n        var _ref21 = _slicedToArray(_ref20, 1),\n            lit = _ref21[0];\n\n        return op(lit);\n      });\n    }\n  }, {\n    key: \"onString1Typed\",\n    value: function onString1Typed(op) {\n      return this.set(['string'], function (_ref22) {\n        var _ref23 = _slicedToArray(_ref22, 1),\n            lit = _ref23[0];\n\n        return op(lit.typedValue);\n      });\n    }\n  }, {\n    key: \"onStringly1\",\n    value: function onStringly1(op) {\n      return this.set(['string'], function (_ref24) {\n        var _ref25 = _slicedToArray(_ref24, 1),\n            lit = _ref25[0];\n\n        return op(lit);\n      }).set(['langString'], function (_ref26) {\n        var _ref27 = _slicedToArray(_ref26, 1),\n            lit = _ref27[0];\n\n        return op(lit);\n      });\n    }\n  }, {\n    key: \"onNumeric1\",\n    value: function onNumeric1(op) {\n      return this.set(['integer'], function (_ref28) {\n        var _ref29 = _slicedToArray(_ref28, 1),\n            val = _ref29[0];\n\n        return op(val);\n      }).set(['decimal'], function (_ref30) {\n        var _ref31 = _slicedToArray(_ref30, 1),\n            val = _ref31[0];\n\n        return op(val);\n      }).set(['float'], function (_ref32) {\n        var _ref33 = _slicedToArray(_ref32, 1),\n            val = _ref33[0];\n\n        return op(val);\n      }).set(['double'], function (_ref34) {\n        var _ref35 = _slicedToArray(_ref34, 1),\n            val = _ref35[0];\n\n        return op(val);\n      }).invalidLexicalForm(['nonlexical'], 1);\n    }\n  }, {\n    key: \"onDateTime1\",\n    value: function onDateTime1(op) {\n      return this.set(['date'], function (_ref36) {\n        var _ref37 = _slicedToArray(_ref36, 1),\n            val = _ref37[0];\n\n        return op(val);\n      }).invalidLexicalForm(['nonlexical'], 1);\n    }\n    /*\n    * Arithetic Operators take numbers, and return numbers.\n    * Check 'numeric' for behaviour of the generic numeric helper.\n    * https://www.w3.org/TR/sparql11-query/#OperatorMapping\n    */\n\n  }, {\n    key: \"arithmetic\",\n    value: function arithmetic(op) {\n      var opFac = function opFac(dt) {\n        return function (_ref38) {\n          var _ref39 = _slicedToArray(_ref38, 2),\n              left = _ref39[0],\n              right = _ref39[1];\n\n          return number(op(left.typedValue, right.typedValue), dt || Consts_1.TypeURL.XSD_FLOAT);\n        };\n      };\n\n      return this.numeric(opFac);\n    }\n  }, {\n    key: \"numberTest\",\n    value: function numberTest(test) {\n      var func = function func(_ref40) {\n        var _ref41 = _slicedToArray(_ref40, 2),\n            left = _ref41[0],\n            right = _ref41[1];\n\n        var result = test(left.typedValue, right.typedValue);\n        return bool(result);\n      };\n\n      return this.numeric(function () {\n        return func;\n      });\n    }\n  }, {\n    key: \"stringTest\",\n    value: function stringTest(test) {\n      return this.set(['string', 'string'], function (_ref42) {\n        var _ref43 = _slicedToArray(_ref42, 2),\n            left = _ref43[0],\n            right = _ref43[1];\n\n        var result = test(left.typedValue, right.typedValue);\n        return bool(result);\n      }).invalidLexicalForm(['nonlexical', 'string'], 1).invalidLexicalForm(['string', 'nonlexical'], 2);\n    }\n  }, {\n    key: \"booleanTest\",\n    value: function booleanTest(test) {\n      return this.set(['boolean', 'boolean'], function (_ref44) {\n        var _ref45 = _slicedToArray(_ref44, 2),\n            left = _ref45[0],\n            right = _ref45[1];\n\n        var result = test(left.typedValue, right.typedValue);\n        return bool(result);\n      }).invalidLexicalForm(['nonlexical', 'boolean'], 1).invalidLexicalForm(['boolean', 'nonlexical'], 2);\n    }\n  }, {\n    key: \"dateTimeTest\",\n    value: function dateTimeTest(test) {\n      return this.set(['date', 'date'], function (_ref46) {\n        var _ref47 = _slicedToArray(_ref46, 2),\n            left = _ref47[0],\n            right = _ref47[1];\n\n        var result = test(left.typedValue, right.typedValue);\n        return bool(result);\n      }).invalidLexicalForm(['nonlexical', 'date'], 1).invalidLexicalForm(['date', 'nonlexical'], 2);\n    }\n  }, {\n    key: \"numeric\",\n    value: function numeric(opFac) {\n      return this.set(['integer', 'integer'], opFac(Consts_1.TypeURL.XSD_INTEGER)).set(['integer', 'decimal'], opFac()).set(['integer', 'float'], opFac()).set(['integer', 'double'], opFac()).invalidLexicalForm(['integer', 'nonlexical'], 2).set(['decimal', 'integer'], opFac()).set(['decimal', 'decimal'], opFac(Consts_1.TypeURL.XSD_DECIMAL)).set(['decimal', 'float'], opFac()).set(['decimal', 'double'], opFac()).invalidLexicalForm(['decimal', 'nonlexical'], 2).set(['float', 'integer'], opFac()).set(['float', 'decimal'], opFac()).set(['float', 'float'], opFac(Consts_1.TypeURL.XSD_FLOAT)).set(['float', 'double'], opFac()).invalidLexicalForm(['float', 'nonlexical'], 2).set(['double', 'integer'], opFac()).set(['double', 'decimal'], opFac()).set(['double', 'float'], opFac()).set(['double', 'double'], opFac(Consts_1.TypeURL.XSD_DOUBLE)).invalidLexicalForm(['double', 'nonlexical'], 2).invalidLexicalForm(['nonlexical', 'integer'], 1).invalidLexicalForm(['nonlexical', 'decimal'], 1).invalidLexicalForm(['nonlexical', 'float'], 1).invalidLexicalForm(['nonlexical', 'double'], 1);\n    }\n  }, {\n    key: \"invalidLexicalForm\",\n    value: function invalidLexicalForm(types, index) {\n      return this.set(types, function (args) {\n        throw new Err.InvalidLexicalForm(args[index - 1].toRDF());\n      });\n    }\n  }, {\n    key: \"chain\",\n    value: function chain(impls) {\n      this.implementations = this.implementations.concat(impls);\n      return this;\n    }\n  }]);\n\n  return Builder;\n}();\n\nexports.Builder = Builder;\nvar implDefaults = {\n  types: [],\n  func: function func() {\n    var msg = 'Implementation not set yet declared as implemented';\n    throw new Err.UnexpectedError(msg);\n  }\n};\n\nvar Impl =\n/*#__PURE__*/\nfunction (_immutable_1$Record) {\n  _inherits(Impl, _immutable_1$Record);\n\n  function Impl(params) {\n    _classCallCheck(this, Impl);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Impl).call(this, params));\n  }\n\n  _createClass(Impl, [{\n    key: \"get\",\n    value: function get(value) {\n      return _get(_getPrototypeOf(Impl.prototype), \"get\", this).call(this, value);\n    }\n  }, {\n    key: \"toPair\",\n    value: function toPair() {\n      return [this.get('types'), this.get('func')];\n    }\n  }]);\n\n  return Impl;\n}(immutable_1.Record(implDefaults));\n\nexports.Impl = Impl;\n\nfunction map(implementations) {\n  var typeImplPair = implementations.map(function (i) {\n    return i.toPair();\n  });\n  return immutable_1.Map(typeImplPair);\n}\n\nexports.map = map; // ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nfunction bool(val) {\n  return new E.BooleanLiteral(val);\n}\n\nexports.bool = bool;\n\nfunction number(num, dt) {\n  return new E.NumericLiteral(num, C.make(dt || Consts_1.TypeURL.XSD_FLOAT), undefined);\n}\n\nexports.number = number;\n\nfunction numberFromString(str, dt) {\n  var num = Number(str);\n  return new E.NumericLiteral(num, C.make(dt || Consts_1.TypeURL.XSD_FLOAT), undefined);\n}\n\nexports.numberFromString = numberFromString;\n\nfunction string(s) {\n  return new E.StringLiteral(s);\n}\n\nexports.string = string;\n\nfunction dateTime(date, str) {\n  return new E.DateTimeLiteral(date, str);\n}\n\nexports.dateTime = dateTime;","map":null,"metadata":{},"sourceType":"script"}