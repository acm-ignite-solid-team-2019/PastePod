{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * This class of error will be thrown when an expression errors.\n * Various reasons this could happen are:\n *   - invalid types for the given operator\n *   - unbound variables\n *   - invalid lexical forms\n *   - ...\n *\n * The distinction is made so that one can catch this specific type\n * and handle it accordingly to the SPARQL spec (relevant for e.g. FILTER, EXTEND),\n * while others (programming errors) can be re-thrown.\n *\n * @see isExpressionError\n */\n\nvar ExpressionError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(ExpressionError, _Error);\n\n  function ExpressionError() {\n    _classCallCheck(this, ExpressionError);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ExpressionError).apply(this, arguments));\n  }\n\n  return ExpressionError;\n}(_wrapNativeSuper(Error));\n\nexports.ExpressionError = ExpressionError;\n/**\n * Checks whether a given error is an {@link ExpressionError}.\n * Also useful for mocking in tests for covering all branches.\n *\n * @see ExpressionError\n */\n\nfunction isExpressionError(error) {\n  return error instanceof ExpressionError;\n}\n\nexports.isExpressionError = isExpressionError;\n/**\n * A literal has an invalid lexical form for the datatype it is accompanied by.\n * This error is only thrown when the term is as function argument that requires\n * a valid lexical form.\n */\n\nvar InvalidLexicalForm =\n/*#__PURE__*/\nfunction (_ExpressionError) {\n  _inherits(InvalidLexicalForm, _ExpressionError);\n\n  function InvalidLexicalForm(arg) {\n    var _this;\n\n    _classCallCheck(this, InvalidLexicalForm);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InvalidLexicalForm).call(this, \"Invalid lexical form '\".concat(pp(arg), \"'\")));\n    _this.arg = arg;\n    return _this;\n  }\n\n  return InvalidLexicalForm;\n}(ExpressionError);\n\nexports.InvalidLexicalForm = InvalidLexicalForm;\n/**\n * A variable in the expression was not bound.\n */\n\nvar UnboundVariableError =\n/*#__PURE__*/\nfunction (_ExpressionError2) {\n  _inherits(UnboundVariableError, _ExpressionError2);\n\n  function UnboundVariableError(variable, bindings) {\n    var _this2;\n\n    _classCallCheck(this, UnboundVariableError);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(UnboundVariableError).call(this, \"Unbound variable '\".concat(pp(variable), \"'\")));\n    _this2.variable = variable;\n    _this2.bindings = bindings;\n    return _this2;\n  }\n\n  return UnboundVariableError;\n}(ExpressionError);\n\nexports.UnboundVariableError = UnboundVariableError;\n/**\n * An invalid term was being coerced to an Effective Boolean Value.\n *\n * See the {@link https://www.w3.org/TR/sparql11-query/#ebv | SPARQL docs}\n * on EBVs.\n */\n\nvar EBVCoercionError =\n/*#__PURE__*/\nfunction (_ExpressionError3) {\n  _inherits(EBVCoercionError, _ExpressionError3);\n\n  function EBVCoercionError(arg) {\n    var _this3;\n\n    _classCallCheck(this, EBVCoercionError);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(EBVCoercionError).call(this, \"Cannot coerce term to EBV '\".concat(pp(arg), \"'\")));\n    _this3.arg = arg;\n    return _this3;\n  }\n\n  return EBVCoercionError;\n}(ExpressionError);\n\nexports.EBVCoercionError = EBVCoercionError;\n/**\n * An equality test was done on literals with unsupported datatypes.\n *\n * See {@link https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal | term equality spec}.\n */\n\nvar RDFEqualTypeError =\n/*#__PURE__*/\nfunction (_ExpressionError4) {\n  _inherits(RDFEqualTypeError, _ExpressionError4);\n\n  function RDFEqualTypeError(args) {\n    var _this4;\n\n    _classCallCheck(this, RDFEqualTypeError);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(RDFEqualTypeError).call(this, 'Equality test for literals with unsupported datatypes'));\n    _this4.args = args;\n    return _this4;\n  }\n\n  return RDFEqualTypeError;\n}(ExpressionError);\n\nexports.RDFEqualTypeError = RDFEqualTypeError;\n/**\n * All the expressions in a COALESCE call threw errors.\n */\n\nvar CoalesceError =\n/*#__PURE__*/\nfunction (_ExpressionError5) {\n  _inherits(CoalesceError, _ExpressionError5);\n\n  function CoalesceError(errors) {\n    var _this5;\n\n    _classCallCheck(this, CoalesceError);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(CoalesceError).call(this, 'All COALESCE arguments threw errors'));\n    _this5.errors = errors;\n    return _this5;\n  }\n\n  return CoalesceError;\n}(ExpressionError);\n\nexports.CoalesceError = CoalesceError;\n/**\n * No arguments to an IN call where equal, and at least one threw an error.\n */\n\nvar InError =\n/*#__PURE__*/\nfunction (_ExpressionError6) {\n  _inherits(InError, _ExpressionError6);\n\n  function InError(errors) {\n    var _this6;\n\n    _classCallCheck(this, InError);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(InError).call(this, 'Some argument to IN errorred and none where equal. ' + errors.map(function (err) {\n      return \"(\".concat(err.toString(), \") \");\n    }).join('and ')));\n    _this6.errors = errors;\n    return _this6;\n  }\n\n  return InError;\n}(ExpressionError);\n\nexports.InError = InError;\n/**\n * Literals were passed to an operator that doesn't support their datatypes.\n */\n\nvar InvalidArgumentTypes =\n/*#__PURE__*/\nfunction (_ExpressionError7) {\n  _inherits(InvalidArgumentTypes, _ExpressionError7);\n\n  function InvalidArgumentTypes(args, op) {\n    var _this7;\n\n    _classCallCheck(this, InvalidArgumentTypes);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(InvalidArgumentTypes).call(this, \"Argument types not valid for operator: '\".concat(pp(op), \"' with '\").concat(pp(args))));\n    _this7.args = args;\n    _this7.op = op;\n    return _this7;\n  }\n\n  return InvalidArgumentTypes;\n}(ExpressionError);\n\nexports.InvalidArgumentTypes = InvalidArgumentTypes;\n/**\n * An invalid typecast happened.\n */\n\nvar CastError =\n/*#__PURE__*/\nfunction (_ExpressionError8) {\n  _inherits(CastError, _ExpressionError8);\n\n  function CastError(arg, cast) {\n    var _this8;\n\n    _classCallCheck(this, CastError);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(CastError).call(this, \"Invalid cast: '\".concat(pp(arg), \"' to '\").concat(pp(cast), \"'\")));\n    _this8.arg = arg;\n    return _this8;\n  }\n\n  return CastError;\n}(ExpressionError);\n\nexports.CastError = CastError;\n\nvar InvalidTimezoneCall =\n/*#__PURE__*/\nfunction (_ExpressionError9) {\n  _inherits(InvalidTimezoneCall, _ExpressionError9);\n\n  function InvalidTimezoneCall(dateString) {\n    var _this9;\n\n    _classCallCheck(this, InvalidTimezoneCall);\n\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(InvalidTimezoneCall).call(this, \"TIMEZONE call on \".concat(dateString, \" which has no timezone\")));\n    _this9.dateString = dateString;\n    return _this9;\n  }\n\n  return InvalidTimezoneCall;\n}(ExpressionError);\n\nexports.InvalidTimezoneCall = InvalidTimezoneCall; // Non Expression Errors ------------------------------------------------------\n\n/**\n * An error that arises when we detect a 'should-be-impossible' state.\n * Given that this error is thrown, it clearly wasn't impossible, and some\n * mistake has been made.\n */\n\nvar UnexpectedError =\n/*#__PURE__*/\nfunction (_Error2) {\n  _inherits(UnexpectedError, _Error2);\n\n  function UnexpectedError(message, payload) {\n    var _this10;\n\n    _classCallCheck(this, UnexpectedError);\n\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(UnexpectedError).call(this, \"Programmer Error '\".concat(message, \"'\")));\n    _this10.payload = payload;\n    return _this10;\n  }\n\n  return UnexpectedError;\n}(_wrapNativeSuper(Error));\n\nexports.UnexpectedError = UnexpectedError;\n/**\n * An Error that signals a feature or function is yet unimplemented.\n */\n\nvar UnimplementedError =\n/*#__PURE__*/\nfunction (_Error3) {\n  _inherits(UnimplementedError, _Error3);\n\n  function UnimplementedError(feature) {\n    _classCallCheck(this, UnimplementedError);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UnimplementedError).call(this, \"Unimplemented feature '\".concat(feature, \"!'\")));\n  }\n\n  return UnimplementedError;\n}(_wrapNativeSuper(Error));\n\nexports.UnimplementedError = UnimplementedError;\n\nvar InvalidArity =\n/*#__PURE__*/\nfunction (_Error4) {\n  _inherits(InvalidArity, _Error4);\n\n  function InvalidArity(args, op) {\n    var _this11;\n\n    _classCallCheck(this, InvalidArity);\n\n    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(InvalidArity).call(this, \"The amount of args don't match the arity of the operator '\".concat(pp(op), \"'.\")));\n    _this11.args = args;\n    _this11.op = op;\n    return _this11;\n  }\n\n  return InvalidArity;\n}(_wrapNativeSuper(Error));\n\nexports.InvalidArity = InvalidArity;\n\nvar InvalidExpression =\n/*#__PURE__*/\nfunction (_Error5) {\n  _inherits(InvalidExpression, _Error5);\n\n  function InvalidExpression(expr) {\n    _classCallCheck(this, InvalidExpression);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(InvalidExpression).call(this, \"Invalid SPARQL Expression '\".concat(pp(expr), \"'\")));\n  }\n\n  return InvalidExpression;\n}(_wrapNativeSuper(Error));\n\nexports.InvalidExpression = InvalidExpression;\n\nvar InvalidExpressionType =\n/*#__PURE__*/\nfunction (_Error6) {\n  _inherits(InvalidExpressionType, _Error6);\n\n  function InvalidExpressionType(expr) {\n    var _this12;\n\n    _classCallCheck(this, InvalidExpressionType);\n\n    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(InvalidExpressionType).call(this, \"Invalid expression type for SPARQL Expression '\".concat(pp(expr), \"'\")));\n    _this12.expr = expr;\n    return _this12;\n  }\n\n  return InvalidExpressionType;\n}(_wrapNativeSuper(Error));\n\nexports.InvalidExpressionType = InvalidExpressionType;\n\nvar InvalidTermType =\n/*#__PURE__*/\nfunction (_Error7) {\n  _inherits(InvalidTermType, _Error7);\n\n  function InvalidTermType(term) {\n    var _this13;\n\n    _classCallCheck(this, InvalidTermType);\n\n    _this13 = _possibleConstructorReturn(this, _getPrototypeOf(InvalidTermType).call(this, \"Invalid term type for term '\".concat(pp(term), \"'\")));\n    _this13.term = term;\n    return _this13;\n  }\n\n  return InvalidTermType;\n}(_wrapNativeSuper(Error));\n\nexports.InvalidTermType = InvalidTermType;\n\nvar UnknownOperator =\n/*#__PURE__*/\nfunction (_Error8) {\n  _inherits(UnknownOperator, _Error8);\n\n  function UnknownOperator(name) {\n    _classCallCheck(this, UnknownOperator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UnknownOperator).call(this, \"Unknown operator: '\".concat(pp(name))));\n  }\n\n  return UnknownOperator;\n}(_wrapNativeSuper(Error));\n\nexports.UnknownOperator = UnknownOperator;\n\nvar UnknownNamedOperator =\n/*#__PURE__*/\nfunction (_Error9) {\n  _inherits(UnknownNamedOperator, _Error9);\n\n  function UnknownNamedOperator(name) {\n    _classCallCheck(this, UnknownNamedOperator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UnknownNamedOperator).call(this, \"Unknown named operator: '\".concat(pp(name), \"'\")));\n  }\n\n  return UnknownNamedOperator;\n}(_wrapNativeSuper(Error));\n\nexports.UnknownNamedOperator = UnknownNamedOperator;\n\nvar NoAggregator =\n/*#__PURE__*/\nfunction (_Error10) {\n  _inherits(NoAggregator, _Error10);\n\n  function NoAggregator(name) {\n    _classCallCheck(this, NoAggregator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NoAggregator).call(this, \"Aggregate expression \".concat(pp(name), \" found, but no aggregate hook provided.\")));\n  }\n\n  return NoAggregator;\n}(_wrapNativeSuper(Error));\n\nexports.NoAggregator = NoAggregator;\n\nvar NoExistenceHook =\n/*#__PURE__*/\nfunction (_Error11) {\n  _inherits(NoExistenceHook, _Error11);\n\n  function NoExistenceHook() {\n    _classCallCheck(this, NoExistenceHook);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NoExistenceHook).call(this, 'EXISTS found, but no existence hook provided.'));\n  }\n\n  return NoExistenceHook;\n}(_wrapNativeSuper(Error));\n\nexports.NoExistenceHook = NoExistenceHook;\n\nfunction pp(o) {\n  return JSON.stringify(o);\n}","map":null,"metadata":{},"sourceType":"script"}