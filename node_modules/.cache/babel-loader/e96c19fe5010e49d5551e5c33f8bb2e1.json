{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar asynciterator_1 = require(\"asynciterator\");\n/**\n * An iterator that takes elements from a given array or iterator of iterators in a round-robin manner.\n *\n * Based on LDF client's UnionIterator:\n * https://github.com/LinkedDataFragments/Client.js/blob/master/lib/sparql/UnionIterator.js\n */\n\n\nvar RoundRobinUnionIterator =\n/*#__PURE__*/\nfunction (_asynciterator_1$Buff) {\n  _inherits(RoundRobinUnionIterator, _asynciterator_1$Buff);\n\n  function RoundRobinUnionIterator(sources, options) {\n    var _this;\n\n    _classCallCheck(this, RoundRobinUnionIterator);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RoundRobinUnionIterator).call(this, options || {\n      autoStart: false\n    }));\n    _this.sourcedEnded = false;\n    _this.currentSource = 0;\n    _this.listenersAttached = false;\n    _this.sources = [];\n    _this.sourceIterator = Array.isArray(sources) ? new asynciterator_1.ArrayIterator(sources) : sources;\n\n    _this.sourceIterator.on('error', function (error) {\n      return _this.emit('error', error);\n    });\n\n    return _this;\n  }\n\n  _createClass(RoundRobinUnionIterator, [{\n    key: \"_read\",\n    value: function _read(count, done) {\n      var _this2 = this;\n\n      if (!this.sourcedEnded) {\n        // Fill the buffer once the source iterator becomes readable\n        if (!this.listenersAttached) {\n          this.listenersAttached = true;\n          this.sourceIterator.on('readable', function () {\n            return _this2._fillBuffer();\n          });\n        } // Poll for new sources\n\n\n        var source;\n\n        while (source = this.sourceIterator.read()) {\n          source.on('error', function (error) {\n            return _this2.emit('error', error);\n          });\n          source.on('readable', function () {\n            return _this2._fillBuffer();\n          });\n          source.on('end', function () {\n            return _this2._fillBuffer();\n          });\n          this.sources.push(source);\n        }\n\n        if (this.sourceIterator.ended) {\n          this.sourcedEnded = true;\n        }\n      }\n\n      var item = null;\n      var attempts = this.sources.length; // Iterate over all sources once\n\n      while (this.sources.length && item === null && attempts--) {\n        var _source = this.sources[this.currentSource]; // Read from the current source\n\n        item = _source.read(); // Remove the source if it has ended, otherwise, increment our stored position\n\n        if (_source.ended) {\n          this.sources.splice(this.currentSource, 1);\n        } else {\n          this.currentSource++;\n        }\n\n        this.currentSource = this.sources.length ? this.currentSource % this.sources.length : 0;\n      } // Push to the buffer if we have an item\n\n\n      if (item !== null) {\n        this._push(item);\n      } // Otherwise close\n\n\n      if (!this.sources.length && this.sourcedEnded) {\n        this.close();\n      }\n\n      done();\n    }\n  }]);\n\n  return RoundRobinUnionIterator;\n}(asynciterator_1.BufferedIterator);\n\nexports.RoundRobinUnionIterator = RoundRobinUnionIterator;","map":null,"metadata":{},"sourceType":"script"}