{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n\nvar sax_1 = require(\"sax\");\n\nvar stream_1 = require(\"stream\");\n\nvar RdfXmlParser =\n/*#__PURE__*/\nfunction (_stream_1$Transform) {\n  _inherits(RdfXmlParser, _stream_1$Transform);\n\n  function RdfXmlParser(args) {\n    var _this;\n\n    _classCallCheck(this, RdfXmlParser);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RdfXmlParser).call(this, {\n      objectMode: true\n    }));\n    _this.activeTagStack = [];\n    _this.nodeIds = {};\n\n    if (args) {\n      Object.assign(_assertThisInitialized(_assertThisInitialized(_this)), args);\n      _this.options = args;\n    }\n\n    if (!_this.dataFactory) {\n      _this.dataFactory = require('@rdfjs/data-model');\n    }\n\n    if (!_this.baseIRI) {\n      _this.baseIRI = '';\n    }\n\n    if (!_this.defaultGraph) {\n      _this.defaultGraph = _this.dataFactory.defaultGraph();\n    }\n\n    _this.saxStream = sax_1.createStream(_this.strict, {\n      xmlns: false,\n      position: false\n    }); // Workaround for an issue in SAX where non-strict mode either lower- or upper-cases all tags.\n\n    if (!_this.strict) {\n      _this.saxStream._parser.looseCase = 'toString';\n    }\n\n    _this.attachSaxListeners();\n\n    return _this;\n  }\n  /**\n   * Parse the namespace of the given tag,\n   * and take into account the namespace of the parent tag that was already parsed.\n   * @param {Tag} tag A tag to parse the namespace from.\n   * @param {IActiveTag} parentTag The parent tag, or null if this tag is the root.\n   * @return {{[p: string]: string}[]} An array of namespaces,\n   *                                   where the last ones have a priority over the first ones.\n   */\n\n\n  _createClass(RdfXmlParser, [{\n    key: \"import\",\n\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {NodeJS.EventEmitter} A quad stream.\n     */\n    value: function _import(stream) {\n      var output = new stream_1.PassThrough({\n        objectMode: true\n      });\n      stream.on('error', function (error) {\n        return parsed.emit('error', error);\n      });\n      stream.on('data', function (data) {\n        return output.write(data);\n      });\n      stream.on('end', function () {\n        return output.emit('end');\n      });\n      var parsed = output.pipe(new RdfXmlParser(this.options));\n      return parsed;\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      this.saxStream.write(chunk, encoding);\n      callback();\n    }\n    /**\n     * Convert the given value to a IRI by taking into account the baseIRI.\n     *\n     * This will follow the RDF/XML spec for converting values with baseIRIs to a IRI.\n     *\n     * @param {string} value The value to convert to an IRI.\n     * @param {IActiveTag} activeTag The active tag.\n     * @return {NamedNode} an IRI.\n     */\n\n  }, {\n    key: \"valueToUri\",\n    value: function valueToUri(value, activeTag) {\n      return this.dataFactory.namedNode(relative_to_absolute_iri_1.resolve(value, activeTag.baseIRI));\n    }\n    /**\n     * Validate the given value as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n     * If it is invalid, an error will be emitted.\n     * @param {string} value A value.\n     */\n\n  }, {\n    key: \"validateNcname\",\n    value: function validateNcname(value) {\n      // Validate term as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n      if (!RdfXmlParser.NCNAME_MATCHER.test(value)) {\n        this.emit('error', new Error(\"Not a valid NCName: \".concat(value)));\n      }\n    }\n  }, {\n    key: \"attachSaxListeners\",\n    value: function attachSaxListeners() {\n      var _this2 = this;\n\n      this.saxStream.on('error', function (error) {\n        return _this2.emit('error', error);\n      });\n      this.saxStream.on('opentag', this.onTag.bind(this));\n      this.saxStream.on('text', this.onText.bind(this));\n      this.saxStream.on('closetag', this.onCloseTag.bind(this));\n      this.saxStream.on('doctype', this.onDoctype.bind(this));\n    }\n    /**\n     * Handle the given tag.\n     * @param {QualifiedTag} tag A SAX tag.\n     */\n\n  }, {\n    key: \"onTag\",\n    value: function onTag(tag) {\n      // Get parent tag\n      var parentTag = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n      var currentParseType = ParseType.RESOURCE;\n\n      if (parentTag) {\n        parentTag.hadChildren = true;\n        currentParseType = parentTag.childrenParseType;\n      } // Check if this tag needs to be converted to a string\n\n\n      if (parentTag && parentTag.childrenStringTags) {\n        // Convert this tag to a string\n        var tagName = tag.name;\n        var attributes = '';\n\n        for (var attributeKey in tag.attributes) {\n          attributes += \" \".concat(attributeKey, \"=\\\"\").concat(tag.attributes[attributeKey], \"\\\"\");\n        }\n\n        var tagContents = \"\".concat(tagName).concat(attributes);\n        var tagString = \"<\".concat(tagContents, \">\");\n        parentTag.childrenStringTags.push(tagString); // Inherit the array, so that deeper tags are appended to this same array\n\n        var stringActiveTag = {\n          childrenStringTags: parentTag.childrenStringTags\n        };\n        stringActiveTag.childrenStringEmitClosingTag = \"</\".concat(tagName, \">\");\n        this.activeTagStack.push(stringActiveTag); // Halt any further processing\n\n        return;\n      }\n\n      var activeTag = {};\n\n      if (parentTag) {\n        // Inherit language scope and baseIRI from parent\n        activeTag.language = parentTag.language;\n        activeTag.baseIRI = parentTag.baseIRI;\n      } else {\n        activeTag.baseIRI = this.baseIRI;\n      }\n\n      this.activeTagStack.push(activeTag);\n      activeTag.ns = RdfXmlParser.parseNamespace(tag, parentTag);\n\n      if (currentParseType === ParseType.RESOURCE) {\n        this.onTagResource(tag, activeTag, parentTag, !parentTag);\n      } else {\n        // currentParseType === ParseType.PROPERTY\n        this.onTagProperty(tag, activeTag, parentTag);\n      }\n    }\n    /**\n     * Handle the given node element in resource-mode.\n     * @param {QualifiedTag} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     * @param {boolean} rootTag If we are currently processing the root tag.\n     */\n\n  }, {\n    key: \"onTagResource\",\n    value: function onTagResource(tag, activeTag, parentTag, rootTag) {\n      var tagExpanded = RdfXmlParser.expandPrefixedTerm(tag.name, activeTag.ns);\n      activeTag.childrenParseType = ParseType.PROPERTY; // Assume that the current node is a _typed_ node (2.13), unless we find an rdf:Description as node name\n\n      var typedNode = true;\n\n      if (tagExpanded.uri === RdfXmlParser.RDF) {\n        // Check forbidden property element names\n        if (!rootTag && RdfXmlParser.FORBIDDEN_NODE_ELEMENTS.indexOf(tagExpanded.local) >= 0) {\n          this.emit('error', new Error(\"Illegal node element name: \".concat(tagExpanded.local)));\n        }\n\n        switch (tagExpanded.local) {\n          case 'RDF':\n            // Tags under <rdf:RDF> must always be resources\n            activeTag.childrenParseType = ParseType.RESOURCE;\n\n          case 'Description':\n            typedNode = false;\n        }\n      }\n\n      var predicates = [];\n      var objects = []; // Collect all attributes as triples\n      // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n\n      var activeSubjectValue = null;\n      var claimSubjectNodeId = false;\n      var subjectValueBlank = false;\n      var explicitType = null;\n\n      for (var attributeKey in tag.attributes) {\n        var attributeValue = tag.attributes[attributeKey];\n        var attributeKeyExpanded = RdfXmlParser.expandPrefixedTerm(attributeKey, activeTag.ns);\n\n        if (parentTag && attributeKeyExpanded.uri === RdfXmlParser.RDF) {\n          switch (attributeKeyExpanded.local) {\n            case 'about':\n              if (activeSubjectValue) {\n                this.emit('error', new Error(\"Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while \".concat(attributeValue, \" and \").concat(activeSubjectValue, \" where found.\")));\n              }\n\n              activeSubjectValue = attributeValue;\n              continue;\n\n            case 'ID':\n              if (activeSubjectValue) {\n                this.emit('error', new Error(\"Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while \".concat(attributeValue, \" and \").concat(activeSubjectValue, \" where found.\")));\n              }\n\n              this.validateNcname(attributeValue);\n              activeSubjectValue = '#' + attributeValue;\n              claimSubjectNodeId = true;\n              continue;\n\n            case 'nodeID':\n              if (activeSubjectValue) {\n                this.emit('error', new Error(\"Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while \".concat(attributeValue, \" and \").concat(activeSubjectValue, \" where found.\")));\n              }\n\n              this.validateNcname(attributeValue);\n              activeSubjectValue = attributeValue;\n              subjectValueBlank = true;\n              continue;\n\n            case 'bagID':\n              this.emit('error', new Error(\"rdf:bagID is not supported.\"));\n              continue;\n\n            case 'type':\n              // Emit the rdf:type later as named node instead of the default literal\n              explicitType = attributeValue;\n              continue;\n\n            case 'aboutEach':\n              this.emit('error', new Error(\"rdf:aboutEach is not supported.\"));\n              continue;\n\n            case 'aboutEachPrefix':\n              this.emit('error', new Error(\"rdf:aboutEachPrefix is not supported.\"));\n              continue;\n\n            case 'li':\n              this.emit('error', new Error(\"rdf:li on node elements are not supported.\"));\n              continue;\n          }\n        } else if (attributeKeyExpanded.uri === RdfXmlParser.XML) {\n          if (attributeKeyExpanded.local === 'lang') {\n            activeTag.language = attributeValue === '' ? null : attributeValue.toLowerCase();\n            continue;\n          } else if (attributeKeyExpanded.local === 'base') {\n            activeTag.baseIRI = attributeValue;\n            continue;\n          }\n        } // Interpret attributes at this point as properties on this node,\n        // but we ignore attributes that have no prefix or known expanded URI\n\n\n        if (attributeKeyExpanded.prefix !== 'xml' && attributeKeyExpanded.uri) {\n          predicates.push(this.dataFactory.namedNode(attributeKeyExpanded.uri + attributeKeyExpanded.local));\n          objects.push(attributeValue);\n        }\n      } // Create the subject value _after_ all attributes have been processed\n\n\n      if (activeSubjectValue !== null) {\n        activeTag.subject = subjectValueBlank ? this.dataFactory.blankNode(activeSubjectValue) : this.valueToUri(activeSubjectValue, activeTag);\n\n        if (claimSubjectNodeId) {\n          this.claimNodeId(activeTag.subject);\n        }\n      } // Force the creation of a subject if it doesn't exist yet\n\n\n      if (!activeTag.subject) {\n        activeTag.subject = this.dataFactory.blankNode();\n      } // Emit the type if we're at a typed node\n\n\n      if (typedNode) {\n        var type = this.dataFactory.namedNode(tagExpanded.uri + tagExpanded.local);\n        this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), type, parentTag ? parentTag.reifiedStatementId : null);\n      }\n\n      if (parentTag) {\n        // If the parent tag defined a predicate, add the current tag as property value\n        if (parentTag.predicate) {\n          if (parentTag.childrenCollectionSubject) {\n            // RDF:List-based properties\n            var linkTerm = this.dataFactory.blankNode(); // Emit <x> <p> <current-chain> OR <previous-chain> <rdf:rest> <current-chain>\n\n            this.emitTriple(parentTag.childrenCollectionSubject, parentTag.childrenCollectionPredicate, linkTerm, parentTag.reifiedStatementId); // Emit <current-chain> <rdf:first> value\n\n            this.emitTriple(linkTerm, this.dataFactory.namedNode(RdfXmlParser.RDF + 'first'), activeTag.subject, activeTag.reifiedStatementId); // Store <current-chain> in the parent node\n\n            parentTag.childrenCollectionSubject = linkTerm;\n            parentTag.childrenCollectionPredicate = this.dataFactory.namedNode(RdfXmlParser.RDF + 'rest');\n          } else {\n            // !parentTag.predicateEmitted\n            // Set-based properties\n            this.emitTriple(parentTag.subject, parentTag.predicate, activeTag.subject, parentTag.reifiedStatementId); // Emit pending properties on the parent tag that had no defined subject yet.\n\n            for (var i = 0; i < parentTag.predicateSubPredicates.length; i++) {\n              this.emitTriple(activeTag.subject, parentTag.predicateSubPredicates[i], parentTag.predicateSubObjects[i], null);\n            } // Cleanup so we don't emit them again when the parent tag is closed\n\n\n            parentTag.predicateSubPredicates = [];\n            parentTag.predicateSubObjects = [];\n            parentTag.predicateEmitted = true;\n          }\n        } // Emit all collected triples\n\n\n        for (var _i = 0; _i < predicates.length; _i++) {\n          var object = this.dataFactory.literal(objects[_i], activeTag.datatype || activeTag.language);\n          this.emitTriple(activeTag.subject, predicates[_i], object, parentTag.reifiedStatementId);\n        } // Emit the rdf:type as named node instead of literal\n\n\n        if (explicitType) {\n          this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.dataFactory.namedNode(explicitType), null);\n        }\n      }\n    }\n    /**\n     * Handle the given property element in property-mode.\n     * @param {QualifiedTag} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     */\n\n  }, {\n    key: \"onTagProperty\",\n    value: function onTagProperty(tag, activeTag, parentTag) {\n      var tagExpanded = RdfXmlParser.expandPrefixedTerm(tag.name, activeTag.ns);\n      activeTag.childrenParseType = ParseType.RESOURCE;\n      activeTag.subject = parentTag.subject; // Inherit parent subject\n\n      if (tagExpanded.uri === RdfXmlParser.RDF && tagExpanded.local === 'li') {\n        // Convert rdf:li to rdf:_x\n        if (!parentTag.listItemCounter) {\n          parentTag.listItemCounter = 1;\n        }\n\n        activeTag.predicate = this.dataFactory.namedNode(tagExpanded.uri + '_' + parentTag.listItemCounter++);\n      } else {\n        activeTag.predicate = this.dataFactory.namedNode(tagExpanded.uri + tagExpanded.local);\n      } // Check forbidden property element names\n\n\n      if (tagExpanded.uri === RdfXmlParser.RDF && RdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(tagExpanded.local) >= 0) {\n        this.emit('error', new Error(\"Illegal property element name: \".concat(tagExpanded.local)));\n      }\n\n      activeTag.predicateSubPredicates = [];\n      activeTag.predicateSubObjects = [];\n      var parseType = false;\n      var attributedProperty = false; // Collect all attributes as triples\n      // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n\n      var activeSubSubjectValue = null;\n      var subSubjectValueBlank = true;\n      var predicates = [];\n      var objects = [];\n\n      for (var propertyAttributeKey in tag.attributes) {\n        var propertyAttributeValue = tag.attributes[propertyAttributeKey];\n        var propertyAttributeKeyExpanded = RdfXmlParser.expandPrefixedTerm(propertyAttributeKey, activeTag.ns);\n\n        if (propertyAttributeKeyExpanded.uri === RdfXmlParser.RDF) {\n          switch (propertyAttributeKeyExpanded.local) {\n            case 'resource':\n              if (activeSubSubjectValue) {\n                this.emit('error', new Error(\"Found both rdf:resource (\".concat(propertyAttributeValue, \") and rdf:nodeID (\").concat(activeSubSubjectValue, \").\")));\n              }\n\n              if (parseType) {\n                this.emit('error', new Error(\"rdf:parseType is not allowed on property elements with rdf:resource (\".concat(propertyAttributeValue, \")\")));\n              }\n\n              activeTag.hadChildren = true;\n              activeSubSubjectValue = propertyAttributeValue;\n              subSubjectValueBlank = false;\n              continue;\n\n            case 'datatype':\n              if (attributedProperty) {\n                this.emit('error', new Error(\"Found both non-rdf:* property attributes and rdf:datatype (\".concat(propertyAttributeValue, \").\")));\n              }\n\n              if (parseType) {\n                this.emit('error', new Error(\"rdf:parseType is not allowed on property elements with rdf:datatype (\".concat(propertyAttributeValue, \")\")));\n              }\n\n              activeTag.datatype = this.valueToUri(propertyAttributeValue, activeTag);\n              continue;\n\n            case 'nodeID':\n              if (attributedProperty) {\n                this.emit('error', new Error(\"Found both non-rdf:* property attributes and rdf:nodeID (\".concat(propertyAttributeValue, \").\")));\n              }\n\n              if (activeTag.hadChildren) {\n                this.emit('error', new Error(\"Found both rdf:resource and rdf:nodeID (\".concat(propertyAttributeValue, \").\")));\n              }\n\n              if (parseType) {\n                this.emit('error', new Error(\"rdf:parseType is not allowed on property elements with rdf:nodeID (\".concat(propertyAttributeValue, \")\")));\n              }\n\n              this.validateNcname(propertyAttributeValue);\n              activeTag.hadChildren = true;\n              activeSubSubjectValue = propertyAttributeValue;\n              subSubjectValueBlank = true;\n              continue;\n\n            case 'bagID':\n              this.emit('error', new Error(\"rdf:bagID is not supported.\"));\n              continue;\n\n            case 'parseType':\n              // Validation\n              if (attributedProperty) {\n                this.emit('error', new Error(\"rdf:parseType is not allowed when non-rdf:* property attributes are present\"));\n              }\n\n              if (activeTag.datatype) {\n                this.emit('error', new Error(\"rdf:parseType is not allowed on property elements with rdf:datatype (\".concat(activeTag.datatype.value, \")\")));\n              }\n\n              if (activeSubSubjectValue) {\n                this.emit('error', new Error(\"rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (\".concat(activeSubSubjectValue, \")\")));\n              }\n\n              if (propertyAttributeValue === 'Resource') {\n                parseType = true;\n                activeTag.childrenParseType = ParseType.PROPERTY; // Turn this property element into a node element\n\n                var nestedBNode = this.dataFactory.blankNode();\n                this.emitTriple(activeTag.subject, activeTag.predicate, nestedBNode, activeTag.reifiedStatementId);\n                activeTag.subject = nestedBNode;\n                activeTag.predicate = null;\n              } else if (propertyAttributeValue === 'Collection') {\n                parseType = true; // Interpret children as being part of an rdf:List\n\n                activeTag.hadChildren = true;\n                activeTag.childrenCollectionSubject = activeTag.subject;\n                activeTag.childrenCollectionPredicate = activeTag.predicate;\n                subSubjectValueBlank = false;\n              } else if (propertyAttributeValue === 'Literal') {\n                parseType = true; // Interpret children as being part of a literal string\n\n                activeTag.childrenTagsToString = true;\n                activeTag.childrenStringTags = [];\n              }\n\n              continue;\n\n            case 'ID':\n              this.validateNcname(propertyAttributeValue);\n              activeTag.reifiedStatementId = this.valueToUri('#' + propertyAttributeValue, activeTag);\n              this.claimNodeId(activeTag.reifiedStatementId);\n              continue;\n          }\n        } else if (propertyAttributeKeyExpanded.uri === RdfXmlParser.XML && propertyAttributeKeyExpanded.local === 'lang') {\n          activeTag.language = propertyAttributeValue === '' ? null : propertyAttributeValue.toLowerCase();\n          continue;\n        } // Interpret attributes at this point as properties via implicit blank nodes on the property,\n        // but we ignore attributes that have no prefix or known expanded URI\n\n\n        if (propertyAttributeKeyExpanded.prefix !== 'xml' && propertyAttributeKeyExpanded.uri) {\n          if (parseType || activeTag.datatype) {\n            this.emit('error', new Error(\"Found illegal rdf:* properties on property element with attribute: \".concat(propertyAttributeValue)));\n          }\n\n          activeTag.hadChildren = true;\n          attributedProperty = true;\n          predicates.push(this.dataFactory.namedNode(propertyAttributeKeyExpanded.uri + propertyAttributeKeyExpanded.local));\n          objects.push(this.dataFactory.literal(propertyAttributeValue, activeTag.datatype || activeTag.language));\n        }\n      } // Create the subject value _after_ all attributes have been processed\n\n\n      if (activeSubSubjectValue !== null) {\n        var subjectParent = activeTag.subject;\n        activeTag.subject = subSubjectValueBlank ? this.dataFactory.blankNode(activeSubSubjectValue) : this.valueToUri(activeSubSubjectValue, activeTag);\n        this.emitTriple(subjectParent, activeTag.predicate, activeTag.subject, activeTag.reifiedStatementId); // Emit our buffered triples\n\n        for (var i = 0; i < predicates.length; i++) {\n          this.emitTriple(activeTag.subject, predicates[i], objects[i], null);\n        }\n\n        activeTag.predicateEmitted = true;\n      } else if (subSubjectValueBlank) {\n        // The current property element has no defined subject\n        // Let's buffer the properties until the child node defines a subject,\n        // or if the tag closes.\n        activeTag.predicateSubPredicates = predicates;\n        activeTag.predicateSubObjects = objects;\n        activeTag.predicateEmitted = false;\n      }\n    }\n    /**\n     * Emit the given triple to the stream.\n     * @param {Term} subject A subject term.\n     * @param {Term} predicate A predicate term.\n     * @param {Term} object An object term.\n     * @param {Term} statementId An optional resource that identifies the triple.\n     *                           If truthy, then the given triple will also be emitted reified.\n     */\n\n  }, {\n    key: \"emitTriple\",\n    value: function emitTriple(subject, predicate, object, statementId) {\n      this.push(this.dataFactory.quad(subject, predicate, object, this.defaultGraph)); // Reify triple\n\n      if (statementId) {\n        this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.dataFactory.namedNode(RdfXmlParser.RDF + 'Statement'), this.defaultGraph));\n        this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'subject'), subject, this.defaultGraph));\n        this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'predicate'), predicate, this.defaultGraph));\n        this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'object'), object, this.defaultGraph));\n      }\n    }\n    /**\n     * Register the given term as a node ID.\n     * If one was already registered, this will emit an error.\n     *\n     * This is used to check duplicate occurrences of rdf:ID in scope of the baseIRI.\n     * @param {Term} term An RDF term.\n     */\n\n  }, {\n    key: \"claimNodeId\",\n    value: function claimNodeId(term) {\n      if (this.nodeIds[term.value]) {\n        this.emit('error', new Error(\"Found multiple occurrences of rdf:ID='\".concat(term.value, \"'.\")));\n      }\n\n      this.nodeIds[term.value] = true;\n    }\n    /**\n     * Handle the given text string.\n     * @param {string} text A parsed text string.\n     */\n\n  }, {\n    key: \"onText\",\n    value: function onText(text) {\n      var activeTag = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n\n      if (activeTag) {\n        if (activeTag.childrenStringTags) {\n          activeTag.childrenStringTags.push(text);\n        } else if (activeTag.predicate) {\n          activeTag.text = text;\n        }\n      }\n    }\n    /**\n     * Handle the closing of the last tag.\n     */\n\n  }, {\n    key: \"onCloseTag\",\n    value: function onCloseTag() {\n      var poppedTag = this.activeTagStack.pop(); // If we were converting a tag to a string, and the tag was not self-closing, close it here.\n\n      if (poppedTag.childrenStringEmitClosingTag) {\n        poppedTag.childrenStringTags.push(poppedTag.childrenStringEmitClosingTag);\n      } // Set the literal value if we were collecting XML tags to string\n\n\n      if (poppedTag.childrenTagsToString) {\n        poppedTag.datatype = this.dataFactory.namedNode(RdfXmlParser.RDF + 'XMLLiteral');\n        poppedTag.text = poppedTag.childrenStringTags.join('');\n        poppedTag.hadChildren = false; // Force a literal triple to be emitted hereafter\n      }\n\n      if (poppedTag.childrenCollectionSubject) {\n        // Terminate the rdf:List\n        this.emitTriple(poppedTag.childrenCollectionSubject, poppedTag.childrenCollectionPredicate, this.dataFactory.namedNode(RdfXmlParser.RDF + 'nil'), poppedTag.reifiedStatementId);\n      } else if (poppedTag.predicate) {\n        if (!poppedTag.hadChildren && poppedTag.childrenParseType !== ParseType.PROPERTY) {\n          // Property element contains text\n          this.emitTriple(poppedTag.subject, poppedTag.predicate, this.dataFactory.literal(poppedTag.text || '', poppedTag.datatype || poppedTag.language), poppedTag.reifiedStatementId);\n        } else if (!poppedTag.predicateEmitted) {\n          // Emit remaining properties on an anonymous property element\n          var subject = this.dataFactory.blankNode();\n          this.emitTriple(poppedTag.subject, poppedTag.predicate, subject, poppedTag.reifiedStatementId);\n\n          for (var i = 0; i < poppedTag.predicateSubPredicates.length; i++) {\n            this.emitTriple(subject, poppedTag.predicateSubPredicates[i], poppedTag.predicateSubObjects[i], null);\n          }\n        }\n      }\n    }\n    /**\n     * Fetch local DOCTYPE ENTITY's and make the parser recognise them.\n     * @param {string} doctype The read doctype.\n     */\n\n  }, {\n    key: \"onDoctype\",\n    value: function onDoctype(doctype) {\n      var _this3 = this;\n\n      doctype.replace(/<!ENTITY ([^ ]+) \"([^\"]+)\">/g, function (match, prefix, uri) {\n        _this3.saxStream._parser.ENTITIES[prefix] = uri;\n        return '';\n      });\n    }\n  }], [{\n    key: \"parseNamespace\",\n    value: function parseNamespace(tag, parentTag) {\n      var thisNs = {};\n      var hasNs = false;\n\n      for (var attributeKey in tag.attributes) {\n        if (attributeKey.startsWith('xmlns')) {\n          if (attributeKey.length === 5) {\n            // Set default namespace\n            hasNs = true;\n            thisNs[''] = tag.attributes[attributeKey];\n          } else if (attributeKey.charAt(5) === ':') {\n            // Definition of a prefix\n            hasNs = true;\n            thisNs[attributeKey.substr(6)] = tag.attributes[attributeKey];\n          }\n        }\n      }\n\n      var parentNs = parentTag && parentTag.ns ? parentTag.ns : [RdfXmlParser.DEFAULT_NS];\n      return hasNs ? parentNs.concat([thisNs]) : parentNs;\n    }\n    /**\n     * Expand the given term value based on the given namespaces.\n     * @param {string} term A term value.\n     * @param {{[p: string]: string}[]} ns An array of namespaces,\n     *                                     where the last ones have a priority over the first ones.\n     * @return {IExpandedPrefix} An expanded prefix object.\n     */\n\n  }, {\n    key: \"expandPrefixedTerm\",\n    value: function expandPrefixedTerm(term, ns) {\n      var colonIndex = term.indexOf(':');\n      var prefix;\n      var local;\n\n      if (colonIndex >= 0) {\n        // Prefix is set\n        prefix = term.substr(0, colonIndex);\n        local = term.substr(colonIndex + 1);\n      } else {\n        // Prefix is not set, fallback to default namespace\n        prefix = '';\n        local = term;\n      }\n\n      var uri = null;\n      var defaultNamespace = null;\n\n      for (var i = ns.length - 1; i >= 0; i--) {\n        var nsElement = ns[i][prefix];\n\n        if (nsElement) {\n          uri = nsElement;\n          break;\n        } else if (!defaultNamespace) {\n          defaultNamespace = ns[i][''];\n        }\n      }\n\n      if (!uri) {\n        // Fallback to default namespace if no match was found\n        uri = defaultNamespace || '';\n      }\n\n      return {\n        prefix: prefix,\n        local: local,\n        uri: uri\n      };\n    }\n  }]);\n\n  return RdfXmlParser;\n}(stream_1.Transform);\n\nRdfXmlParser.MIME_TYPE = 'application/rdf+xml';\nRdfXmlParser.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nRdfXmlParser.XML = 'http://www.w3.org/XML/1998/namespace';\nRdfXmlParser.XMLNS = 'http://www.w3.org/2000/xmlns/';\nRdfXmlParser.DEFAULT_NS = {\n  xml: RdfXmlParser.XML\n};\nRdfXmlParser.FORBIDDEN_NODE_ELEMENTS = ['RDF', 'ID', 'about', 'bagID', 'parseType', 'resource', 'nodeID', 'li', 'aboutEach', 'aboutEachPrefix'];\nRdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS = ['Description', 'RDF', 'ID', 'about', 'bagID', 'parseType', 'resource', 'nodeID', 'aboutEach', 'aboutEachPrefix']; // tslint:disable-next-line:max-line-length\n\nRdfXmlParser.NCNAME_MATCHER = /^((?:[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]))((?:[#\\x2D\\.0-9A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]))*$/;\nexports.RdfXmlParser = RdfXmlParser;\nvar ParseType;\n\n(function (ParseType) {\n  ParseType[ParseType[\"RESOURCE\"] = 0] = \"RESOURCE\";\n  ParseType[ParseType[\"PROPERTY\"] = 1] = \"PROPERTY\";\n})(ParseType = exports.ParseType || (exports.ParseType = {}));","map":null,"metadata":{},"sourceType":"script"}