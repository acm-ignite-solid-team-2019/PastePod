{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DefaultDataFactory = require(\"@rdfjs/data-model\");\n\nvar SparqlJsonBindingsTransformer_1 = require(\"./SparqlJsonBindingsTransformer\");\n/**\n * Parser for the SPARQL 1.1 Query Results JSON format.\n * @see https://www.w3.org/TR/sparql11-results-json/\n */\n\n\nvar SparqlJsonParser =\n/*#__PURE__*/\nfunction () {\n  function SparqlJsonParser(settings) {\n    _classCallCheck(this, SparqlJsonParser);\n\n    settings = settings || {};\n    this.dataFactory = settings.dataFactory || DefaultDataFactory;\n    this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n  }\n  /**\n   * Convert a SPARQL JSON bindings response to an array of bindings objects.\n   * @param sparqlResponse A SPARQL JSON response.\n   * @return {IBindings[]} An array of bindings.\n   */\n\n\n  _createClass(SparqlJsonParser, [{\n    key: \"parseJsonResults\",\n    value: function parseJsonResults(sparqlResponse) {\n      var _this = this;\n\n      return sparqlResponse.results.bindings.map(function (rawBindings) {\n        return _this.parseJsonBindings(rawBindings);\n      });\n    }\n    /**\n     * Convert a SPARQL JSON bindings response stream to a stream of bindings objects.\n     *\n     * The bindings stream will emit a 'variables' event that will contain\n     * the array of variables (as RDF.Variable[]), as defined in the response head.\n     *\n     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n     * @return {NodeJS.ReadableStream} A stream of bindings.\n     */\n\n  }, {\n    key: \"parseJsonResultsStream\",\n    value: function parseJsonResultsStream(sparqlResponseStream) {\n      var _this2 = this;\n\n      sparqlResponseStream.on('error', function (error) {\n        return resultStream.emit('error', error);\n      });\n      var variables = [];\n      sparqlResponseStream.pipe(require('JSONStream').parse('head.vars.*')).on('data', function (variable) {\n        return variables.push(_this2.dataFactory.variable(variable));\n      }).on('end', function () {\n        return resultStream.emit('variables', variables);\n      });\n      var resultStream = sparqlResponseStream.pipe(require('JSONStream').parse('results.bindings.*')).pipe(new SparqlJsonBindingsTransformer_1.SparqlJsonBindingsTransformer(this));\n      return resultStream;\n    }\n    /**\n     * Convert a SPARQL JSON result binding to a bindings object.\n     * @param rawBindings A SPARQL JSON result binding.\n     * @return {IBindings} A bindings object.\n     */\n\n  }, {\n    key: \"parseJsonBindings\",\n    value: function parseJsonBindings(rawBindings) {\n      var bindings = {};\n\n      for (var key in rawBindings) {\n        var rawValue = rawBindings[key];\n        var value = null;\n\n        switch (rawValue.type) {\n          case 'bnode':\n            value = this.dataFactory.blankNode(rawValue.value);\n            break;\n\n          case 'literal':\n            if (rawValue['xml:lang']) {\n              value = this.dataFactory.literal(rawValue.value, rawValue['xml:lang']);\n            } else if (rawValue.datatype) {\n              value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n            } else {\n              value = this.dataFactory.literal(rawValue.value);\n            }\n\n            break;\n\n          case 'typed-literal':\n            // Virtuoso uses this non-spec-compliant way of defining typed literals\n            value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n            break;\n\n          default:\n            value = this.dataFactory.namedNode(rawValue.value);\n            break;\n        }\n\n        bindings[this.prefixVariableQuestionMark ? '?' + key : key] = value;\n      }\n\n      return bindings;\n    }\n    /**\n     * Convert a SPARQL JSON boolean response to a boolean.\n     * This will throw an error if the given reponse was not a valid boolean response.\n     * @param sparqlResponse A SPARQL JSON response.\n     * @return {IBindings[]} An array of bindings.\n     */\n\n  }, {\n    key: \"parseJsonBoolean\",\n    value: function parseJsonBoolean(sparqlResponse) {\n      if ('boolean' in sparqlResponse) {\n        return sparqlResponse.boolean;\n      }\n\n      throw new Error('No valid ASK response was found.');\n    }\n    /**\n     * Convert a SPARQL JSON boolean response stream to a promise resolving to a boolean.\n     * This will reject if the given reponse was not a valid boolean response.\n     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n     * @return {NodeJS.ReadableStream} A stream of bindings.\n     */\n\n  }, {\n    key: \"parseJsonBooleanStream\",\n    value: function parseJsonBooleanStream(sparqlResponseStream) {\n      return new Promise(function (resolve, reject) {\n        sparqlResponseStream.on('error', reject);\n        sparqlResponseStream.pipe(require('JSONStream').parse('boolean')).on('data', resolve).on('end', function () {\n          return reject(new Error('No valid ASK response was found.'));\n        });\n      });\n    }\n  }]);\n\n  return SparqlJsonParser;\n}();\n\nexports.SparqlJsonParser = SparqlJsonParser;","map":null,"metadata":{},"sourceType":"script"}