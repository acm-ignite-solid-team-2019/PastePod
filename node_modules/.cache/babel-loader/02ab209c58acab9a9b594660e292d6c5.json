{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"isomorphic-fetch\");\n\nvar relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n\nvar FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\n/**\n * Parses JSON-LD contexts.\n */\n\n\nvar ContextParser =\n/*#__PURE__*/\nfunction () {\n  function ContextParser(options) {\n    _classCallCheck(this, ContextParser);\n\n    options = options || {};\n    this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n    this.documentCache = {};\n    this.validate = !options.skipValidation;\n    this.expandContentTypeToBase = options.expandContentTypeToBase;\n  }\n  /**\n   * Get the prefix from the given term.\n   * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n   * @param {string} term A term that is an URL or a prefixed URL.\n   * @param {IJsonLdContextNormalized} context A context.\n   * @return {string} The prefix or null.\n   */\n\n\n  _createClass(ContextParser, [{\n    key: \"parse\",\n\n    /**\n     * Parse a JSON-LD context in any form.\n     * @param {JsonLdContext} context A context, URL to a context, or an array of contexts/URLs.\n     * @param {IParseOptions} options Optional parsing options.\n     * @return {Promise<IJsonLdContextNormalized>} A promise resolving to the context.\n     */\n    value: function parse(context) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          baseIri = _ref.baseIri,\n          parentContext = _ref.parentContext,\n          external = _ref.external;\n\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var contexts, newContext;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(context === null || context === undefined)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", baseIri ? {\n                  '@base': baseIri\n                } : {});\n\n              case 4:\n                if (!(typeof context === 'string')) {\n                  _context.next = 17;\n                  break;\n                }\n\n                if (ContextParser.isValidIri(context)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                context = relative_to_absolute_iri_1.resolve(context, baseIri);\n\n                if (ContextParser.isValidIri(context)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new Error(\"Invalid context IRI: \".concat(context));\n\n              case 9:\n                _context.t0 = this;\n                _context.next = 12;\n                return this.load(context);\n\n              case 12:\n                _context.t1 = _context.sent;\n                _context.t2 = {\n                  baseIri: baseIri,\n                  parentContext: parentContext,\n                  external: true\n                };\n                return _context.abrupt(\"return\", _context.t0.parse.call(_context.t0, _context.t1, _context.t2));\n\n              case 17:\n                if (!Array.isArray(context)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                _context.next = 20;\n                return Promise.all(context.map(function (subContext) {\n                  if (typeof subContext === 'string') {\n                    return _this.load(subContext);\n                  } else {\n                    return subContext;\n                  }\n                }));\n\n              case 20:\n                contexts = _context.sent;\n                return _context.abrupt(\"return\", contexts.reduce(function (accContextPromise, contextEntry) {\n                  return accContextPromise.then(function (accContext) {\n                    return _this.parse(contextEntry, {\n                      baseIri: baseIri,\n                      parentContext: accContext,\n                      external: external\n                    });\n                  });\n                }, Promise.resolve(parentContext)));\n\n              case 24:\n                if (!(typeof context === 'object')) {\n                  _context.next = 39;\n                  break;\n                }\n\n                if (!context['@context']) {\n                  _context.next = 29;\n                  break;\n                }\n\n                _context.next = 28;\n                return this.parse(context['@context'], {\n                  baseIri: baseIri,\n                  parentContext: parentContext,\n                  external: external\n                });\n\n              case 28:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 29:\n                // We have an actual context object.\n                newContext = {}; // According to the JSON-LD spec, @base must be ignored from external contexts.\n\n                if (external) {\n                  delete context['@base'];\n                } // Override the base IRI if provided.\n\n\n                if (baseIri && !('@base' in newContext)) {\n                  newContext['@base'] = baseIri;\n                }\n\n                newContext = Object.assign({}, newContext, parentContext, context);\n                ContextParser.idifyReverseTerms(newContext);\n                ContextParser.expandPrefixedTerms(newContext, this.expandContentTypeToBase);\n\n                if (this.validate) {\n                  ContextParser.validate(newContext);\n                }\n\n                return _context.abrupt(\"return\", newContext);\n\n              case 39:\n                throw new Error(\"Tried parsing a context that is not a string, array or object, but got \".concat(context));\n\n              case 40:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var cached;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cached = this.documentCache[url];\n\n                if (!cached) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", Array.isArray(cached) ? cached.slice() : Object.assign({}, cached));\n\n              case 3:\n                _context2.next = 5;\n                return this.documentLoader.load(url);\n\n              case 5:\n                return _context2.abrupt(\"return\", this.documentCache[url] = _context2.sent['@context']);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }], [{\n    key: \"getPrefix\",\n    value: function getPrefix(term, context) {\n      var separatorPos = term.indexOf(':');\n\n      if (separatorPos >= 0) {\n        // Suffix can not begin with two slashes\n        if (term.length > separatorPos + 1 && term.charAt(separatorPos + 1) === '/' && term.charAt(separatorPos + 2) === '/') {\n          return null;\n        }\n\n        var prefix = term.substr(0, separatorPos); // Prefix can not be an underscore (this is a blank node)\n\n        if (prefix === '_') {\n          return null;\n        } // Prefix must match a term in the active context\n\n\n        if (context[prefix]) {\n          return prefix;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * From a given context entry value, get the string value, or the @id field.\n     * @param contextValue A value for a term in a context.\n     * @return {string} The id value, or null.\n     */\n\n  }, {\n    key: \"getContextValueId\",\n    value: function getContextValueId(contextValue) {\n      if (contextValue === null || typeof contextValue === 'string') {\n        return contextValue;\n      }\n\n      var id = contextValue['@id'];\n      return id ? id : null;\n    }\n    /**\n     * Expand the term or prefix of the given term if it has one,\n     * otherwise return the term as-is.\n     *\n     * Iff in vocab-mode, then other references to other terms in the context can be used,\n     * such as to `myTerm`:\n     * ```\n     * {\n     *   \"myTerm\": \"http://example.org/myLongTerm\"\n     * }\n     * ```\n     *\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalized} context A context.\n     * @param {boolean} vocab If the term is a predicate or type and should be expanded based on @vocab,\n     *                        otherwise it is considered a regular term that is expanded based on @base.\n     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n     */\n\n  }, {\n    key: \"expandTerm\",\n    value: function expandTerm(term, context, vocab) {\n      var contextValue = context[term]; // Immediately return if the term was disabled in the context\n\n      if (contextValue === null || contextValue && contextValue['@id'] === null) {\n        return null;\n      } // Check the @id\n\n\n      if (contextValue && vocab) {\n        var value = this.getContextValueId(contextValue);\n\n        if (value && value !== term) {\n          return value;\n        }\n      } // Check if the term is prefixed\n\n\n      var prefix = ContextParser.getPrefix(term, context);\n\n      if (prefix) {\n        var _value = this.getContextValueId(context[prefix]);\n\n        if (_value) {\n          return _value + term.substr(prefix.length + 1);\n        }\n      } else if (vocab && context['@vocab'] && term.charAt(0) !== '@' && term.indexOf(':') < 0) {\n        return context['@vocab'] + term;\n      } else if (!vocab && context['@base'] && term.charAt(0) !== '@' && term.indexOf(':') < 0) {\n        return relative_to_absolute_iri_1.resolve(term, context['@base']);\n      }\n\n      return term;\n    }\n    /**\n     * Check if the given context value can be a prefix value.\n     * @param value A context value.\n     * @return {boolean} If it can be a prefix value.\n     */\n\n  }, {\n    key: \"isPrefixValue\",\n    value: function isPrefixValue(value) {\n      return value && (typeof value === 'string' || value['@id'] || value['@type']);\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n\n  }, {\n    key: \"isValidIri\",\n    value: function isValidIri(iri) {\n      return ContextParser.IRI_REGEX.test(iri);\n    }\n    /**\n     * Add an @id term for all @reverse terms.\n     * @param {IJsonLdContextNormalized} context A context.\n     * @return {IJsonLdContextNormalized} The mutated input context.\n     */\n\n  }, {\n    key: \"idifyReverseTerms\",\n    value: function idifyReverseTerms(context) {\n      var _arr = Object.keys(context);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var key = _arr[_i];\n        var value = context[key];\n\n        if (value && typeof value === 'object') {\n          if (value['@reverse'] && !value['@id']) {\n            if (typeof value['@reverse'] !== 'string') {\n              throw new Error(\"Invalid @reverse value: '\".concat(value['@reverse'], \"'\"));\n            }\n\n            value['@id'] = value['@reverse'];\n            value['@reverse'] = true;\n          }\n        }\n      }\n\n      return context;\n    }\n    /**\n     * Expand all prefixed terms in the given context.\n     * @param {IJsonLdContextNormalized} context A context.\n     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n     *                                          via @base if @vocab is set to null.\n     * @return {IJsonLdContextNormalized} The mutated input context.\n     */\n\n  }, {\n    key: \"expandPrefixedTerms\",\n    value: function expandPrefixedTerms(context, expandContentTypeToBase) {\n      var _arr2 = Object.keys(context);\n\n      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n        var key = _arr2[_i2];\n\n        // Only expand allowed keys\n        if (ContextParser.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0) {\n          // Error if we try to alias a keyword to something else.\n          if (key[0] === '@' && ContextParser.ALIAS_KEYS_BLACKLIST.indexOf(key) >= 0) {\n            throw new Error(\"Keywords can not be aliased to something else.\\nTried mapping \".concat(key, \" to \").concat(context[key]));\n          } // Loop because prefixes might be nested\n\n\n          while (ContextParser.isPrefixValue(context[key])) {\n            var value = context[key];\n            var changed = false;\n\n            if (typeof value === 'string') {\n              context[key] = ContextParser.expandTerm(value, context, true);\n              changed = changed || value !== context[key];\n            } else {\n              var id = value['@id'];\n              var type = value['@type'];\n\n              if (id) {\n                context[key]['@id'] = ContextParser.expandTerm(id, context, true);\n                changed = changed || id !== context[key]['@id'];\n              }\n\n              if (type && type !== '@vocab') {\n                // First check @vocab, then fallback to @base\n                context[key]['@type'] = ContextParser.expandTerm(type, context, true);\n\n                if (expandContentTypeToBase && type === context[key]['@type']) {\n                  context[key]['@type'] = ContextParser.expandTerm(type, context, false);\n                }\n\n                changed = changed || type !== context[key]['@type'];\n              }\n            }\n\n            if (!changed) {\n              break;\n            }\n          }\n        }\n      }\n\n      return context;\n    }\n    /**\n     * Validate the entries of the given context.\n     * @param {IJsonLdContextNormalized} context A context.\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(context) {\n      var _arr3 = Object.keys(context);\n\n      for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n        var key = _arr3[_i3];\n        var value = context[key];\n        var valueType = typeof value; // First check if the key is a keyword\n\n        if (key[0] === '@') {\n          switch (key.substr(1)) {\n            case 'vocab':\n              if (value !== null && valueType !== 'string') {\n                throw new Error(\"Found an invalid @vocab IRI: \".concat(value));\n              }\n\n              break;\n\n            case 'base':\n              if (value !== null && valueType !== 'string') {\n                throw new Error(\"Found an invalid @base IRI: \".concat(context[key]));\n              }\n\n              break;\n\n            case 'language':\n              if (value !== null && valueType !== 'string') {\n                throw new Error(\"Found an invalid @language string: \".concat(value));\n              }\n\n              break;\n          }\n        } // Otherwise, consider the key a term\n\n\n        if (value !== null) {\n          switch (valueType) {\n            case 'string':\n              // Always valid\n              break;\n\n            case 'object':\n              if (key.indexOf(':') < 0 && !('@id' in value) && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n                throw new Error(\"Missing @id in context entry: '\".concat(key, \"': '\").concat(JSON.stringify(value), \"'\"));\n              }\n\n              var _arr4 = Object.keys(value);\n\n              for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n                var objectKey = _arr4[_i4];\n                var objectValue = value[objectKey];\n\n                if (!objectValue) {\n                  continue;\n                }\n\n                switch (objectKey) {\n                  case '@id':\n                    if (objectValue[0] === '@' && objectValue !== '@type' && objectValue !== '@id') {\n                      throw new Error(\"Illegal keyword alias in term value, found: '\".concat(key, \"': '\").concat(JSON.stringify(value), \"'\"));\n                    }\n\n                    break;\n\n                  case '@type':\n                    if (objectValue !== '@id' && objectValue !== '@vocab' && (objectValue[0] === '_' || !ContextParser.isValidIri(objectValue))) {\n                      throw new Error(\"A context @type must be an absolute IRI, found: '\".concat(key, \"': '\").concat(objectValue, \"'\"));\n                    }\n\n                    break;\n\n                  case '@reverse':\n                    if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                      throw new Error(\"Found non-matching @id and @reverse term values in '\".concat(key, \"':'\").concat(objectValue, \"' and '\").concat(value['@id'], \"'\"));\n                    }\n\n                    break;\n\n                  case '@container':\n                    if (objectValue === '@list' && value['@reverse']) {\n                      throw new Error(\"Term value can not be @container: @list and @reverse at the same time on '\".concat(key, \"'\"));\n                    }\n\n                    if (ContextParser.CONTAINERS.indexOf(objectValue) < 0) {\n                      throw new Error(\"Invalid term @container for '\".concat(key, \"' ('\").concat(objectValue, \"'), must be one of \").concat(ContextParser.CONTAINERS.join(', ')));\n                    }\n\n                    break;\n\n                  case '@language':\n                    if (objectValue !== null && typeof objectValue !== 'string') {\n                      throw new Error(\"Found an invalid term @language string in: '\".concat(key, \"': '\").concat(JSON.stringify(value), \"'\"));\n                    }\n\n                    break;\n                }\n              }\n\n              break;\n\n            default:\n              throw new Error(\"Found an invalid term value: '\".concat(key, \"': '\").concat(value, \"'\"));\n          }\n        }\n      }\n    }\n  }]);\n\n  return ContextParser;\n}(); // Regex for valid IRIs\n\n\nContextParser.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\^~\\[\\]`]*$/; // Keys in the contexts that will not be expanded based on the base IRI\n\nContextParser.EXPAND_KEYS_BLACKLIST = ['@base', '@vocab', '@language']; // Keys in the contexts that may not be aliased\n\nContextParser.ALIAS_KEYS_BLACKLIST = ['@container', '@graph', '@id', '@index', '@list', '@nest', '@none', '@prefix', '@reverse', '@set', '@type', '@value']; // All valid @container values\n\nContextParser.CONTAINERS = ['@list', '@set', '@index', '@language'];\nexports.ContextParser = ContextParser;","map":null,"metadata":{},"sourceType":"script"}