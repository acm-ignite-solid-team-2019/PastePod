{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sparqljson_parse_1 = require(\"sparqljson-parse\");\n/**\n * Converts SPARQL JSON results to a tree-based structure by splitting variables on a certain delimiter.\n */\n\n\nvar Converter =\n/*#__PURE__*/\nfunction () {\n  function Converter(settings) {\n    _classCallCheck(this, Converter);\n\n    settings = settings || {\n      delimiter: '_'\n    };\n    settings.prefixVariableQuestionMark = false;\n    this.delimiter = settings.delimiter || '_';\n    this.parser = new sparqljson_parse_1.SparqlJsonParser(settings);\n    this.materializeRdfJsTerms = settings.materializeRdfJsTerms;\n  }\n  /**\n   * Adds a value to a tree.\n   * @param tree A tree datastructure.\n   * @param {string[]} path The path of keys in the tree.\n   * @param {Term} value A value to add.\n   * @param {string} lastKeyPath The accumulated key path (separated by the given delimiter)\n   *                             through recursive calls, can be empty.\n   * @param {ISchema} schema A schema.\n   * @param {boolean} materializeRdfJsTerms If RDFJS terms should be materialized.\n   * @param {string} delimiter The string to join key paths by.\n   */\n\n\n  _createClass(Converter, [{\n    key: \"sparqlJsonResultsToTree\",\n\n    /**\n     * Convert a complete SPARQL JSON response to a GraphQL results tree.\n     * @param sparqlResponse A SPARQL JSON response.\n     * @param {ISchema} schema A schema.\n     * @return {any} A GraphQL results tree.\n     */\n    value: function sparqlJsonResultsToTree(sparqlResponse, schema) {\n      return this.bindingsToTree(this.parser.parseJsonResults(sparqlResponse), schema || {\n        singularizeVariables: {}\n      });\n    }\n    /**\n     * Convert an array of bindings to a GraphQL results tree.\n     * @param {IBindings[]} bindingsArray An array of bindings.\n     * @param {ISchema} schema A schema.\n     * @return {any} A GraphQL results tree.\n     */\n\n  }, {\n    key: \"bindingsToTree\",\n    value: function bindingsToTree(bindingsArray, schema) {\n      var singularRoot = schema && schema.singularizeVariables[''];\n      var tree = singularRoot ? {} : [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = bindingsArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var bindings = _step.value;\n          var subTree = tree;\n\n          if (!singularRoot) {\n            subTree = {};\n            tree.push(subTree);\n          }\n\n          for (var key in bindings) {\n            var path = key.split(this.delimiter);\n            var value = bindings[key];\n            Converter.addValueToTree(subTree, path, value, '', schema, this.materializeRdfJsTerms, this.delimiter);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return tree;\n    }\n  }], [{\n    key: \"addValueToTree\",\n    value: function addValueToTree(tree, path, value, lastKeyPath, schema, materializeRdfJsTerms, delimiter) {\n      var key = path[0];\n      var keyPath = lastKeyPath ? lastKeyPath + delimiter + key : key;\n      var singularize = schema.singularizeVariables[keyPath];\n\n      if (path.length === 1) {\n        // Leaf nodes\n        var setValue = materializeRdfJsTerms ? value.value : value;\n\n        if (singularize) {\n          if (!tree[key]) {\n            tree[key] = setValue;\n          }\n        } else {\n          if (!tree[key]) {\n            tree[key] = [];\n          }\n\n          tree[key].push(setValue);\n        }\n      } else {\n        // Inner nodes\n        var nextNode;\n\n        if (singularize) {\n          if (!tree[key]) {\n            tree[key] = {};\n          }\n\n          nextNode = tree[key];\n        } else {\n          if (!tree[key]) {\n            tree[key] = [];\n          }\n\n          nextNode = {};\n          tree[key].push(nextNode);\n        }\n\n        Converter.addValueToTree(nextNode, path.slice(1), value, keyPath, schema, materializeRdfJsTerms, delimiter);\n      }\n    }\n  }]);\n\n  return Converter;\n}();\n\nexports.Converter = Converter;","map":null,"metadata":{},"sourceType":"script"}