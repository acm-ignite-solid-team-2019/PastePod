{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar algebra_1 = require(\"./algebra\");\n\nvar factory_1 = require(\"./factory\");\n\nvar Util =\n/*#__PURE__*/\nfunction () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, null, [{\n    key: \"inScopeVariables\",\n\n    /**\n     * Detects all in-scope variables.\n     * In practice this means iterating through the entire algebra tree, finding all variables,\n     * and stopping when a project function is found.\n     * @param {Operation} op - Input algebra tree.\n     * @returns {Variable[]} - List of unique in-scope variables.\n     */\n    value: function inScopeVariables(op) {\n      var _Util$recurseOperatio;\n\n      var variables = [];\n\n      function addVariable(v) {\n        if (!variables.find(function (v2) {\n          return v.value === v2.value;\n        })) variables.push(v);\n      } // https://www.w3.org/TR/sparql11-query/#variableScope\n\n\n      Util.recurseOperation(op, (_Util$recurseOperatio = {}, _defineProperty(_Util$recurseOperatio, algebra_1.types.EXPRESSION, function (op) {\n        var expr = op;\n\n        if (expr.expressionType === 'aggregate' && expr.variable) {\n          var agg = expr;\n          addVariable(agg.variable);\n        }\n\n        return true;\n      }), _defineProperty(_Util$recurseOperatio, algebra_1.types.EXTEND, function (op) {\n        var extend = op;\n        addVariable(extend.variable);\n        return true;\n      }), _defineProperty(_Util$recurseOperatio, algebra_1.types.GRAPH, function (op) {\n        var graph = op;\n        if (graph.name.termType === 'Variable') addVariable(graph.name);\n        return true;\n      }), _defineProperty(_Util$recurseOperatio, algebra_1.types.GROUP, function (op) {\n        var group = op;\n        group.variables.forEach(addVariable);\n        return true;\n      }), _defineProperty(_Util$recurseOperatio, algebra_1.types.PATH, function (op) {\n        var path = op;\n        if (path.subject.termType === 'Variable') addVariable(path.subject);\n        if (path.object.termType === 'Variable') addVariable(path.object);\n        if (path.graph.termType === 'Variable') addVariable(path.graph);\n        return true;\n      }), _defineProperty(_Util$recurseOperatio, algebra_1.types.PATTERN, function (op) {\n        var pattern = op;\n        if (pattern.subject.termType === 'Variable') addVariable(pattern.subject);\n        if (pattern.predicate.termType === 'Variable') addVariable(pattern.predicate);\n        if (pattern.object.termType === 'Variable') addVariable(pattern.object);\n        if (pattern.graph.termType === 'Variable') addVariable(pattern.graph);\n        return true;\n      }), _defineProperty(_Util$recurseOperatio, algebra_1.types.PROJECT, function (op) {\n        var project = op;\n        project.variables.forEach(addVariable);\n        return false;\n      }), _defineProperty(_Util$recurseOperatio, algebra_1.types.SERVICE, function (op) {\n        var service = op;\n        if (service.name.termType === 'Variable') addVariable(service.name);\n        return true;\n      }), _defineProperty(_Util$recurseOperatio, algebra_1.types.VALUES, function (op) {\n        var values = op;\n        values.variables.forEach(addVariable);\n        return true;\n      }), _Util$recurseOperatio));\n      return variables;\n    }\n    /**\n     * Recurses through the given algebra tree\n     * A map of callback functions can be provided for individual Operation types to gather data.\n     * The return value of those callbacks should indicate whether recursion should be applied or not.\n     * Making modifications will change the original input object.\n     * @param {Operation} op - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation) => boolean } callbacks - A map of required callback Operations.\n     */\n\n  }, {\n    key: \"recurseOperation\",\n    value: function recurseOperation(op, callbacks) {\n      var result = op;\n      var doRecursion = true;\n      if (callbacks[op.type]) doRecursion = callbacks[op.type](op);\n      if (!doRecursion) return;\n\n      var recurseOp = function recurseOp(op) {\n        return Util.recurseOperation(op, callbacks);\n      };\n\n      switch (result.type) {\n        case algebra_1.types.ALT:\n          var alt = result;\n          recurseOp(alt.left);\n          recurseOp(alt.right);\n          break;\n\n        case algebra_1.types.ASK:\n          var ask = result;\n          recurseOp(ask.input);\n          break;\n\n        case algebra_1.types.BGP:\n          var bgp = result;\n          bgp.patterns.forEach(recurseOp);\n          break;\n\n        case algebra_1.types.CONSTRUCT:\n          var construct = result;\n          recurseOp(construct.input);\n          construct.template.map(recurseOp);\n          break;\n\n        case algebra_1.types.DESCRIBE:\n          var describe = result;\n          recurseOp(describe.input);\n          break;\n\n        case algebra_1.types.DISTINCT:\n          var distinct = result;\n          recurseOp(distinct.input);\n          break;\n\n        case algebra_1.types.EXPRESSION:\n          var expr = result;\n\n          if (expr.expressionType === algebra_1.expressionTypes.EXISTENCE) {\n            var exist = expr;\n            recurseOp(exist.input);\n          }\n\n          break;\n\n        case algebra_1.types.EXTEND:\n          var extend = result;\n          recurseOp(extend.input);\n          recurseOp(extend.expression);\n          break;\n\n        case algebra_1.types.FILTER:\n          var filter = result;\n          recurseOp(filter.input);\n          recurseOp(filter.expression);\n          break;\n\n        case algebra_1.types.FROM:\n          var from = result;\n          recurseOp(from.input);\n          break;\n\n        case algebra_1.types.GRAPH:\n          var graph = result;\n          recurseOp(graph.input);\n          break;\n\n        case algebra_1.types.GROUP:\n          var group = result;\n          recurseOp(group.input);\n          group.aggregates.forEach(recurseOp);\n          break;\n\n        case algebra_1.types.INV:\n          var inv = result;\n          recurseOp(inv.path);\n          break;\n\n        case algebra_1.types.JOIN:\n          var join = result;\n          recurseOp(join.left);\n          recurseOp(join.right);\n          break;\n\n        case algebra_1.types.LEFT_JOIN:\n          var leftJoin = result;\n          recurseOp(leftJoin.left);\n          recurseOp(leftJoin.right);\n          if (leftJoin.expression) recurseOp(leftJoin.expression);\n          break;\n\n        case algebra_1.types.LINK:\n          break;\n\n        case algebra_1.types.MINUS:\n          var minus = result;\n          recurseOp(minus.left);\n          recurseOp(minus.right);\n          break;\n\n        case algebra_1.types.NPS:\n          break;\n\n        case algebra_1.types.ONE_OR_MORE_PATH:\n          var oom = result;\n          recurseOp(oom.path);\n          break;\n\n        case algebra_1.types.ORDER_BY:\n          var order = result;\n          recurseOp(order.input);\n          order.expressions.forEach(recurseOp);\n          break;\n\n        case algebra_1.types.PATH:\n          var path = result;\n          recurseOp(path.predicate);\n          break;\n\n        case algebra_1.types.PATTERN:\n          break;\n\n        case algebra_1.types.PROJECT:\n          var project = result;\n          recurseOp(project.input);\n          break;\n\n        case algebra_1.types.REDUCED:\n          var reduced = result;\n          recurseOp(reduced.input);\n          break;\n\n        case algebra_1.types.SEQ:\n          var seq = result;\n          recurseOp(seq.left);\n          recurseOp(seq.right);\n          break;\n\n        case algebra_1.types.SERVICE:\n          var service = result;\n          recurseOp(service.input);\n          break;\n\n        case algebra_1.types.SLICE:\n          var slice = result;\n          recurseOp(slice.input);\n          break;\n\n        case algebra_1.types.UNION:\n          var union = result;\n          recurseOp(union.left);\n          recurseOp(union.right);\n          break;\n\n        case algebra_1.types.VALUES:\n          break;\n\n        case algebra_1.types.ZERO_OR_MORE_PATH:\n          var zom = result;\n          recurseOp(zom.path);\n          break;\n\n        case algebra_1.types.ZERO_OR_ONE_PATH:\n          var zoo = result;\n          recurseOp(zoo.path);\n          break;\n\n        default:\n          throw new Error('Unknown Operation type ' + result.type);\n      }\n    }\n    /**\n     * Creates a deep copy of the given Operation.\n     * Creates shallow copies of the non-Operation values.\n     * A map of callback functions can be provided for individual Operation types\n     * to specifically modify the given objects before triggering recursion.\n     * The return value of those callbacks should indicate whether recursion should be applied to this returned object or not.\n     * @param {Operation} op - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation, factory: Factory) => RecurseResult } callbacks - A map of required callback Operations.\n     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n     * @returns {Operation} - The copied result.\n     */\n\n  }, {\n    key: \"mapOperation\",\n    value: function mapOperation(op, callbacks, factory) {\n      var result = op;\n      var doRecursion = true;\n      factory = factory || new factory_1.default();\n\n      if (callbacks[op.type]) {\n        var _callbacks$op$type = callbacks[op.type](op, factory);\n\n        result = _callbacks$op$type.result;\n        doRecursion = _callbacks$op$type.recurse;\n      }\n\n      if (!doRecursion) return result;\n\n      var mapOp = function mapOp(op) {\n        return Util.mapOperation(op, callbacks, factory);\n      };\n\n      switch (result.type) {\n        case algebra_1.types.ALT:\n          var alt = result;\n          return factory.createAlt(mapOp(alt.left), mapOp(alt.right));\n\n        case algebra_1.types.ASK:\n          var ask = result;\n          return factory.createAsk(mapOp(ask.input));\n\n        case algebra_1.types.BGP:\n          var bgp = result;\n          return factory.createBgp(bgp.patterns.map(mapOp));\n\n        case algebra_1.types.CONSTRUCT:\n          var construct = result;\n          return factory.createConstruct(mapOp(construct.input), construct.template.map(mapOp));\n\n        case algebra_1.types.DESCRIBE:\n          var describe = result;\n          return factory.createDescribe(mapOp(describe.input), describe.terms);\n\n        case algebra_1.types.DISTINCT:\n          var distinct = result;\n          return factory.createDistinct(mapOp(distinct.input));\n\n        case algebra_1.types.EXPRESSION:\n          var expr = result;\n          return Util.mapExpression(expr, callbacks, factory);\n\n        case algebra_1.types.EXTEND:\n          var extend = result;\n          return factory.createExtend(mapOp(extend.input), extend.variable, mapOp(extend.expression));\n\n        case algebra_1.types.FILTER:\n          var filter = result;\n          return factory.createFilter(mapOp(filter.input), mapOp(filter.expression));\n\n        case algebra_1.types.FROM:\n          var from = result;\n          return factory.createFrom(mapOp(from.input), [].concat(from.default), [].concat(from.named));\n\n        case algebra_1.types.GRAPH:\n          var graph = result;\n          return factory.createGraph(mapOp(graph.input), graph.name);\n\n        case algebra_1.types.GROUP:\n          var group = result;\n          return factory.createGroup(mapOp(group.input), [].concat(group.variables), group.aggregates.map(mapOp));\n\n        case algebra_1.types.INV:\n          var inv = result;\n          return factory.createInv(mapOp(inv.path));\n\n        case algebra_1.types.JOIN:\n          var join = result;\n          return factory.createJoin(mapOp(join.left), mapOp(join.right));\n\n        case algebra_1.types.LEFT_JOIN:\n          var leftJoin = result;\n          return factory.createLeftJoin(mapOp(leftJoin.left), mapOp(leftJoin.right), leftJoin.expression ? mapOp(leftJoin.expression) : undefined);\n\n        case algebra_1.types.LINK:\n          var link = result;\n          return factory.createLink(link.iri);\n\n        case algebra_1.types.MINUS:\n          var minus = result;\n          return factory.createMinus(mapOp(minus.left), mapOp(minus.right));\n\n        case algebra_1.types.NPS:\n          var nps = result;\n          return factory.createNps([].concat(nps.iris));\n\n        case algebra_1.types.ONE_OR_MORE_PATH:\n          var oom = result;\n          return factory.createOneOrMorePath(mapOp(oom.path));\n\n        case algebra_1.types.ORDER_BY:\n          var order = result;\n          return factory.createOrderBy(mapOp(order.input), order.expressions.map(mapOp));\n\n        case algebra_1.types.PATH:\n          var path = result;\n          return factory.createPath(path.subject, mapOp(path.predicate), path.object, path.graph);\n\n        case algebra_1.types.PATTERN:\n          var pattern = result;\n          return factory.createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph);\n\n        case algebra_1.types.PROJECT:\n          var project = result;\n          return factory.createProject(mapOp(project.input), [].concat(project.variables));\n\n        case algebra_1.types.REDUCED:\n          var reduced = result;\n          return factory.createReduced(mapOp(reduced.input));\n\n        case algebra_1.types.SEQ:\n          var seq = result;\n          return factory.createSeq(mapOp(seq.left), mapOp(seq.right));\n\n        case algebra_1.types.SERVICE:\n          var service = result;\n          return factory.createService(mapOp(service.input), service.name, service.silent);\n\n        case algebra_1.types.SLICE:\n          var slice = result;\n          return factory.createSlice(mapOp(slice.input), slice.start, slice.length);\n\n        case algebra_1.types.UNION:\n          var union = result;\n          return factory.createUnion(mapOp(union.left), mapOp(union.right));\n\n        case algebra_1.types.VALUES:\n          var values = result;\n          return factory.createValues([].concat(values.variables), values.bindings.map(function (b) {\n            return Object.assign({}, b);\n          }));\n\n        case algebra_1.types.ZERO_OR_MORE_PATH:\n          var zom = result;\n          return factory.createZeroOrMorePath(mapOp(zom.path));\n\n        case algebra_1.types.ZERO_OR_ONE_PATH:\n          var zoo = result;\n          return factory.createZeroOrOnePath(mapOp(zoo.path));\n\n        default:\n          throw new Error('Unknown Operation type ' + result.type);\n      }\n    }\n    /**\n     * Similar to the {@link mapOperation} function but specifically for expressions.\n     * Both functions call each other while copying.\n     * Should not be called directly since it does not execute the callbacks, these happen in {@link mapOperation}.\n     * @param {Expression} expr - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation, factory: Factory) => RecurseResult } callbacks - A map of required callback Operations.\n     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n     * @returns {Operation} - The copied result.\n     */\n\n  }, {\n    key: \"mapExpression\",\n    value: function mapExpression(expr, callbacks, factory) {\n      var recurse = function recurse(op) {\n        return Util.mapOperation(op, callbacks, factory);\n      };\n\n      switch (expr.expressionType) {\n        case algebra_1.expressionTypes.AGGREGATE:\n          if (expr.variable) {\n            var bound = expr;\n            return factory.createBoundAggregate(bound.variable, bound.aggregator, recurse(bound.expression), bound.distinct, bound.separator);\n          }\n\n          var aggregate = expr;\n          return factory.createAggregateExpression(aggregate.aggregator, recurse(aggregate.expression), aggregate.distinct, aggregate.separator);\n\n        case algebra_1.expressionTypes.EXISTENCE:\n          var exist = expr;\n          return factory.createExistenceExpression(exist.not, recurse(exist.input));\n\n        case algebra_1.expressionTypes.NAMED:\n          var named = expr;\n          return factory.createNamedExpression(named.name, named.args.map(recurse));\n\n        case algebra_1.expressionTypes.OPERATOR:\n          var op = expr;\n          return factory.createOperatorExpression(op.operator, op.args.map(recurse));\n\n        case algebra_1.expressionTypes.TERM:\n          var term = expr;\n          return factory.createTermExpression(term.term);\n\n        default:\n          throw new Error('Unknown Expression type ' + expr.expressionType);\n      }\n    }\n  }, {\n    key: \"createUniqueVariable\",\n    value: function createUniqueVariable(label, variables, dataFactory) {\n      var counter = 0;\n      var labelLoop = label;\n\n      while (variables[labelLoop]) {\n        labelLoop = label + counter++;\n      }\n\n      return dataFactory.variable(labelLoop);\n    }\n  }]);\n\n  return Util;\n}();\n\nexports.default = Util;","map":null,"metadata":{},"sourceType":"script"}