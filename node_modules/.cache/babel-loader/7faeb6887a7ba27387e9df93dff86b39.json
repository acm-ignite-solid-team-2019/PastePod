{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Algebra = require(\"./algebra\");\n\nvar factory_1 = require(\"./factory\");\n\nvar util_1 = require(\"./util\");\n\nvar Parser = require('sparqljs').Parser;\n\nvar isEqual = require('lodash.isequal');\n\nvar types = Algebra.types;\nvar variables = new Set();\nvar varCount = 0;\nvar useQuads = false;\nvar factory;\n/**\n * Translates the given SPARQL query to SPARQL Algebra.\n * @param sparql - Either a SPARQL string or an object generated by sparql.js\n * @param options - Optional options object. Current options:\n *                    * dataFactory: The Datafactory used to generate terms. Default @rdfjs/data-model.\n *                    * quads: Boolean indicating whether triples should be converted to Quads (consumes GRAPH statements). Default false.\n *                    * prefixes: Pre-defined prefixes for the given query. Default empty.\n *                    * baseIRI: Base IRI that should be used for the query. Default undefined (throws error if required).\n * @returns {Operation}\n */\n\nfunction translate(sparql, options) {\n  options = options || {};\n  factory = new factory_1.default(options.dataFactory);\n\n  if (isString(sparql)) {\n    var parser = new Parser(options.prefixes, options.baseIRI); // resets the identifier counter used for blank nodes\n    // provides nicer and more consistent output if there are multiple calls\n\n    parser._resetBlanks();\n\n    sparql = parser.parse(sparql);\n  }\n\n  return translateQuery(sparql, options.quads, options.blankToVariable);\n}\n\nexports.default = translate;\n\nfunction translateQuery(sparql, quads, blankToVariable) {\n  // this set is filled in during the inScopeVariables call\n  variables = new Set();\n  varCount = 0;\n  useQuads = quads;\n  if (sparql.type !== 'query') throw new Error('Translate only works on complete query objects.'); // group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE\n\n  var group = {\n    type: 'group',\n    patterns: sparql.where || []\n  };\n  var vars = new Set(Object.keys(inScopeVariables(group)).map(factory.createTerm.bind(factory)));\n  var res = translateGroupGraphPattern(group);\n  res = translateAggregates(sparql, res, vars);\n\n  if (blankToVariable) {\n    res = translateBlankNodesToVariables(res, vars);\n  }\n\n  return res;\n}\n\nfunction isString(str) {\n  return typeof str === 'string';\n}\n\nfunction isObject(o) {\n  return o !== null && typeof o === 'object';\n}\n\nfunction isVariable(str) {\n  // there is also a '?' operator...\n  return isString(str) && str[0] === '?' && str.length > 1;\n} // 18.2.1\n\n\nfunction inScopeVariables(thingy) {\n  var inScope = {};\n\n  if (isVariable(thingy)) {\n    inScope[thingy] = true;\n    variables.add(thingy); // keep track of all variables so we don't generate duplicates\n  } else if (isObject(thingy)) {\n    if (thingy.type === 'bind') {\n      inScopeVariables(thingy.expression); // to fill `variables`\n\n      Object.assign(inScope, inScopeVariables(thingy.variable));\n    } else if (thingy.queryType === 'SELECT') {\n      var all = inScopeVariables(thingy.where); // always executing this makes sure `variables` gets filled correctly\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = thingy.variables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _v = _step.value;\n          if (_v === '*') Object.assign(inScope, all);else if (_v.variable) // aggregates\n            Object.assign(inScope, inScopeVariables(_v.variable));else Object.assign(inScope, inScopeVariables(_v));\n        } // TODO: I'm not 100% sure if you always add these or only when '*' was selected\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (thingy.group) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = thingy.group[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var v = _step2.value;\n            Object.assign(inScope, inScopeVariables(v));\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } else {\n      var _arr = Object.keys(thingy);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var key = _arr[_i];\n        Object.assign(inScope, inScopeVariables(thingy[key]));\n      }\n    }\n  }\n\n  return inScope;\n}\n\nfunction translateGroupGraphPattern(thingy) {\n  // 18.2.2.1\n  // already done by sparql parser\n  // 18.2.2.2\n  var filters = [];\n  var nonfilters = [];\n\n  if (thingy.patterns) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = thingy.patterns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var pattern = _step3.value;\n        (pattern.type === 'filter' ? filters : nonfilters).push(pattern);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  } // 18.2.2.3\n  // 18.2.2.4\n  // 18.2.2.5\n\n\n  if (thingy.type === 'bgp') return translateBgp(thingy); // 18.2.2.6\n\n  var result;\n  if (thingy.type === 'union') result = nonfilters.map(function (p) {\n    // sparqljs doesn't always indicate the children are groups\n    if (p.type !== 'group') p = {\n      type: 'group',\n      patterns: [p]\n    };\n    return translateGroupGraphPattern(p);\n  }).reduce(function (acc, item) {\n    return factory.createUnion(acc, item);\n  });else if (thingy.type === 'graph') // need to handle this separately since the filters need to be in the graph\n    return translateGraph(thingy);else if (thingy.type === 'group') result = nonfilters.reduce(accumulateGroupGraphPattern, factory.createBgp([])); // custom values operation\n  else if (thingy.type === 'values') result = translateInlineData(thingy);else if (thingy.type === 'query') result = translateQuery(thingy, useQuads, false);else throw new Error('Unexpected type: ' + thingy.type);\n\n  if (filters.length > 0) {\n    var expressions = filters.map(function (filter) {\n      return translateExpression(filter.expression);\n    });\n    if (expressions.length > 0) result = factory.createFilter(result, expressions.reduce(function (acc, exp) {\n      return factory.createOperatorExpression('&&', [acc, exp]);\n    }));\n  }\n\n  return result;\n}\n\nfunction translateExpression(exp) {\n  if (isString(exp)) return factory.createTermExpression(factory.createTerm(exp));\n  if (exp.aggregation) return factory.createAggregateExpression(exp.aggregation, translateExpression(exp.expression), exp.distinct, exp.separator);\n  if (exp.function) return factory.createNamedExpression(factory.createTerm(exp.function), exp.args.map(translateExpression));\n\n  if (exp.operator) {\n    if (exp.operator === 'exists' || exp.operator === 'notexists') return factory.createExistenceExpression(exp.operator === 'notexists', translateGroupGraphPattern(exp.args[0]));\n    if (exp.operator === 'in' || exp.operator === 'notin') exp.args = [exp.args[0]].concat(exp.args[1]); // sparql.js uses 2 arguments with the second one being a list\n\n    return factory.createOperatorExpression(exp.operator, exp.args.map(translateExpression));\n  }\n\n  throw new Error('Unknown expression: ' + JSON.stringify(exp));\n}\n\nfunction translateBgp(thingy) {\n  var patterns = [];\n  var joins = [];\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = thingy.triples[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var t = _step4.value;\n\n      if (t.predicate.type === 'path') {\n        // translatePath returns a mix of Quads and Paths\n        var path = translatePath(t);\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = path[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var p = _step5.value;\n\n            if (p.type === types.PATH) {\n              if (patterns.length > 0) joins.push(factory.createBgp(patterns));\n              patterns = [];\n              joins.push(p);\n            } else patterns.push(p);\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      } else patterns.push(translateTriple(t));\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  if (patterns.length > 0) joins.push(factory.createBgp(patterns));\n  if (joins.length === 1) return joins[0];\n  return joins.reduce(function (acc, item) {\n    return factory.createJoin(acc, item);\n  });\n}\n\nfunction translatePath(triple) {\n  var sub = factory.createTerm(triple.subject);\n  var pred = translatePathPredicate(triple.predicate);\n  var obj = factory.createTerm(triple.object);\n  return simplifyPath(sub, pred, obj);\n}\n\nfunction translatePathPredicate(predicate) {\n  if (isString(predicate)) return factory.createLink(factory.createTerm(predicate));\n  if (predicate.pathType === '^') return factory.createInv(translatePathPredicate(predicate.items[0]));\n\n  if (predicate.pathType === '!') {\n    // negation is either over a single predicate or a list of disjuncted properties\n    var normals = [];\n    var inverted = [];\n    var items;\n    if (predicate.items[0].type === 'path' && predicate.items[0].pathType === '|') items = predicate.items[0].items; // the | element\n    else items = predicate.items;\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = items[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var item = _step6.value;\n        if (isString(item)) normals.push(item);else if (item.pathType === '^') inverted.push(item.items[0]);else throw new Error('Unexpected item: ' + JSON.stringify(item));\n      } // NPS elements do not have the LINK function\n\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n\n    var normalElement = factory.createNps(normals.map(factory.createTerm.bind(factory)));\n    var invertedElement = factory.createInv(factory.createNps(inverted.map(factory.createTerm.bind(factory))));\n    if (inverted.length === 0) return normalElement;\n    if (normals.length === 0) return invertedElement;\n    return factory.createAlt(normalElement, invertedElement);\n  }\n\n  if (predicate.pathType === '/') return predicate.items.map(translatePathPredicate).reduce(function (acc, p) {\n    return factory.createSeq(acc, p);\n  });\n  if (predicate.pathType === '|') return predicate.items.map(translatePathPredicate).reduce(function (acc, p) {\n    return factory.createAlt(acc, p);\n  });\n  if (predicate.pathType === '*') return factory.createZeroOrMorePath(translatePathPredicate(predicate.items[0]));\n  if (predicate.pathType === '+') return factory.createOneOrMorePath(translatePathPredicate(predicate.items[0]));\n  if (predicate.pathType === '?') return factory.createZeroOrOnePath(translatePathPredicate(predicate.items[0]));\n  throw new Error('Unable to translate path expression ' + predicate);\n}\n\nfunction simplifyPath(subject, predicate, object) {\n  if (predicate.type === types.LINK) return [factory.createPattern(subject, predicate.iri, object)];\n  if (predicate.type === types.INV) return simplifyPath(object, predicate.path, subject);\n\n  if (predicate.type === types.SEQ) {\n    var v = generateFreshVar();\n    var left = simplifyPath(subject, predicate.left, v);\n    var right = simplifyPath(v, predicate.right, object);\n    return left.concat(right);\n  }\n\n  return [factory.createPath(subject, predicate, object)];\n}\n\nfunction generateFreshVar() {\n  var v = '?var' + varCount++;\n  if (variables.has(v)) return generateFreshVar();\n  variables.add(v);\n  return factory.createTerm(v);\n}\n\nfunction translateTriple(triple) {\n  return factory.createPattern(factory.createTerm(triple.subject), factory.createTerm(triple.predicate), factory.createTerm(triple.object));\n}\n\nfunction translateGraph(graph) {\n  var name = factory.createTerm(graph.name);\n  graph.type = 'group';\n  var result = translateGroupGraphPattern(graph);\n  if (useQuads) result = recurseGraph(result, name);else result = factory.createGraph(result, name);\n  return result;\n}\n\nvar typeVals = Object.keys(types).map(function (key) {\n  return types[key];\n});\n\nfunction recurseGraph(thingy, graph) {\n  if (thingy.type === types.BGP) thingy.patterns = thingy.patterns.map(function (quad) {\n    quad.graph = graph;\n    return quad;\n  });else if (thingy.type === types.PATH) thingy.graph = graph;else {\n    var _arr2 = Object.keys(thingy);\n\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var key = _arr2[_i2];\n      if (Array.isArray(thingy[key])) thingy[key] = thingy[key].map(function (x) {\n        return recurseGraph(x, graph);\n      });else if (typeVals.indexOf(thingy[key].type) >= 0) // can't do instanceof on an interface\n        thingy[key] = recurseGraph(thingy[key], graph);\n    }\n  }\n  return thingy;\n}\n\nfunction accumulateGroupGraphPattern(G, E) {\n  if (E.type === 'optional') {\n    // optional input needs to be interpreted as a group\n    var A = translateGroupGraphPattern({\n      type: 'group',\n      patterns: E.patterns\n    });\n\n    if (A.type === types.FILTER) {\n      var filter = A;\n      G = factory.createLeftJoin(G, filter.input, filter.expression);\n    } else G = factory.createLeftJoin(G, A);\n  } else if (E.type === 'minus') {\n    // minus input needs to be interpreted as a group\n    var _A = translateGroupGraphPattern({\n      type: 'group',\n      patterns: E.patterns\n    });\n\n    G = factory.createMinus(G, _A);\n  } else if (E.type === 'bind') G = factory.createExtend(G, factory.createTerm(E.variable), translateExpression(E.expression));else if (E.type === 'service') {\n    // transform to group so childnodes get parsed correctly\n    E.type = 'group';\n\n    var _A2 = factory.createService(translateGroupGraphPattern(E), factory.createTerm(E.name), E.silent);\n\n    G = simplifiedJoin(G, _A2);\n  } else {\n    var _A3 = translateGroupGraphPattern(E);\n\n    G = simplifiedJoin(G, _A3);\n  }\n\n  return G;\n}\n\nfunction simplifiedJoin(G, A) {\n  // 18.2.2.8 (simplification)\n  if (G.type === types.BGP && G.patterns.length === 0) G = A;else if (A.type === types.BGP && A.patterns.length === 0) {} // do nothing\n  else G = factory.createJoin(G, A);\n  return G;\n}\n\nfunction translateInlineData(values) {\n  var variables = (values.values.length === 0 ? [] : Object.keys(values.values[0])).map(factory.createTerm.bind(factory));\n  var bindings = values.values.map(function (binding) {\n    var keys = Object.keys(binding);\n    keys = keys.filter(function (k) {\n      return binding[k] !== undefined;\n    });\n    var map = {};\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = keys[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var key = _step7.value;\n        map[key] = factory.createTerm(binding[key]);\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n\n    return map;\n  });\n  return factory.createValues(variables, bindings);\n} // --------------------------------------- AGGREGATES\n\n\nfunction translateAggregates(query, res, variables) {\n  // 18.2.4.1\n  var E = [];\n  var A = {};\n  query.variables = mapAggregates(query.variables, A);\n  query.having = mapAggregates(query.having, A);\n  query.order = mapAggregates(query.order, A); // if there are any aggregates or if we have a groupBy (both result in a GROUP)\n\n  if (query.group || Object.keys(A).length > 0) {\n    var aggregates = Object.keys(A).map(function (v) {\n      return translateBoundAggregate(A[v], factory.createTerm(v));\n    });\n    var vars = [];\n\n    if (query.group) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = query.group[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var e = _step8.value;\n\n          if (e.expression.type) {\n            var v = e.variable ? factory.createTerm(e.variable) : generateFreshVar();\n            res = factory.createExtend(res, v, translateExpression(e.expression));\n            vars.push(v);\n          } else vars.push(factory.createTerm(e.expression)); // this will always be a var, otherwise sparql would be invalid\n\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n\n    res = factory.createGroup(res, vars, aggregates);\n  } // 18.2.4.2\n\n\n  if (query.having) {\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      for (var _iterator9 = query.having[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var filter = _step9.value;\n        res = factory.createFilter(res, translateExpression(filter));\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n  } // 18.2.4.3\n\n\n  if (query.values) res = factory.createJoin(res, translateInlineData(query)); // 18.2.4.4\n\n  var PV = new Set();\n\n  if (query.queryType === 'SELECT' || query.queryType === 'DESCRIBE') {\n    if (query.variables.indexOf('*') >= 0) PV = variables;else {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = query.variables[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var _v2 = _step10.value;\n          // can have non-variables with DESCRIBE\n          if (isVariable(_v2) || !_v2.variable) PV.add(factory.createTerm(_v2));else if (_v2.variable) // ... AS ?x\n            {\n              PV.add(factory.createTerm(_v2.variable));\n              E.push(_v2);\n            }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n  } // TODO: Jena simplifies by having a list of extends\n\n\n  for (var _i3 = 0; _i3 < E.length; _i3++) {\n    var _v3 = E[_i3];\n    res = factory.createExtend(res, factory.createTerm(_v3.variable), translateExpression(_v3.expression));\n  } // 18.2.5\n  // not using toList and toMultiset\n  // 18.2.5.1\n\n\n  if (query.order) res = factory.createOrderBy(res, query.order.map(function (exp) {\n    var result = translateExpression(exp.expression);\n    if (exp.descending) result = factory.createOperatorExpression(types.DESC, [result]); // TODO: should this really be an epxression?\n\n    return result;\n  })); // 18.2.5.2\n  // construct does not need a project (select, ask and describe do)\n\n  if (query.queryType === 'SELECT') res = factory.createProject(res, Array.from(PV)); // 18.2.5.3\n\n  if (query.distinct) res = factory.createDistinct(res); // 18.2.5.4\n\n  if (query.reduced) res = factory.createReduced(res); // 18.2.5.5\n\n  if (query.offset || query.limit) res = factory.createSlice(res, query.offset, query.limit); // NEW: support for ask/construct/describe queries\n\n  if (query.queryType === 'CONSTRUCT') res = factory.createConstruct(res, query.template.map(translateTriple));else if (query.queryType === 'ASK') res = factory.createAsk(res);else if (query.queryType === 'DESCRIBE') res = factory.createDescribe(res, Array.from(PV));\n  if (query.from) res = factory.createFrom(res, query.from.default.map(factory.createTerm.bind(factory)), query.from.named.map(factory.createTerm.bind(factory)));\n  return res;\n} // rewrites some of the input sparql object to make use of aggregate variables\n\n\nfunction mapAggregates(thingy, aggregates) {\n  if (!thingy) return thingy;\n\n  if (thingy.type === 'aggregate') {\n    var found = false;\n    var v;\n\n    var _arr3 = Object.keys(aggregates);\n\n    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {\n      var key = _arr3[_i4];\n\n      if (isEqual(aggregates[key], thingy)) {\n        v = key;\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      v = '?' + generateFreshVar().value; // this is still in \"sparql.js language\" so a var string is still needed\n\n      aggregates[v] = thingy;\n    }\n\n    return v; // this is still in \"sparql.js language\" so a var string is still needed\n  } // non-aggregate expression\n\n\n  if (thingy.expression) thingy.expression = mapAggregates(thingy.expression, aggregates);else if (thingy.args) mapAggregates(thingy.args, aggregates);else if (Array.isArray(thingy)) thingy.forEach(function (subthingy, idx) {\n    return thingy[idx] = mapAggregates(subthingy, aggregates);\n  });\n  return thingy;\n}\n\nfunction translateBoundAggregate(thingy, v) {\n  if (thingy.type !== 'aggregate' || !thingy.aggregation) throw new Error('Unexpected input: ' + JSON.stringify(thingy));\n  var A = translateExpression(thingy);\n  A.variable = v;\n  return A;\n}\n\nfunction translateBlankNodesToVariables(res, variables) {\n  var blankToVariableMapping = {};\n  var variablesRaw = Array.from(variables).reduce(function (acc, variable) {\n    acc[variable.value] = true;\n    return acc;\n  }, {});\n  return util_1.default.mapOperation(res, {\n    'path': function path(op, factory) {\n      return {\n        result: factory.createPath(blankToVariable(op.subject), op.predicate, blankToVariable(op.object), blankToVariable(op.graph)),\n        recurse: false\n      };\n    },\n    'pattern': function pattern(op, factory) {\n      return {\n        result: factory.createPattern(blankToVariable(op.subject), blankToVariable(op.predicate), blankToVariable(op.object), blankToVariable(op.graph)),\n        recurse: false\n      };\n    }\n  });\n\n  function blankToVariable(term) {\n    if (term.termType === 'BlankNode') {\n      var variable = blankToVariableMapping[term.value];\n\n      if (!variable) {\n        variable = util_1.default.createUniqueVariable(term.value, variablesRaw, factory.dataFactory);\n        variablesRaw[variable.value] = true;\n        blankToVariableMapping[term.value] = variable;\n      }\n\n      return variable;\n    }\n\n    return term;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}