{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"isomorphic-fetch\");\n\nvar sparqljs_1 = require(\"sparqljs\");\n\nvar sparqljson_parse_1 = require(\"sparqljson-parse\");\n\nvar sparqlxml_parse_1 = require(\"sparqlxml-parse\"); // tslint:disable-next-line:no-var-requires\n\n\nvar n3 = require('n3');\n/**\n * A SparqlEndpointFetcher can send queries to SPARQL endpoints,\n * and retrieve and parse the results.\n */\n\n\nvar SparqlEndpointFetcher =\n/*#__PURE__*/\nfunction () {\n  function SparqlEndpointFetcher(args) {\n    var _this = this,\n        _this$sparqlParsers;\n\n    _classCallCheck(this, SparqlEndpointFetcher);\n\n    args = args || {};\n    this.fetchCb = args.fetch || fetch;\n    this.sparqlJsonParser = new sparqljson_parse_1.SparqlJsonParser(args);\n    this.sparqlXmlParser = new sparqlxml_parse_1.SparqlXmlParser(args);\n    this.sparqlParsers = (_this$sparqlParsers = {}, _defineProperty(_this$sparqlParsers, SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON, {\n      parseBooleanStream: function parseBooleanStream(sparqlResponseStream) {\n        return _this.sparqlJsonParser.parseJsonBooleanStream(sparqlResponseStream);\n      },\n      parseResultsStream: function parseResultsStream(sparqlResponseStream) {\n        return _this.sparqlJsonParser.parseJsonResultsStream(sparqlResponseStream);\n      }\n    }), _defineProperty(_this$sparqlParsers, SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML, {\n      parseBooleanStream: function parseBooleanStream(sparqlResponseStream) {\n        return _this.sparqlXmlParser.parseXmlBooleanStream(sparqlResponseStream);\n      },\n      parseResultsStream: function parseResultsStream(sparqlResponseStream) {\n        return _this.sparqlXmlParser.parseXmlResultsStream(sparqlResponseStream);\n      }\n    }), _this$sparqlParsers);\n  }\n  /**\n   * Get the query type of the given query.\n   *\n   * This will parse the query and thrown an exception on syntax errors.\n   *\n   * @param {string} query A query.\n   * @return {\"SELECT\" | \"ASK\" | \"CONSTRUCT\" | \"UNKNOWN\"} The query type.\n   */\n\n\n  _createClass(SparqlEndpointFetcher, [{\n    key: \"getQueryType\",\n    value: function getQueryType(query) {\n      var parsedQuery = new sparqljs_1.Parser().parse(query);\n      return parsedQuery.type === 'query' ? parsedQuery.queryType === 'DESCRIBE' ? 'CONSTRUCT' : parsedQuery.queryType : \"UNKNOWN\";\n    }\n    /**\n     * Send a SELECT query to the given endpoint URL and return the resulting bindings stream.\n     * @see IBindings\n     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n     * @param {string} query    A SPARQL query string.\n     * @return {Promise<NodeJS.ReadableStream>} A stream of {@link IBindings}.\n     */\n\n  }, {\n    key: \"fetchBindings\",\n    value: function fetchBindings(endpoint, query) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _ref, _ref2, contentType, responseStream, parser;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);\n\n              case 2:\n                _ref = _context.sent;\n                _ref2 = _slicedToArray(_ref, 2);\n                contentType = _ref2[0];\n                responseStream = _ref2[1];\n                parser = this.sparqlParsers[contentType];\n\n                if (parser) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new Error('Unknown SPARQL results content type: ' + contentType);\n\n              case 9:\n                return _context.abrupt(\"return\", parser.parseResultsStream(responseStream));\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Send an ASK query to the given endpoint URL and return a promise resolving to the boolean answer.\n     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n     * @param {string} query    A SPARQL query string.\n     * @return {Promise<boolean>} A boolean resolving to the answer.\n     */\n\n  }, {\n    key: \"fetchAsk\",\n    value: function fetchAsk(endpoint, query) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var _ref3, _ref4, contentType, responseStream, parser;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);\n\n              case 2:\n                _ref3 = _context2.sent;\n                _ref4 = _slicedToArray(_ref3, 2);\n                contentType = _ref4[0];\n                responseStream = _ref4[1];\n                parser = this.sparqlParsers[contentType];\n\n                if (parser) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new Error('Unknown SPARQL results content type: ' + contentType);\n\n              case 9:\n                return _context2.abrupt(\"return\", parser.parseBooleanStream(responseStream));\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Send a CONSTRUCT/DESCRIBE query to the given endpoint URL and return the resulting triple stream.\n     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n     * @param {string} query    A SPARQL query string.\n     * @return {Promise<Stream>} A stream of triples.\n     */\n\n  }, {\n    key: \"fetchTriples\",\n    value: function fetchTriples(endpoint, query) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        var rawStream;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_TURTLE);\n\n              case 2:\n                rawStream = _context3.sent[1];\n                return _context3.abrupt(\"return\", rawStream.pipe(new n3.StreamParser({\n                  format: SparqlEndpointFetcher.CONTENTTYPE_TURTLE\n                })));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Send a query to the given endpoint URL and return the resulting stream.\n     *\n     * This will only accept responses with the application/sparql-results+json content type.\n     *\n     * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n     * @param {string} query        A SPARQL query string.\n     * @param {string} acceptHeader The HTTP accept to use.\n     * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.\n     */\n\n  }, {\n    key: \"fetchRawStream\",\n    value: function fetchRawStream(endpoint, query, acceptHeader) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4() {\n        var url, headers, httpResponse, responseStream, contentType;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                url = endpoint + '?query=' + encodeURIComponent(query); // Initiate request\n\n                headers = new Headers();\n                headers.append('Accept', acceptHeader);\n                _context4.next = 5;\n                return this.fetchCb(url, {\n                  headers: headers\n                });\n\n              case 5:\n                httpResponse = _context4.sent;\n                // Wrap WhatWG readable stream into a Node.js readable stream\n                // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n                responseStream = require('is-stream')(httpResponse.body) ? httpResponse.body : require('node-web-streams').toNodeReadable(httpResponse.body); // Determine the content type and emit it to the stream\n\n                contentType = httpResponse.headers.get('Content-Type') || '';\n\n                if (contentType.indexOf(';') > 0) {\n                  contentType = contentType.substr(0, contentType.indexOf(';'));\n                } // Emit an error if the server returned an invalid response\n\n\n                if (!httpResponse.ok) {\n                  setImmediate(function () {\n                    return responseStream.emit('error', new Error('Invalid SPARQL endpoint (' + endpoint + ') response: ' + httpResponse.statusText));\n                  });\n                }\n\n                return _context4.abrupt(\"return\", [contentType, responseStream]);\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }]);\n\n  return SparqlEndpointFetcher;\n}();\n\nSparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON = 'application/sparql-results+json';\nSparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML = 'application/sparql-results+xml';\nSparqlEndpointFetcher.CONTENTTYPE_SPARQL = \"\".concat(SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON, \";q=1.0,\").concat(SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML, \";q=0.7\");\nSparqlEndpointFetcher.CONTENTTYPE_TURTLE = 'text/turtle';\nexports.SparqlEndpointFetcher = SparqlEndpointFetcher;","map":null,"metadata":{},"sourceType":"script"}