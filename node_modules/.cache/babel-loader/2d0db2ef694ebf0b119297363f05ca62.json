{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nvar asynciterator_1 = require(\"asynciterator\");\n\nvar asynciterator_promiseproxy_1 = require(\"asynciterator-promiseproxy\");\n\nvar rdf_string_1 = require(\"rdf-string\");\n\nvar rdf_terms_1 = require(\"rdf-terms\");\n/**\n * A comunica Query Operation Actor that resolves BGPs in a left-deep manner\n * based on the pattern with the smallest item count.\n */\n\n\nvar ActorQueryOperationBgpLeftDeepSmallest =\n/*#__PURE__*/\nfunction (_bus_query_operation_) {\n  _inherits(ActorQueryOperationBgpLeftDeepSmallest, _bus_query_operation_);\n\n  function ActorQueryOperationBgpLeftDeepSmallest(args) {\n    _classCallCheck(this, ActorQueryOperationBgpLeftDeepSmallest);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ActorQueryOperationBgpLeftDeepSmallest).call(this, args, 'bgp'));\n  }\n  /**\n   * Create a new bindings stream\n   * that takes every binding of the base stream,\n   * materializes the remaining patterns with it,\n   * and emits all bindings from this new set of patterns.\n   * @param {BindingsStream} baseStream The base stream.\n   * @param {Algebra.Pattern[]} patterns The patterns to materialize with each binding of the base stream.\n   * @param {(patterns: Algebra.Pattern[]) => Promise<IActorQueryOperationOutput>} patternBinder A callback\n   * to retrieve the bindings stream of an array of patterns.\n   * @return {BindingsStream}\n   */\n\n\n  _createClass(ActorQueryOperationBgpLeftDeepSmallest, [{\n    key: \"testOperation\",\n    value: function () {\n      var _testOperation = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(pattern, context) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(pattern.patterns.length < 2)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('Actor ' + this.name + ' can only operate on BGPs with at least two patterns.');\n\n              case 2:\n                return _context.abrupt(\"return\", true);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function testOperation(_x, _x2) {\n        return _testOperation.apply(this, arguments);\n      }\n\n      return testOperation;\n    }()\n  }, {\n    key: \"runOperation\",\n    value: function () {\n      var _runOperation = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(pattern, context) {\n        var _this = this;\n\n        var patternOutputs, metadatas, smallestId, i, smallestPattern, remainingPatterns, remainingMetadatas, subContext, bindingsStream, variables, metadata;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return Promise.all(pattern.patterns.map(function (subPattern) {\n                  return _this.mediatorQueryOperation.mediate({\n                    operation: subPattern,\n                    context: context\n                  });\n                }));\n\n              case 2:\n                _context4.t0 = bus_query_operation_1.ActorQueryOperation.getSafeBindings;\n                patternOutputs = _context4.sent.map(_context4.t0);\n                _context4.next = 6;\n                return ActorQueryOperationBgpLeftDeepSmallest.hasOneEmptyPatternOutput(patternOutputs);\n\n              case 6:\n                if (!_context4.sent) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", {\n                  bindingsStream: new asynciterator_1.EmptyIterator(),\n                  metadata: function metadata() {\n                    return Promise.resolve({\n                      totalItems: 0\n                    });\n                  },\n                  type: 'bindings',\n                  variables: []\n                });\n\n              case 8:\n                _context4.next = 10;\n                return Promise.all(patternOutputs.map(\n                /*#__PURE__*/\n                function () {\n                  var _ref = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee2(patternOutput) {\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            if (!patternOutput.metadata) {\n                              _context2.next = 6;\n                              break;\n                            }\n\n                            _context2.next = 3;\n                            return patternOutput.metadata();\n\n                          case 3:\n                            _context2.t0 = _context2.sent;\n                            _context2.next = 7;\n                            break;\n\n                          case 6:\n                            _context2.t0 = {};\n\n                          case 7:\n                            return _context2.abrupt(\"return\", _context2.t0);\n\n                          case 8:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, this);\n                  }));\n\n                  return function (_x5) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()));\n\n              case 10:\n                metadatas = _context4.sent;\n                smallestId = ActorQueryOperationBgpLeftDeepSmallest.getSmallestPatternId(metadatas);\n                this.logDebug(context, 'Smallest pattern: ', {\n                  pattern: pattern.patterns[smallestId],\n                  metadata: metadatas[smallestId]\n                }); // Close the non-smallest streams\n\n                for (i = 0; i < patternOutputs.length; i++) {\n                  if (i !== smallestId) {\n                    patternOutputs[i].bindingsStream.close();\n                  }\n                } // Take the pattern with the smallest number of items\n\n\n                smallestPattern = patternOutputs.slice(smallestId)[0];\n                remainingPatterns = pattern.patterns.concat([]);\n                remainingPatterns.splice(smallestId, 1);\n                remainingMetadatas = metadatas.concat([]);\n                remainingMetadatas.splice(smallestId, 1); // Check if the output type is correct\n\n                bus_query_operation_1.ActorQueryOperation.validateQueryOutput(smallestPattern, 'bindings'); // Materialize the remaining patterns for each binding in the stream.\n\n                subContext = context && context.set(bus_query_operation_1.KEY_CONTEXT_BGP_PARENTMETADATA, remainingMetadatas);\n                bindingsStream = ActorQueryOperationBgpLeftDeepSmallest.createLeftDeepStream(smallestPattern.bindingsStream, remainingPatterns,\n                /*#__PURE__*/\n                function () {\n                  var _ref2 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee3(patterns) {\n                    var operation;\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            // Send the materialized patterns to the mediator for recursive BGP evaluation.\n                            operation = {\n                              type: 'bgp',\n                              patterns: patterns\n                            };\n                            _context3.t0 = bus_query_operation_1.ActorQueryOperation;\n                            _context3.next = 4;\n                            return _this.mediatorQueryOperation.mediate({\n                              operation: operation,\n                              context: subContext\n                            });\n\n                          case 4:\n                            _context3.t1 = _context3.sent;\n                            return _context3.abrupt(\"return\", _context3.t0.getSafeBindings.call(_context3.t0, _context3.t1).bindingsStream);\n\n                          case 6:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, this);\n                  }));\n\n                  return function (_x6) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }()); // Prepare variables and metadata\n\n                variables = ActorQueryOperationBgpLeftDeepSmallest.getCombinedVariables(patternOutputs);\n\n                metadata = function metadata() {\n                  return Promise.resolve({\n                    totalItems: ActorQueryOperationBgpLeftDeepSmallest.estimateCombinedTotalItems(metadatas[smallestId], metadatas.slice(smallestId))\n                  });\n                };\n\n                return _context4.abrupt(\"return\", {\n                  type: 'bindings',\n                  bindingsStream: bindingsStream,\n                  variables: variables,\n                  metadata: metadata\n                });\n\n              case 25:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function runOperation(_x3, _x4) {\n        return _runOperation.apply(this, arguments);\n      }\n\n      return runOperation;\n    }()\n  }], [{\n    key: \"createLeftDeepStream\",\n    value: function createLeftDeepStream(baseStream, patterns, patternBinder) {\n      var bindingsStream = new asynciterator_1.MultiTransformIterator(baseStream);\n\n      bindingsStream._createTransformer = function (bindings) {\n        var bindingsMerger = function bindingsMerger(subBindings) {\n          return subBindings.merge(bindings);\n        };\n\n        return new asynciterator_promiseproxy_1.PromiseProxyIterator(\n        /*#__PURE__*/\n        _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee5() {\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.next = 2;\n                  return patternBinder(ActorQueryOperationBgpLeftDeepSmallest.materializePatterns(patterns, bindings));\n\n                case 2:\n                  _context5.t0 = bindingsMerger;\n                  return _context5.abrupt(\"return\", _context5.sent.map(_context5.t0));\n\n                case 4:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        })), {\n          autoStart: true,\n          maxBufferSize: 128\n        });\n      };\n\n      return bindingsStream;\n    }\n    /**\n     * Get the combined list of variables of the given pattern outputs.\n     * @param {IActorQueryOperationOutput[]} patternOutputs An array of query operation outputs\n     * @return {string[]} The array of variable names.\n     */\n\n  }, {\n    key: \"getCombinedVariables\",\n    value: function getCombinedVariables(patternOutputs) {\n      return require('lodash.uniq')([].concat.apply([], patternOutputs.map(function (patternOutput) {\n        return patternOutput.variables;\n      })));\n    }\n    /**\n     * Find the pattern index with the smallest number of elements.\n     * @param {{[p: string]: any}[]} metadatas An array of optional metadata objects for the patterns.\n     * @return {number} The index of the pattern with the smallest number of elements.\n     */\n\n  }, {\n    key: \"getSmallestPatternId\",\n    value: function getSmallestPatternId(metadatas) {\n      var smallestId = -1;\n      var smallestCount = Infinity;\n\n      for (var i = 0; i < metadatas.length; i++) {\n        var meta = metadatas[i];\n        var count = ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(meta);\n\n        if (count <= smallestCount) {\n          smallestCount = count;\n          smallestId = i;\n        }\n      }\n\n      return smallestId;\n    }\n    /**\n     * Estimate an upper bound for the total number of items from the given metadata.\n     * @param {{[p: string]: any}} smallestPattern The optional metadata for the pattern\n     *                                             with the smallest number of elements.\n     * @param {{[p: string]: any}[]} otherPatterns The array of optional metadata for the other patterns.\n     * @return {number} The estimated number of total items.\n     */\n\n  }, {\n    key: \"estimateCombinedTotalItems\",\n    value: function estimateCombinedTotalItems(smallestPattern, otherPatterns) {\n      var smallestCount = ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(smallestPattern);\n      return otherPatterns.map(function (otherPattern) {\n        return smallestCount * ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(otherPattern);\n      }).reduce(function (sum, element) {\n        return sum + element;\n      }, 0);\n    }\n    /**\n     * Get the estimated number of items from the given metadata.\n     * @param {{[p: string]: any}} metadata An optional metadata object.\n     * @return {number} The estimated number of items, or `Infinity` if metadata is falsy.\n     */\n\n  }, {\n    key: \"getTotalItems\",\n    value: function getTotalItems(metadata) {\n      var totalItems = (metadata || {}).totalItems;\n      return totalItems || totalItems === 0 ? totalItems : Infinity;\n    }\n    /**\n     * Materialize all patterns in the given pattern array with the given bindings.\n     * @param {Pattern[]} patterns SPARQL algebra patterns.\n     * @param {Bindings} bindings A bindings object.\n     * @return {Pattern[]} A new array where each input pattern is materialized.\n     */\n\n  }, {\n    key: \"materializePatterns\",\n    value: function materializePatterns(patterns, bindings) {\n      return patterns.map(function (pattern) {\n        return ActorQueryOperationBgpLeftDeepSmallest.materializePattern(pattern, bindings);\n      });\n    }\n    /**\n     * Materialize a pattern with the given bindings.\n     * @param {Pattern} pattern A SPARQL algebra pattern.\n     * @param {Bindings} bindings A bindings object.\n     * @return {Pattern} A new materialized pattern.\n     */\n\n  }, {\n    key: \"materializePattern\",\n    value: function materializePattern(pattern, bindings) {\n      return Object.assign(rdf_terms_1.mapTerms(pattern, function (term) {\n        return ActorQueryOperationBgpLeftDeepSmallest.materializeTerm(term, bindings);\n      }), {\n        type: 'pattern'\n      });\n    }\n    /**\n     * Materialize a term with the given binding.\n     *\n     * If the given term is a variable (or blank node)\n     * and that variable exist in the given bindings object,\n     * the value of that binding is returned.\n     * In all other cases, the term itself is returned.\n     *\n     * @param {RDF.Term} term A term.\n     * @param {Bindings} bindings A bindings object.\n     * @return {RDF.Term} The materialized term.\n     */\n\n  }, {\n    key: \"materializeTerm\",\n    value: function materializeTerm(term, bindings) {\n      if (term.termType === 'Variable') {\n        var value = bindings.get(rdf_string_1.termToString(term));\n\n        if (value) {\n          return value;\n        }\n      }\n\n      return term;\n    }\n    /**\n     * Check if at least one of the given outputs has an empty output, i.e., when the estimated count is zero.\n     * @param {IActorQueryOperationOutputBindings[]} patternOutputs Pattern outputs.\n     * @return {Promise<boolean>} A promise for indicating whether or not at least one of the outputs is empty.\n     */\n\n  }, {\n    key: \"hasOneEmptyPatternOutput\",\n    value: function () {\n      var _hasOneEmptyPatternOutput = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(patternOutputs) {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, patternOutput, metadata;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context6.prev = 3;\n                _iterator = patternOutputs[Symbol.iterator]();\n\n              case 5:\n                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                  _context6.next = 16;\n                  break;\n                }\n\n                patternOutput = _step.value;\n\n                if (!patternOutput.metadata) {\n                  _context6.next = 13;\n                  break;\n                }\n\n                _context6.next = 10;\n                return patternOutput.metadata();\n\n              case 10:\n                metadata = _context6.sent;\n\n                if (ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(metadata)) {\n                  _context6.next = 13;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", true);\n\n              case 13:\n                _iteratorNormalCompletion = true;\n                _context6.next = 5;\n                break;\n\n              case 16:\n                _context6.next = 22;\n                break;\n\n              case 18:\n                _context6.prev = 18;\n                _context6.t0 = _context6[\"catch\"](3);\n                _didIteratorError = true;\n                _iteratorError = _context6.t0;\n\n              case 22:\n                _context6.prev = 22;\n                _context6.prev = 23;\n\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n\n              case 25:\n                _context6.prev = 25;\n\n                if (!_didIteratorError) {\n                  _context6.next = 28;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 28:\n                return _context6.finish(25);\n\n              case 29:\n                return _context6.finish(22);\n\n              case 30:\n                return _context6.abrupt(\"return\", false);\n\n              case 31:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[3, 18, 22, 30], [23,, 25, 29]]);\n      }));\n\n      function hasOneEmptyPatternOutput(_x7) {\n        return _hasOneEmptyPatternOutput.apply(this, arguments);\n      }\n\n      return hasOneEmptyPatternOutput;\n    }()\n  }]);\n\n  return ActorQueryOperationBgpLeftDeepSmallest;\n}(bus_query_operation_1.ActorQueryOperationTypedMediated);\n\nexports.ActorQueryOperationBgpLeftDeepSmallest = ActorQueryOperationBgpLeftDeepSmallest;","map":null,"metadata":{},"sourceType":"script"}