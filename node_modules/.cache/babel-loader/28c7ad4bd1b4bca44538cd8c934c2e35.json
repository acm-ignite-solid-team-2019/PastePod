{"ast":null,"code":"\"use strict\";\n\nvar _toArray = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n/**\n * Expresses a path or mutation as a SPARQL query.\n *\n * Requires:\n * - a mutationExpressions or pathExpression property on the path proxy\n */\n\nvar SparqlHandler =\n/*#__PURE__*/\nfunction () {\n  function SparqlHandler() {\n    _classCallCheck(this, SparqlHandler);\n  }\n\n  _createClass(SparqlHandler, [{\n    key: \"handle\",\n    value: function () {\n      var _handle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(pathData, path) {\n        var _this = this;\n\n        var mutationExpressions, pathExpression;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return path.mutationExpressions;\n\n              case 2:\n                mutationExpressions = _context.sent;\n\n                if (!(Array.isArray(mutationExpressions) && mutationExpressions.length)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", mutationExpressions.map(function (e) {\n                  return _this.mutationExpressionToQuery(e);\n                }).join('\\n;\\n'));\n\n              case 5:\n                _context.next = 7;\n                return path.pathExpression;\n\n              case 7:\n                pathExpression = _context.sent;\n\n                if (Array.isArray(pathExpression)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new Error(\"\".concat(pathData, \" has no pathExpression property\"));\n\n              case 10:\n                return _context.abrupt(\"return\", this.pathExpressionToQuery(pathData, path, pathExpression));\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handle(_x, _x2) {\n        return _handle.apply(this, arguments);\n      }\n\n      return handle;\n    }()\n  }, {\n    key: \"pathExpressionToQuery\",\n    value: function pathExpressionToQuery(pathData, path, pathExpression) {\n      if (pathExpression.length < 2) throw new Error(\"\".concat(pathData, \" should at least contain a subject and a predicate\")); // Embed the basic graph pattern into a SPARQL query\n\n      var queryVar = this.createVar(pathData.property);\n      var clauses = this.expressionToTriplePatterns(pathExpression, queryVar);\n      return \"SELECT \".concat(queryVar, \" WHERE {\\n  \").concat(clauses.join('\\n  '), \"\\n}\");\n    }\n  }, {\n    key: \"mutationExpressionToQuery\",\n    value: function mutationExpressionToQuery(_ref) {\n      var _this2 = this;\n\n      var mutationType = _ref.mutationType,\n          conditions = _ref.conditions,\n          predicate = _ref.predicate,\n          objects = _ref.objects;\n      // If the only condition is a subject, we need no WHERE clause\n      var scope = {};\n      var subject, where;\n\n      if (conditions.length === 1) {\n        subject = this.termToString(conditions[0].subject);\n        where = [];\n      } // Otherwise, create a WHERE clause from all conditions\n      else {\n          var lastPredicate = conditions[conditions.length - 1].predicate;\n          subject = this.createVar(lastPredicate.value, scope);\n          where = this.expressionToTriplePatterns(conditions, subject, scope);\n        } // If a list of objects was specified, the mutation is \"<s> <p> objects\"\n\n\n      var objectList = objects && objects.map(function (o) {\n        return _this2.termToString(o);\n      }).join(', ');\n      var mutationPattern = objectList ? \"\".concat(subject, \" \").concat(this.termToString(predicate), \" \").concat(objectList, \".\") : // Otherwise, the mutation is the unconstrained last segment\n      where[where.length - 1];\n      return where.length === 0 ? // If there are no WHERE clauses, just mutate raw data\n      \"\".concat(mutationType, \" DATA {\\n  \").concat(mutationPattern, \"\\n}\") : // Otherwise, return a DELETE/INSERT ... WHERE ... query\n      \"\".concat(mutationType, \" {\\n  \").concat(mutationPattern, \"\\n} WHERE {\\n  \").concat(where.join('\\n  '), \"\\n}\");\n    }\n  }, {\n    key: \"expressionToTriplePatterns\",\n    value: function expressionToTriplePatterns(_ref2, queryVar) {\n      var _this3 = this;\n\n      var _ref3 = _toArray(_ref2),\n          root = _ref3[0],\n          pathExpression = _ref3.slice(1);\n\n      var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var last = pathExpression.length - 1;\n      var object = this.termToString(root.subject);\n      return pathExpression.map(function (segment, index) {\n        // Obtain components and generate triple pattern\n        var subject = object;\n        var predicate = segment.predicate;\n        object = index < last ? _this3.createVar(\"v\".concat(index), scope) : queryVar;\n        return \"\".concat(subject, \" \").concat(_this3.termToString(predicate), \" \").concat(object, \".\");\n      });\n    } // Creates a unique query variable within the given scope, based on the suggestion\n\n  }, {\n    key: \"createVar\",\n    value: function createVar(suggestion, scope) {\n      var counter = 0;\n      var label = \"?\".concat(suggestion.match(/[a-z0-9]*$/i)[0] || 'result');\n\n      if (scope) {\n        while (scope[label]) {\n          label = \"?\".concat(suggestion, \"_\").concat(counter++);\n        }\n\n        scope[label] = true;\n      }\n\n      return label;\n    } // Converts an RDFJS term to a string that we can use in a query\n\n  }, {\n    key: \"termToString\",\n    value: function termToString(term) {\n      switch (term.termType) {\n        case 'NamedNode':\n          return \"<\".concat(term.value, \">\");\n\n        case 'BlankNode':\n          return \"_:\".concat(term.value);\n\n        case 'Literal':\n          return \"\\\"\".concat(term.value.replace(/\"/g, '\\\\\"'), \"\\\"\");\n\n        default:\n          throw new Error(\"Could not convert a term of type \".concat(term.termType));\n      }\n    }\n  }]);\n\n  return SparqlHandler;\n}();\n\nexports.default = SparqlHandler;","map":null,"metadata":{},"sourceType":"script"}