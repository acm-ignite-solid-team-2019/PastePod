{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar DefaultEngine = require('../lib/comunica-engine');\n/**\n * Asynchronous iterator wrapper for the Comunica SPARQL query engine.\n */\n\n\nvar ComunicaEngine =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a ComunicaEngine to query the given subject.\n   *\n   * The source can be a single URL, an RDF/JS Datasource,\n   * or an array with any of these.\n   * If undefined, it defaults to dereferencing the subject.\n   */\n  function ComunicaEngine(subject, source) {\n    _classCallCheck(this, ComunicaEngine);\n\n    this._subject = subject;\n    this._source = source;\n    this._engine = DefaultEngine;\n  }\n  /**\n   * Creates an asynchronous iterable\n   * of results for the given SPARQL query.\n   */\n\n\n  _createClass(ComunicaEngine, [{\n    key: \"execute\",\n    value: function execute(sparql) {\n      var _this = this;\n\n      // Comunica does not support SPARQL UPDATE queries yet,\n      // so we temporarily throw an error for them.\n      if (sparql.startsWith('INSERT') || sparql.startsWith('DELETE')) return this.executeUpdate(sparql); // Create an iterator function that reads the next binding\n\n      var bindings;\n\n      var next =\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee() {\n          var source, sources, queryResult;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (bindings) {\n                    _context.next = 24;\n                    break;\n                  }\n\n                  _context.next = 3;\n                  return _this._source;\n\n                case 3:\n                  _context.t0 = _context.sent;\n\n                  if (_context.t0) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  _context.t1 = _this;\n                  _context.next = 8;\n                  return _this._subject;\n\n                case 8:\n                  _context.t2 = _context.sent;\n                  _context.t0 = _context.t1.getDocument.call(_context.t1, _context.t2);\n\n                case 10:\n                  source = _context.t0;\n\n                  if (!Array.isArray(source)) {\n                    _context.next = 17;\n                    break;\n                  }\n\n                  _context.next = 14;\n                  return Promise.all(source);\n\n                case 14:\n                  _context.t3 = _context.sent;\n                  _context.next = 18;\n                  break;\n\n                case 17:\n                  _context.t3 = [source];\n\n                case 18:\n                  _context.t4 = function (value) {\n                    return {\n                      type: typeof value === 'string' ? 'file' : 'rdfjsSource',\n                      value: value\n                    };\n                  };\n\n                  sources = _context.t3.map(_context.t4);\n                  _context.next = 22;\n                  return _this._engine.query(sparql, {\n                    sources: sources\n                  });\n\n                case 22:\n                  queryResult = _context.sent;\n                  bindings = queryResult.bindingsStream;\n\n                case 24:\n                  return _context.abrupt(\"return\", new Promise(readNextBinding));\n\n                case 25:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        return function next() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      return _defineProperty({\n        next: next\n      }, Symbol.asyncIterator, function () {\n        return this;\n      }); // Reads the next binding\n\n      function readNextBinding(resolve) {\n        var done = function done() {\n          return resolve({\n            done: true\n          });\n        }; // Mark the iterator as done when the source has ended\n\n\n        if (bindings.ended) {\n          done();\n        } else {\n          // Wait for either the data or the end event\n          bindings.once('data', function (data) {\n            resolve({\n              value: data\n            });\n            bindings.removeListener('end', done);\n          });\n          bindings.on('end', done);\n        }\n      }\n    }\n    /**\n     * Throws an error for update queries.\n     */\n\n  }, {\n    key: \"executeUpdate\",\n    value: function executeUpdate(sparql) {\n      throw new Error(\"Comunica does not support SPARQL UPDATE queries, received: \".concat(sparql));\n    }\n  }, {\n    key: \"getDocument\",\n    value: function getDocument(subject) {\n      return subject.value.replace(/#.*/, '');\n    }\n  }]);\n\n  return ComunicaEngine;\n}();\n\nexports.default = ComunicaEngine;","map":null,"metadata":{},"sourceType":"script"}