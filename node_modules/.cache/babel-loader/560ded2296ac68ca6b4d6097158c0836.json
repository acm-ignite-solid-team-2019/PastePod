{"ast":null,"code":"var Transform = require('stream').Transform;\n\nvar util = require('util');\n\nvar sax = require('sax');\n\nvar elem = require('./elem');\n\nvar debug = require('debug')('sax-stream');\n\nmodule.exports = XmlNode;\n\nfunction XmlNode(options) {\n  if (!(this instanceof XmlNode)) {\n    return new XmlNode(options);\n  }\n\n  Transform.call(this, {\n    highWaterMark: options.highWaterMark || 350,\n    objectMode: true\n  });\n  this.records = [];\n  this.error = null;\n  this.parser = this.createSaxParser(options);\n}\n\nutil.inherits(XmlNode, Transform);\n\nXmlNode.prototype.createSaxParser = function (options) {\n  function matchSingle(name) {\n    return name === options.tag;\n  }\n\n  function matchAny(name) {\n    return options.tag.indexOf(name) !== -1;\n  }\n\n  function pushBare(tag, record) {\n    self.records.push(record);\n  }\n\n  function pushWithTag(tag, record) {\n    self.records.push({\n      tag: tag,\n      record: record\n    });\n  }\n\n  var self = this,\n      record,\n      parser = sax.parser(options.strict || false, prepareParserOptions(options));\n  var matchesTag = matchSingle,\n      push = pushBare;\n\n  if (Array.isArray(options.tag)) {\n    matchesTag = matchAny;\n    push = pushWithTag;\n  }\n\n  parser.onopentag = function (node) {\n    debug('Open \"%s\"', node.name);\n\n    if (record) {\n      record = elem.addChild(record, node.name);\n    } else if (matchesTag(node.name)) {\n      record = {};\n    }\n\n    if (record && Object.keys(node.attributes).length) {\n      record.attribs = node.attributes;\n    }\n  };\n\n  parser.onclosetag = function (tag) {\n    debug('Closed \"%s\"', tag);\n\n    if (matchesTag(tag) && !record.parent) {\n      debug('Emitting record', record);\n      push(tag, record);\n      record = undefined;\n    } else if (record) {\n      record = record.parent;\n    }\n  };\n\n  parser.ontext = function (value) {\n    if (record) {\n      elem.addText(record, value);\n    }\n  };\n\n  parser.oncdata = function (value) {\n    if (record) {\n      elem.concatText(record, value);\n    }\n  };\n\n  parser.onerror = function (err) {\n    self.error = err;\n  };\n\n  parser.onend = function () {\n    debug('onend - flushing remaining items');\n    self.pushAll(self.callback);\n    self.callback = null;\n  };\n\n  return parser;\n};\n\nXmlNode.prototype.pushAll = function (callback) {\n  if (this.error) {\n    callback(this.error);\n    this.error = null;\n    return;\n  }\n\n  debug('pushing %d', this.records.length);\n  this.records.forEach(this.push.bind(this));\n  this.records.length = 0;\n  callback();\n};\n\nXmlNode.prototype._transform = function (chunk, encoding, callback) {\n  this.parser.write(chunk.toString());\n  this.pushAll(callback);\n};\n\nXmlNode.prototype._flush = function (callback) {\n  var self = this;\n  self.callback = callback;\n  self.parser.close();\n};\n\nfunction prepareParserOptions(options) {\n  return ['trim', 'normalize', 'lowercase', 'xmlns', 'position', 'strictEntities', 'noscript'].reduce(function (opts, name) {\n    if (name in options) {\n      opts[name] = options[name];\n    }\n\n    return opts;\n  }, {\n    position: false\n  });\n}","map":null,"metadata":{},"sourceType":"script"}