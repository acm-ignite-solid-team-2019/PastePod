{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar immutable_1 = require(\"immutable\");\n\nvar Logger_1 = require(\"./Logger\");\n/**\n * An actor can act on messages of certain types and provide output of a certain type.\n *\n * The flow of an actor is as follows:\n * 1. Send a message to {@link Actor#test} to test if an actor can run that action.\n * 2. If the actor can reply to the message, let the actor run the action using {@link Actor#run}.\n *\n * An actor is typically subscribed to a bus,\n * using which the applicability to an action can be tested.\n *\n * @see Bus\n *\n * @template I The input type of an actor.\n * @template T The test type of an actor.\n * @template O The output type of an actor.\n */\n\n\nvar Actor =\n/*#__PURE__*/\nfunction () {\n  /**\n   * All enumerable properties from the `args` object are inherited to this actor.\n   *\n   * The actor will subscribe to the given bus when this constructor is called.\n   *\n   * @param {IActorArgs<I extends IAction, T extends IActorTest, O extends IActorOutput>} args Arguments object\n   * @param {string} args.name The name for this actor.\n   * @param {Bus<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>} args.bus\n   *        The bus this actor subscribes to.\n   * @throws When required arguments are missing.\n   */\n  function Actor(args) {\n    _classCallCheck(this, Actor);\n\n    require('lodash.assign')(this, args);\n\n    this.bus.subscribe(this);\n  }\n  /**\n   * Get the logger from the given context.\n   * @param {ActionContext} context An optional context.\n   * @return {Logger} The logger or null.\n   */\n\n\n  _createClass(Actor, [{\n    key: \"runObservable\",\n\n    /**\n     * Run the given action on this actor\n     * AND invokes the {@link Bus#onRun} method.\n     *\n     * @param {I} action The action to run.\n     * @return {Promise<T>} A promise that resolves to the run result.\n     */\n    value: function runObservable(action) {\n      var output = this.run(action);\n      this.bus.onRun(this, action, output);\n      return output;\n    }\n    /**\n     * Initialize this actor.\n     * This should be used for doing things that take a while,\n     * such as opening files.\n     *\n     * @return {Promise<void>} A promise that resolves when the actor has been initialized.\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", true);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n\n      return initialize;\n    }()\n    /**\n     * Deinitialize this actor.\n     * This should be used for cleaning up things when the application is shut down,\n     * such as closing files and removing temporary files.\n     *\n     * @return {Promise<void>} A promise that resolves when the actor has been deinitialized.\n     */\n\n  }, {\n    key: \"deinitialize\",\n    value: function () {\n      var _deinitialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", true);\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function deinitialize() {\n        return _deinitialize.apply(this, arguments);\n      }\n\n      return deinitialize;\n    }()\n    /* Proxy methods for the (optional) logger that is defined in the context */\n\n  }, {\n    key: \"getDefaultLogData\",\n    value: function getDefaultLogData(context, data) {\n      if (!data) {\n        data = {};\n      }\n\n      data.actor = this.name;\n      return data;\n    }\n  }, {\n    key: \"logTrace\",\n    value: function logTrace(context, message, data) {\n      var logger = Actor.getContextLogger(context);\n\n      if (logger) {\n        logger.trace(message, this.getDefaultLogData(context, data));\n      }\n    }\n  }, {\n    key: \"logDebug\",\n    value: function logDebug(context, message, data) {\n      var logger = Actor.getContextLogger(context);\n\n      if (logger) {\n        logger.debug(message, this.getDefaultLogData(context, data));\n      }\n    }\n  }, {\n    key: \"logInfo\",\n    value: function logInfo(context, message, data) {\n      var logger = Actor.getContextLogger(context);\n\n      if (logger) {\n        logger.info(message, this.getDefaultLogData(context, data));\n      }\n    }\n  }, {\n    key: \"logWarn\",\n    value: function logWarn(context, message, data) {\n      var logger = Actor.getContextLogger(context);\n\n      if (logger) {\n        logger.warn(message, this.getDefaultLogData(context, data));\n      }\n    }\n  }, {\n    key: \"logError\",\n    value: function logError(context, message, data) {\n      var logger = Actor.getContextLogger(context);\n\n      if (logger) {\n        logger.error(message, this.getDefaultLogData(context, data));\n      }\n    }\n  }, {\n    key: \"logFatal\",\n    value: function logFatal(context, message, data) {\n      var logger = Actor.getContextLogger(context);\n\n      if (logger) {\n        logger.fatal(message, this.getDefaultLogData(context, data));\n      }\n    }\n  }], [{\n    key: \"getContextLogger\",\n    value: function getContextLogger(context) {\n      return context ? context.get(Logger_1.KEY_CONTEXT_LOG) : null;\n    }\n  }]);\n\n  return Actor;\n}();\n\nexports.Actor = Actor;\n/**\n * A convenience constructor for {@link ActionContext} based on a given hash.\n * @param {{[p: string]: any}} hash A hash that maps keys to values.\n * @return {ActionContext} The immutable action context from the hash.\n * @constructor\n */\n\nfunction ActionContext(hash) {\n  return immutable_1.Map(hash);\n}\n\nexports.ActionContext = ActionContext;","map":null,"metadata":{},"sourceType":"script"}