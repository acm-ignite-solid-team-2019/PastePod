{"ast":null,"code":"\"use strict\";\n\nvar _get = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar RDFDM = require(\"@rdfjs/data-model\");\n\nvar Expressions_1 = require(\"./Expressions\");\n\nvar C = require(\"../util/Consts\");\n\nvar Err = require(\"../util/Errors\");\n\nvar Term =\n/*#__PURE__*/\nfunction () {\n  function Term() {\n    _classCallCheck(this, Term);\n\n    this.expressionType = Expressions_1.ExpressionType.Term;\n  }\n\n  _createClass(Term, [{\n    key: \"str\",\n    value: function str() {\n      throw new Err.InvalidArgumentTypes([this], C.RegularOperator.STR);\n    }\n  }, {\n    key: \"coerceEBV\",\n    value: function coerceEBV() {\n      throw new Err.EBVCoercionError(this);\n    }\n  }]);\n\n  return Term;\n}();\n\nexports.Term = Term; // NamedNodes -----------------------------------------------------------------\n\nvar NamedNode =\n/*#__PURE__*/\nfunction (_Term) {\n  _inherits(NamedNode, _Term);\n\n  function NamedNode(value) {\n    var _this;\n\n    _classCallCheck(this, NamedNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NamedNode).call(this));\n    _this.value = value;\n    _this.termType = 'namedNode';\n    return _this;\n  }\n\n  _createClass(NamedNode, [{\n    key: \"toRDF\",\n    value: function toRDF() {\n      return RDFDM.namedNode(this.value);\n    }\n  }, {\n    key: \"str\",\n    value: function str() {\n      return this.value;\n    }\n  }]);\n\n  return NamedNode;\n}(Term);\n\nexports.NamedNode = NamedNode; // BlankNodes -----------------------------------------------------------------\n\nvar BlankNode =\n/*#__PURE__*/\nfunction (_Term2) {\n  _inherits(BlankNode, _Term2);\n\n  function BlankNode(value) {\n    var _this2;\n\n    _classCallCheck(this, BlankNode);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(BlankNode).call(this));\n    _this2.value = value;\n    _this2.termType = 'blankNode';\n    _this2.value = value;\n    return _this2;\n  }\n\n  _createClass(BlankNode, [{\n    key: \"toRDF\",\n    value: function toRDF() {\n      return RDFDM.blankNode(this.value);\n    }\n  }], [{\n    key: \"nextID\",\n    value: function nextID() {\n      BlankNode._nextID += 1;\n      return BlankNode.nextID.toString();\n    }\n  }]);\n\n  return BlankNode;\n}(Term);\n\nBlankNode._nextID = 0;\nexports.BlankNode = BlankNode;\n\nvar Literal =\n/*#__PURE__*/\nfunction (_Term3) {\n  _inherits(Literal, _Term3);\n\n  function Literal(typedValue, typeURL, strValue, language) {\n    var _this3;\n\n    _classCallCheck(this, Literal);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Literal).call(this));\n    _this3.typedValue = typedValue;\n    _this3.typeURL = typeURL;\n    _this3.strValue = strValue;\n    _this3.language = language;\n    _this3.termType = 'literal';\n    _this3.type = C.type(typeURL.value);\n    return _this3;\n  }\n\n  _createClass(Literal, [{\n    key: \"toRDF\",\n    value: function toRDF() {\n      return RDFDM.literal(this.strValue || this.typedValue.toString(), this.language || this.typeURL);\n    }\n  }, {\n    key: \"str\",\n    value: function str() {\n      return this.strValue || this.typedValue.toString();\n    }\n  }]);\n\n  return Literal;\n}(Term);\n\nexports.Literal = Literal;\n\nvar NumericLiteral =\n/*#__PURE__*/\nfunction (_Literal) {\n  _inherits(NumericLiteral, _Literal);\n\n  function NumericLiteral() {\n    _classCallCheck(this, NumericLiteral);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NumericLiteral).apply(this, arguments));\n  }\n\n  _createClass(NumericLiteral, [{\n    key: \"coerceEBV\",\n    value: function coerceEBV() {\n      return !!this.typedValue;\n    }\n  }, {\n    key: \"toRDF\",\n    value: function toRDF() {\n      var term = _get(_getPrototypeOf(NumericLiteral.prototype), \"toRDF\", this).call(this);\n\n      if (!isFinite(this.typedValue)) {\n        term.value = term.value.replace('Infinity', 'INF');\n      }\n\n      return term;\n    }\n  }]);\n\n  return NumericLiteral;\n}(Literal);\n\nexports.NumericLiteral = NumericLiteral;\n\nvar BooleanLiteral =\n/*#__PURE__*/\nfunction (_Literal2) {\n  _inherits(BooleanLiteral, _Literal2);\n\n  function BooleanLiteral(typedValue, strValue) {\n    var _this4;\n\n    _classCallCheck(this, BooleanLiteral);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(BooleanLiteral).call(this, typedValue, C.make(C.TypeURL.XSD_BOOLEAN), strValue));\n    _this4.typedValue = typedValue;\n    _this4.strValue = strValue;\n    return _this4;\n  }\n\n  _createClass(BooleanLiteral, [{\n    key: \"coerceEBV\",\n    value: function coerceEBV() {\n      return !!this.typedValue;\n    }\n  }]);\n\n  return BooleanLiteral;\n}(Literal);\n\nexports.BooleanLiteral = BooleanLiteral;\n\nvar DateTimeLiteral =\n/*#__PURE__*/\nfunction (_Literal3) {\n  _inherits(DateTimeLiteral, _Literal3);\n\n  // strValue is mandatory here because toISOString will always add\n  // milliseconds, even if they were not present.\n  function DateTimeLiteral(typedValue, strValue) {\n    var _this5;\n\n    _classCallCheck(this, DateTimeLiteral);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(DateTimeLiteral).call(this, typedValue, C.make(C.TypeURL.XSD_DATE_TIME), strValue));\n    _this5.typedValue = typedValue;\n    _this5.strValue = strValue;\n    return _this5;\n  }\n\n  return DateTimeLiteral;\n}(Literal);\n\nexports.DateTimeLiteral = DateTimeLiteral;\n\nvar LangStringLiteral =\n/*#__PURE__*/\nfunction (_Literal4) {\n  _inherits(LangStringLiteral, _Literal4);\n\n  function LangStringLiteral(typedValue, language) {\n    var _this6;\n\n    _classCallCheck(this, LangStringLiteral);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(LangStringLiteral).call(this, typedValue, C.make(C.TypeURL.RDF_LANG_STRING), typedValue, language));\n    _this6.typedValue = typedValue;\n    _this6.language = language;\n    return _this6;\n  }\n\n  _createClass(LangStringLiteral, [{\n    key: \"coerceEBV\",\n    value: function coerceEBV() {\n      return this.strValue.length !== 0;\n    }\n  }]);\n\n  return LangStringLiteral;\n}(Literal);\n\nexports.LangStringLiteral = LangStringLiteral; // https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal\n// https://www.w3.org/TR/sparql11-query/#defn_SimpleLiteral\n// https://www.w3.org/TR/sparql11-query/#func-strings\n// This does not include language tagged literals\n\nvar StringLiteral =\n/*#__PURE__*/\nfunction (_Literal5) {\n  _inherits(StringLiteral, _Literal5);\n\n  function StringLiteral(typedValue) {\n    var _this7;\n\n    _classCallCheck(this, StringLiteral);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(StringLiteral).call(this, typedValue, C.make(C.TypeURL.XSD_STRING), typedValue));\n    _this7.typedValue = typedValue;\n    return _this7;\n  }\n\n  _createClass(StringLiteral, [{\n    key: \"coerceEBV\",\n    value: function coerceEBV() {\n      return this.strValue.length !== 0;\n    }\n  }]);\n\n  return StringLiteral;\n}(Literal);\n\nexports.StringLiteral = StringLiteral;\n/*\n * This class is used when a literal is parsed, and it's value is\n * an invalid lexical form for it's datatype. The spec defines value with\n * invalid lexical form are still valid terms, and as such we can not error\n * immediately. This class makes sure that the typedValue will remain undefined,\n * and the category 'nonlexical'. This way, only when operators apply to the\n * 'nonlexical' category, they will keep working, otherwise they will throw a\n * type error.\n * This seems to match the spec, except maybe for functions that accept\n * non-lexical values for their datatype.\n *\n * See:\n *  - https://www.w3.org/TR/xquery/#dt-type-error\n *  - https://www.w3.org/TR/rdf-concepts/#section-Literal-Value\n *  - https://www.w3.org/TR/xquery/#dt-ebv\n *  - ... some other more precise thing i can't find...\n */\n\nvar NonLexicalLiteral =\n/*#__PURE__*/\nfunction (_Literal6) {\n  _inherits(NonLexicalLiteral, _Literal6);\n\n  function NonLexicalLiteral(typedValue, typeURL, strValue, language) {\n    var _this8;\n\n    _classCallCheck(this, NonLexicalLiteral);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(NonLexicalLiteral).call(this, typedValue, typeURL, strValue, language));\n    _this8.typedValue = undefined;\n    _this8.type = 'nonlexical';\n    _this8.shouldBeCategory = C.type(typeURL.value);\n    return _this8;\n  }\n\n  _createClass(NonLexicalLiteral, [{\n    key: \"coerceEBV\",\n    value: function coerceEBV() {\n      var isNumericOrBool = C.NumericTypeCategories.contains(this.shouldBeCategory) || this.shouldBeCategory === 'boolean';\n\n      if (isNumericOrBool) {\n        return false;\n      }\n\n      throw new Err.EBVCoercionError(this);\n    }\n  }]);\n\n  return NonLexicalLiteral;\n}(Literal);\n\nexports.NonLexicalLiteral = NonLexicalLiteral;","map":null,"metadata":{},"sourceType":"script"}