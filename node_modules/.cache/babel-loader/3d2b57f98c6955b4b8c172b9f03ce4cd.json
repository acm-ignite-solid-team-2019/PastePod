{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DefaultDataFactory = require(\"@rdfjs/data-model\");\n\nvar graphql_1 = require(\"graphql\");\n\nvar sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * Translate GraphQL queries into SPARQL algebra.\n */\n\n\nvar Converter =\n/*#__PURE__*/\nfunction () {\n  function Converter(settings) {\n    _classCallCheck(this, Converter);\n\n    this.expressionVariableCounter = 0;\n    settings = settings || {};\n    this.dataFactory = settings.dataFactory || DefaultDataFactory;\n    this.operationFactory = new sparqlalgebrajs_1.Factory(this.dataFactory);\n    this.arraysToRdfLists = settings.arraysToRdfLists;\n    this.variableDelimiter = settings.variableDelimiter || '_';\n    this.requireContext = settings.requireContext;\n  }\n  /**\n   * Translates a GraphQL query into SPARQL algebra.\n   * @param {string} graphqlQuery A GraphQL query string.\n   * @param {IContext} context A JSON-LD context.\n   * @param {IVariablesDictionary} variablesDict A variables dictionary.\n   * @return {Operation}\n   */\n\n\n  _createClass(Converter, [{\n    key: \"graphqlToSparqlAlgebra\",\n    value: function graphqlToSparqlAlgebra(graphqlQuery, context, variablesDict) {\n      var _this = this;\n\n      var document = graphql_1.parse(graphqlQuery);\n      var queryParseContext = {\n        context: context,\n        fragmentDefinitions: this.indexFragments(document),\n        path: [],\n        terminalVariables: [],\n        variablesDict: variablesDict || {},\n        variablesMetaDict: {}\n      };\n      var operation = this.operationFactory.createProject(document.definitions.map(this.definitionToPattern.bind(this, queryParseContext)).reduce(function (prev, current) {\n        if (!current) {\n          return prev;\n        }\n\n        if (!prev) {\n          return current;\n        }\n\n        return _this.operationFactory.createUnion(prev, current);\n      }, null), queryParseContext.terminalVariables); // Convert blank nodes to variables\n\n      return this.translateBlankNodesToVariables(operation);\n    }\n    /**\n     * Create an index of all fragment definitions in the given document.\n     *\n     * This will assign a new array of definition nodes without fragment definition.\n     *\n     * @param {DocumentNode} document A document node.\n     * @return {{[p: string]: FragmentDefinitionNode}} An index of fragment definition nodes.\n     */\n\n  }, {\n    key: \"indexFragments\",\n    value: function indexFragments(document) {\n      var fragmentDefinitions = {};\n      var newDefinitions = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = document.definitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var definition = _step.value;\n\n          if (definition.kind === 'FragmentDefinition') {\n            fragmentDefinitions[definition.name.value] = definition;\n          } else {\n            newDefinitions.push(definition);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      document.definitions = newDefinitions;\n      return fragmentDefinitions;\n    }\n    /**\n     * Convert a GraphQL definition node into an algebra operation.\n     * @param {IConvertContext} convertContext A convert context.\n     * @param {DefinitionNode} definition A GraphQL definition node.\n     * @return {Operation} A SPARQL algebra operation.\n     */\n\n  }, {\n    key: \"definitionToPattern\",\n    value: function definitionToPattern(convertContext, definition) {\n      switch (definition.kind) {\n        case 'OperationDefinition':\n          var operationDefinition = definition;\n\n          if (operationDefinition.operation !== 'query') {\n            throw new Error('Unsupported definition operation: ' + operationDefinition.operation);\n          } // We ignore the query name, as SPARQL doesn't support naming queries.\n\n\n          var subject = this.dataFactory.blankNode(); // Variables\n\n          if (operationDefinition.variableDefinitions) {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = operationDefinition.variableDefinitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var variableDefinition = _step2.value;\n                var name = variableDefinition.variable.name.value; // Put the default value in the context if it hasn't been defined yet.\n\n                if (variableDefinition.defaultValue) {\n                  if (!convertContext.variablesDict[name]) {\n                    convertContext.variablesDict[name] = variableDefinition.defaultValue;\n                  }\n                } // Handle type\n\n\n                var typeNode = variableDefinition.type;\n                var mandatory = typeNode.kind === 'NonNullType';\n\n                if (mandatory) {\n                  typeNode = typeNode.type;\n                }\n\n                var list = typeNode.kind === 'ListType';\n\n                if (list) {\n                  typeNode = typeNode.type;\n                }\n\n                var type = typeNode.name.value;\n                convertContext.variablesMetaDict[name] = {\n                  mandatory: mandatory,\n                  list: list,\n                  type: type\n                };\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          } // Directives\n\n\n          if (operationDefinition.directives) {\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n              for (var _iterator3 = operationDefinition.directives[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var directive = _step3.value;\n\n                if (!this.handleDirective(directive, convertContext)) {\n                  return null;\n                }\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                  _iterator3.return();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n          }\n\n          return this.joinOperations(operationDefinition.selectionSet.selections.map(this.selectionToPatterns.bind(this, convertContext, subject)));\n\n        case 'FragmentDefinition':\n          throw new Error('Illegal state: fragment definitions must be indexed and removed before processing');\n\n        default:\n          throw new Error('Unsupported definition node: ' + definition.kind);\n      }\n    }\n    /**\n     * Convert a GraphQL selection node into an algebra operation.\n     * @param {IConvertContext} convertContext A convert context.\n     * @param {Term} subject The RDF term that should be used as subject.\n     * @param {SelectionNode} selectionNode A GraphQL selection node.\n     * @return {Pattern[]} An array of quad patterns.\n     */\n\n  }, {\n    key: \"selectionToPatterns\",\n    value: function selectionToPatterns(convertContext, subject, selectionNode) {\n      switch (selectionNode.kind) {\n        case 'FragmentSpread':\n          var fragmentSpreadNode = selectionNode;\n          var fragmentDefinitionNode = convertContext.fragmentDefinitions[fragmentSpreadNode.name.value];\n\n          if (!fragmentDefinitionNode) {\n            throw new Error('Undefined fragment definition: ' + fragmentSpreadNode.name.value);\n          } // Wrap in an OPTIONAL, as this pattern should only apply if the type applies\n\n\n          return this.operationFactory.createLeftJoin(this.operationFactory.createBgp([]), this.fieldToOperation(convertContext, subject, {\n            alias: null,\n            arguments: null,\n            directives: fragmentDefinitionNode.directives,\n            kind: 'Field',\n            name: fragmentSpreadNode.name,\n            selectionSet: fragmentDefinitionNode.selectionSet\n          }, false, [this.newTypePattern(subject, fragmentDefinitionNode.typeCondition, convertContext)]));\n\n        case 'InlineFragment':\n          var inlineFragmentNode = selectionNode; // Wrap in an OPTIONAL, as this pattern should only apply if the type applies\n\n          return this.operationFactory.createLeftJoin(this.operationFactory.createBgp([]), this.fieldToOperation(convertContext, subject, {\n            alias: null,\n            arguments: null,\n            directives: inlineFragmentNode.directives,\n            kind: 'Field',\n            name: {\n              kind: 'Name',\n              value: subject.value\n            },\n            selectionSet: inlineFragmentNode.selectionSet\n          }, false, inlineFragmentNode.typeCondition ? [this.newTypePattern(subject, inlineFragmentNode.typeCondition, convertContext)] : []));\n\n        case 'Field':\n          return this.fieldToOperation(convertContext, subject, selectionNode, true);\n      }\n    }\n    /**\n     * Create a pattern with an rdf:type predicate.\n     * @param {Term} subject The subject.\n     * @param {NamedTypeNode} typeCondition The object name.\n     * @param {IConvertContext} convertContext A convert context.\n     * @return {Pattern} A pattern.\n     */\n\n  }, {\n    key: \"newTypePattern\",\n    value: function newTypePattern(subject, typeCondition, convertContext) {\n      return this.operationFactory.createPattern(subject, this.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), this.valueToNamedNode(typeCondition.name.value, convertContext.context));\n    }\n    /**\n     * Convert a field node to an operation.\n     * @param {IConvertContext} convertContext A convert context.\n     * @param {Term} subject The subject.\n     * @param {FieldNode} fieldNode The field node to convert.\n     * @param {boolean} pushTerminalVariables If terminal variables should be created.\n     * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.\n     * @return {Operation} The reslting operation.\n     */\n\n  }, {\n    key: \"fieldToOperation\",\n    value: function fieldToOperation(convertContext, subject, fieldNode, pushTerminalVariables, auxiliaryPatterns) {\n      var _this2 = this;\n\n      // Offset and limit can be changed using the magic arguments 'first' and 'offset'.\n      var offset = 0;\n      var limit;\n\n      if (pushTerminalVariables) {\n        var operationOverride = this.handleMetaField(convertContext, subject, fieldNode, auxiliaryPatterns);\n\n        if (operationOverride) {\n          return operationOverride;\n        }\n      }\n\n      var patterns = auxiliaryPatterns ? auxiliaryPatterns.concat([]) : []; // Aliases change the variable name (and path name)\n\n      var object = this.nameToVariable(fieldNode.alias ? fieldNode.alias : fieldNode.name, convertContext); // Check if there is a '_' argument\n      // We do this before handling all other arguments so that the order of final triple patterns is sane.\n\n      var setValueArgument = null;\n\n      if (fieldNode.arguments && fieldNode.arguments.length) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = fieldNode.arguments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var argument = _step4.value;\n\n            if (argument.name.value === '_') {\n              // '_'-arguments do not create an additional predicate link, but set the value directly.\n              setValueArgument = argument;\n              pushTerminalVariables = false;\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        if (setValueArgument) {\n          var valueOutput = this.valueToTerm(setValueArgument.value, convertContext, fieldNode.name.value);\n          valueOutput.terms.forEach(function (term) {\n            return patterns.push(_this2.createTriplePattern(subject, fieldNode.name, term, convertContext.context));\n          });\n\n          if (valueOutput.auxiliaryPatterns) {\n            patterns = patterns.concat(valueOutput.auxiliaryPatterns);\n          }\n        }\n      } // Create at least a pattern for the parent node and the current path.\n\n\n      if (pushTerminalVariables) {\n        patterns.push(this.createTriplePattern(subject, fieldNode.name, object, convertContext.context));\n      } // Create patterns for the node's arguments\n\n\n      if (fieldNode.arguments && fieldNode.arguments.length) {\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = fieldNode.arguments[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var _argument = _step5.value;\n\n            if (_argument.name.value === '_') {// no-op\n            } else if (_argument.name.value === 'first') {\n              if (_argument.value.kind !== 'IntValue') {\n                throw new Error('Invalid value type for \\'first\\' argument: ' + _argument.value.kind);\n              }\n\n              limit = parseInt(_argument.value.value, 10);\n            } else if (_argument.name.value === 'offset') {\n              if (_argument.value.kind !== 'IntValue') {\n                throw new Error('Invalid value type for \\'offset\\' argument: ' + _argument.value.kind);\n              }\n\n              offset = parseInt(_argument.value.value, 10);\n            } else {\n              var _valueOutput = this.valueToTerm(_argument.value, convertContext, _argument.name.value);\n\n              var _iteratorNormalCompletion6 = true;\n              var _didIteratorError6 = false;\n              var _iteratorError6 = undefined;\n\n              try {\n                for (var _iterator6 = _valueOutput.terms[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                  var term = _step6.value;\n                  patterns.push(this.createTriplePattern(object, _argument.name, term, convertContext.context));\n                }\n              } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                    _iterator6.return();\n                  }\n                } finally {\n                  if (_didIteratorError6) {\n                    throw _iteratorError6;\n                  }\n                }\n              }\n\n              if (_valueOutput.auxiliaryPatterns) {\n                patterns = patterns.concat(_valueOutput.auxiliaryPatterns);\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      } // Directives\n\n\n      if (fieldNode.directives) {\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = fieldNode.directives[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var directive = _step7.value;\n\n            if (!this.handleDirective(directive, convertContext)) {\n              return this.operationFactory.createBgp([]);\n            }\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      } // Recursive call for nested selection sets\n\n\n      var operation = this.operationFactory.createBgp(patterns);\n\n      if (fieldNode.selectionSet && fieldNode.selectionSet.selections.length) {\n        // Change path value when there was an alias on this node.\n        var pathSubValue = fieldNode.alias ? fieldNode.alias.value : fieldNode.name.value;\n        var subConvertContext = pushTerminalVariables ? Object.assign(Object.assign({}, convertContext), {\n          path: convertContext.path.concat([pathSubValue])\n        }) : convertContext; // If the magic keyword 'totalCount' is present, include a count aggregator.\n\n        var totalCount = false;\n        var selections = fieldNode.selectionSet.selections.filter(function (selection) {\n          if (selection.kind === 'Field' && selection.name.value === 'totalCount') {\n            totalCount = true;\n            return false;\n          }\n\n          return true;\n        });\n        var joinedOperation = this.joinOperations([operation].concat(selections.map(this.selectionToPatterns.bind(this, subConvertContext, pushTerminalVariables ? object : subject)))); // Modify the operation if there was a count selection\n\n        if (totalCount) {\n          // Create to a count aggregation\n          var expressionVariable = this.dataFactory.variable('var' + this.expressionVariableCounter++);\n          var countOverVariable = this.dataFactory.variable(object.value + this.variableDelimiter + 'totalCount');\n          var aggregator = this.operationFactory.createBoundAggregate(expressionVariable, 'count', this.operationFactory.createTermExpression(object), false);\n          var countProject = this.operationFactory.createProject(this.operationFactory.createExtend(this.operationFactory.createGroup(operation, [], [aggregator]), countOverVariable, this.operationFactory.createTermExpression(expressionVariable)), [countOverVariable]);\n          convertContext.terminalVariables.push(countOverVariable); // If no other selections exist (next to totalCount),\n          // then we just return the count operations as-is,\n          // otherwise, we join the count operation with all other selections\n\n          if (!selections.length) {\n            joinedOperation = countProject;\n          } else {\n            joinedOperation = this.operationFactory.createJoin(this.operationFactory.createProject(joinedOperation, []), countProject);\n          }\n        }\n\n        operation = joinedOperation;\n      } else if (pushTerminalVariables) {\n        // If no nested selection sets exist,\n        // consider the object variable as a terminal variable that should be selected.\n        convertContext.terminalVariables.push(object);\n      } // Wrap the operation in a slice if a 'first' or 'offset' argument was provided.\n\n\n      if (offset || limit) {\n        operation = this.operationFactory.createSlice(this.operationFactory.createProject(operation, []), offset, limit);\n      }\n\n      return operation;\n    }\n    /**\n     * Create a triple pattern when the predicate is a name node that needs to be translated using the context.\n     * @param {Term} subject The subject.\n     * @param {NameNode} predicateName The name node for the predicate.\n     * @param {Term} object The object.\n     * @param {IContext} context A context.\n     * @return {Pattern} A triple pattern.\n     */\n\n  }, {\n    key: \"createTriplePattern\",\n    value: function createTriplePattern(subject, predicateName, object, context) {\n      var predicate = this.valueToNamedNode(predicateName.value, context);\n\n      if (context && context[predicateName.value] && context[predicateName.value]['@reverse'] === predicate.value) {\n        return this.operationFactory.createPattern(object, predicate, subject);\n      }\n\n      return this.operationFactory.createPattern(subject, predicate, object);\n    }\n    /**\n     * Check if the given node is a meta field, for things like introspection.\n     * If so, return a new operation for this, otherwise, null is returned.\n     * @param {IConvertContext} convertContext A convert context.\n     * @param {Term} subject The subject.\n     * @param {FieldNode} fieldNode The field node to convert.\n     * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.\n     * @return {Operation} An operation or null.\n     */\n\n  }, {\n    key: \"handleMetaField\",\n    value: function handleMetaField(convertContext, subject, fieldNode, auxiliaryPatterns) {\n      // TODO: in the future, we should add support for GraphQL wide range of introspection features:\n      // http://graphql.org/learn/introspection/\n      if (fieldNode.name.value === '__typename') {\n        // Aliases change the variable name (and path name)\n        var object = this.nameToVariable(fieldNode.alias ? fieldNode.alias : fieldNode.name, convertContext);\n        convertContext.terminalVariables.push(object);\n        return this.operationFactory.createBgp([this.operationFactory.createPattern(subject, this.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), object)].concat(auxiliaryPatterns || []));\n      }\n\n      return null;\n    }\n    /**\n     * Join the given array of operations.\n     * If all operations are BGPs, then a single big BGP with all patterns from the given BGPs will be created.\n     * @param {Operation[]} operations An array of operations.\n     * @return {Operation} A single joined operation.\n     */\n\n  }, {\n    key: \"joinOperations\",\n    value: function joinOperations(operations) {\n      var _this3 = this;\n\n      if (!operations.length) {\n        throw new Error('Can not make a join of no operations');\n      }\n\n      if (operations.length === 1) {\n        return operations[0];\n      } // Check if all operations are BGPs\n\n\n      var bgps = true;\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = operations[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var operation = _step8.value;\n\n          if (operation.type !== 'bgp') {\n            bgps = false;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      if (bgps) {\n        // Create a big BGP from all BGPs\n        return this.operationFactory.createBgp([].concat.apply([], operations.map(function (op) {\n          return op.patterns;\n        })));\n      } else {\n        // Create nested joins\n        return operations.reverse().reduce(function (prev, cur) {\n          return prev ? _this3.operationFactory.createJoin(cur, prev) : cur;\n        }, null);\n      }\n    }\n    /**\n     * Convert a name node to a variable built from the node name and the current path inside the context.\n     * @param {NameNode} name A name node.\n     * @param {IConvertContext} convertContext A convert context.\n     * @return {Variable} A variable.\n     */\n\n  }, {\n    key: \"nameToVariable\",\n    value: function nameToVariable(name, convertContext) {\n      return this.dataFactory.variable((convertContext.path.length ? convertContext.path.join(this.variableDelimiter) + this.variableDelimiter : '') + name.value);\n    }\n    /**\n     * Convert a GraphQL term into a URI using the given context.\n     * @param {string} value A GraphQL term.\n     * @param {IContext} context A JSON-LD context.\n     * @return {NamedNode} A named node.\n     */\n\n  }, {\n    key: \"valueToNamedNode\",\n    value: function valueToNamedNode(value, context) {\n      var contextValue = context[value];\n\n      if (this.requireContext && !contextValue) {\n        throw new Error('No context entry was found for ' + value);\n      }\n\n      if (contextValue && !(typeof contextValue === 'string')) {\n        contextValue = contextValue['@id'] || contextValue['@reverse'];\n      }\n\n      return this.dataFactory.namedNode(contextValue || value);\n    }\n    /**\n     * Convert a GraphQL value into an RDF term.\n     * @param {ValueNode} valueNode A GraphQL value node.\n     * @param {IConvertContext} convertContext A convert context.\n     * @param {string} argumentName The name of the argument this value is created for.\n     *                              This might influence the literal language or datatype.\n     * @return {Term} An RDF term.\n     */\n\n  }, {\n    key: \"valueToTerm\",\n    value: function valueToTerm(valueNode, convertContext, argumentName) {\n      switch (valueNode.kind) {\n        case 'Variable':\n          var variableNode = valueNode;\n          var id = variableNode.name.value;\n          var value = convertContext.variablesDict[id];\n          var meta = convertContext.variablesMetaDict[id]; // Handle missing values\n\n          if (!value) {\n            if (!meta || meta.mandatory) {\n              throw new Error(\"Undefined variable: \".concat(id));\n            } else {\n              return this.valueToTerm({\n                kind: 'NullValue'\n              }, convertContext, argumentName);\n            }\n          } // Don't allow variables that refer to other variables\n\n\n          if (value.kind === 'Variable') {\n            throw new Error(\"Variable refers to another variable: \".concat(id));\n          }\n\n          if (meta) {\n            // Check the type\n            if (meta.list) {\n              // If we expect a list, check if we got a list.\n              if (value.kind !== 'ListValue') {\n                throw new Error(\"Expected a list, but got \".concat(value.kind, \" for \").concat(id));\n              } // Check the type in the list\n\n\n              if (meta.type) {\n                var listValue = value;\n                var _iteratorNormalCompletion9 = true;\n                var _didIteratorError9 = false;\n                var _iteratorError9 = undefined;\n\n                try {\n                  for (var _iterator9 = listValue.values[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                    var v = _step9.value;\n\n                    if (v.kind !== meta.type) {\n                      throw new Error(\"Expected \".concat(meta.type, \", but got \").concat(v.kind, \" for \").concat(id));\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError9 = true;\n                  _iteratorError9 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                      _iterator9.return();\n                    }\n                  } finally {\n                    if (_didIteratorError9) {\n                      throw _iteratorError9;\n                    }\n                  }\n                }\n              }\n            } else if (meta.type) {// This is allowed to be different (?)\n\n              /*if (value.kind !== meta.type) {\n                throw new Error(`Expected ${meta.type}, but got ${value.kind} for ${id}`);\n              }*/\n            }\n          }\n\n          return this.valueToTerm(value, convertContext, argumentName);\n\n        case 'IntValue':\n          return {\n            terms: [this.dataFactory.literal(valueNode.value, this.dataFactory.namedNode('http://www.w3.org/2001/XMLSchema#integer'))]\n          };\n\n        case 'FloatValue':\n          return {\n            terms: [this.dataFactory.literal(valueNode.value, this.dataFactory.namedNode('http://www.w3.org/2001/XMLSchema#float'))]\n          };\n\n        case 'StringValue':\n          var contextEntry = convertContext.context[argumentName];\n          var language = null;\n          var datatype = null;\n\n          if (contextEntry && typeof contextEntry !== 'string') {\n            if (contextEntry['@language']) {\n              language = contextEntry['@language'];\n            } else if (contextEntry['@type']) {\n              datatype = this.dataFactory.namedNode(contextEntry['@type']);\n            }\n          }\n\n          return {\n            terms: [this.dataFactory.literal(valueNode.value, language || datatype)]\n          };\n\n        case 'BooleanValue':\n          return {\n            terms: [this.dataFactory.literal(valueNode.value ? 'true' : 'false', this.dataFactory.namedNode('http://www.w3.org/2001/XMLSchema#boolean'))]\n          };\n\n        case 'NullValue':\n          return {\n            terms: [this.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil')]\n          };\n\n        case 'EnumValue':\n          return {\n            terms: [this.valueToNamedNode(valueNode.value, convertContext.context)]\n          };\n\n        case 'ListValue':\n          var listTerms = [];\n          var auxiliaryPatterns = []; // Create terms for list values\n\n          var _iteratorNormalCompletion10 = true;\n          var _didIteratorError10 = false;\n          var _iteratorError10 = undefined;\n\n          try {\n            for (var _iterator10 = valueNode.values[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n              var _v = _step10.value;\n              var subValue = this.valueToTerm(_v, convertContext, argumentName);\n              var _iteratorNormalCompletion11 = true;\n              var _didIteratorError11 = false;\n              var _iteratorError11 = undefined;\n\n              try {\n                for (var _iterator11 = subValue.terms[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                  var _term = _step11.value;\n                  listTerms.push(_term);\n                }\n              } catch (err) {\n                _didIteratorError11 = true;\n                _iteratorError11 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                    _iterator11.return();\n                  }\n                } finally {\n                  if (_didIteratorError11) {\n                    throw _iteratorError11;\n                  }\n                }\n              }\n\n              if (subValue.auxiliaryPatterns) {\n                auxiliaryPatterns = auxiliaryPatterns.concat(subValue.auxiliaryPatterns);\n              }\n            }\n          } catch (err) {\n            _didIteratorError10 = true;\n            _iteratorError10 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n                _iterator10.return();\n              }\n            } finally {\n              if (_didIteratorError10) {\n                throw _iteratorError10;\n              }\n            }\n          }\n\n          if (this.arraysToRdfLists) {\n            // Convert array to RDF list\n            // Create chained list structure\n            var firstListNode = this.dataFactory.blankNode();\n            var listNode = firstListNode;\n            var remaining = listTerms.length;\n\n            for (var _i = 0; _i < listTerms.length; _i++) {\n              var term = listTerms[_i];\n              auxiliaryPatterns.push(this.operationFactory.createPattern(listNode, this.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first'), term));\n              var nextListNode = --remaining === 0 ? this.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil') : this.dataFactory.blankNode();\n              auxiliaryPatterns.push(this.operationFactory.createPattern(listNode, this.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest'), nextListNode));\n              listNode = nextListNode;\n            }\n\n            return {\n              terms: [firstListNode],\n              auxiliaryPatterns: auxiliaryPatterns\n            };\n          } else {\n            // Convert array to multiple terms that will be linked via the same predicate.\n            return {\n              terms: listTerms,\n              auxiliaryPatterns: auxiliaryPatterns\n            };\n          }\n\n        case 'ObjectValue':\n          // Convert object keys to predicates and values to objects, and link them both with a new blank node.\n          var subject = this.dataFactory.blankNode();\n          var auxiliaryObjectPatterns = [];\n          var _iteratorNormalCompletion12 = true;\n          var _didIteratorError12 = false;\n          var _iteratorError12 = undefined;\n\n          try {\n            for (var _iterator12 = valueNode.fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n              var field = _step12.value;\n              var predicate = this.valueToNamedNode(field.name.value, convertContext.context);\n\n              var _subValue = this.valueToTerm(field.value, convertContext, argumentName);\n\n              var _iteratorNormalCompletion13 = true;\n              var _didIteratorError13 = false;\n              var _iteratorError13 = undefined;\n\n              try {\n                for (var _iterator13 = _subValue.terms[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                  var _term2 = _step13.value;\n                  auxiliaryObjectPatterns.push(this.createTriplePattern(subject, field.name, _term2, convertContext.context));\n                }\n              } catch (err) {\n                _didIteratorError13 = true;\n                _iteratorError13 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n                    _iterator13.return();\n                  }\n                } finally {\n                  if (_didIteratorError13) {\n                    throw _iteratorError13;\n                  }\n                }\n              }\n\n              if (_subValue.auxiliaryPatterns) {\n                auxiliaryObjectPatterns = auxiliaryObjectPatterns.concat(_subValue.auxiliaryPatterns);\n              }\n            }\n          } catch (err) {\n            _didIteratorError12 = true;\n            _iteratorError12 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n                _iterator12.return();\n              }\n            } finally {\n              if (_didIteratorError12) {\n                throw _iteratorError12;\n              }\n            }\n          }\n\n          return {\n            terms: [subject],\n            auxiliaryPatterns: auxiliaryObjectPatterns\n          };\n      }\n    }\n    /**\n     * Get an argument by name.\n     * This will throw an error if the argument could not be found.\n     * @param {ReadonlyArray<ArgumentNode>} args Arguments or null.\n     * @param {string} name The name of an argument.\n     * @return {ArgumentNode} The named argument.\n     */\n\n  }, {\n    key: \"getArgument\",\n    value: function getArgument(args, name) {\n      if (!args) {\n        throw new Error('No arguments were defined for the directive.');\n      }\n\n      var _iteratorNormalCompletion14 = true;\n      var _didIteratorError14 = false;\n      var _iteratorError14 = undefined;\n\n      try {\n        for (var _iterator14 = args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n          var argument = _step14.value;\n\n          if (argument.name.value === name) {\n            return argument;\n          }\n        }\n      } catch (err) {\n        _didIteratorError14 = true;\n        _iteratorError14 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n            _iterator14.return();\n          }\n        } finally {\n          if (_didIteratorError14) {\n            throw _iteratorError14;\n          }\n        }\n      }\n\n      throw new Error('Undefined argument: ' + name);\n    }\n    /**\n     * Handle a directive.\n     * @param {DirectiveNode} directive A directive.\n     * @param {IConvertContext} convertContext A convert context.\n     * @return {boolean} If processing of the active should continue.\n     */\n\n  }, {\n    key: \"handleDirective\",\n    value: function handleDirective(directive, convertContext) {\n      var arg = this.getArgument(directive.arguments, 'if');\n      var subValue = this.valueToTerm(arg.value, convertContext, arg.name.value);\n\n      if (subValue.terms.length !== 1) {\n        throw new Error(\"Can not apply a directive with a list: \".concat(subValue.terms));\n      }\n\n      var val = subValue.terms[0];\n\n      switch (directive.name.value) {\n        case 'include':\n          if (val.termType === 'Literal' && val.value === 'false') {\n            return false;\n          }\n\n          break;\n\n        case 'skip':\n          if (val.termType === 'Literal' && val.value === 'true') {\n            return false;\n          }\n\n          break;\n\n        default:\n          throw new Error('Unsupported directive: ' + directive.name.value);\n      }\n\n      return true;\n    }\n    /**\n     * Translates blank nodes inside the query to variables.\n     * @param {Project} operation The operation to translate.\n     * @return {Operation} The transformed operation.\n     */\n\n  }, {\n    key: \"translateBlankNodesToVariables\",\n    value: function translateBlankNodesToVariables(operation) {\n      var dataFactory = this.dataFactory;\n      var blankToVariableMapping = {};\n      var variablesRaw = Array.from(operation.variables).reduce(function (acc, variable) {\n        acc[variable.value] = true;\n        return acc;\n      }, {});\n      return sparqlalgebrajs_1.Util.mapOperation(operation, {\n        path: function path(op, factory) {\n          return {\n            recurse: false,\n            result: factory.createPath(blankToVariable(op.subject), op.predicate, blankToVariable(op.object), blankToVariable(op.graph))\n          };\n        },\n        pattern: function pattern(op, factory) {\n          return {\n            recurse: false,\n            result: factory.createPattern(blankToVariable(op.subject), blankToVariable(op.predicate), blankToVariable(op.object), blankToVariable(op.graph))\n          };\n        }\n      });\n\n      function blankToVariable(term) {\n        if (term.termType === 'BlankNode') {\n          var variable = blankToVariableMapping[term.value];\n\n          if (!variable) {\n            variable = sparqlalgebrajs_1.Util.createUniqueVariable(term.value, variablesRaw, dataFactory);\n            variablesRaw[variable.value] = true;\n            blankToVariableMapping[term.value] = variable;\n          }\n\n          return variable;\n        }\n\n        return term;\n      }\n    }\n  }]);\n\n  return Converter;\n}();\n\nexports.Converter = Converter;","map":null,"metadata":{},"sourceType":"script"}