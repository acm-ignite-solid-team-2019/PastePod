{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DefaultDataFactory = require(\"@rdfjs/data-model\");\n\nvar SparqlXmlBindingsTransformer_1 = require(\"./SparqlXmlBindingsTransformer\"); // tslint:disable-next-line:no-var-requires\n\n\nvar XmlNode = require('sax-stream');\n/**\n * Parser for the SPARQL Query Results XML format.\n * @see https://www.w3.org/TR/rdf-sparql-XMLres/\n */\n\n\nvar SparqlXmlParser =\n/*#__PURE__*/\nfunction () {\n  function SparqlXmlParser(settings) {\n    _classCallCheck(this, SparqlXmlParser);\n\n    settings = settings || {};\n    this.dataFactory = settings.dataFactory || DefaultDataFactory;\n    this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n  }\n  /**\n   * Convert a SPARQL XML bindings response stream to a stream of bindings objects.\n   *\n   * The bindings stream will emit a 'variables' event that will contain\n   * the array of variables (as RDF.Variable[]), as defined in the response head.\n   *\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n   * @return {NodeJS.ReadableStream} A stream of bindings.\n   */\n\n\n  _createClass(SparqlXmlParser, [{\n    key: \"parseXmlResultsStream\",\n    value: function parseXmlResultsStream(sparqlResponseStream) {\n      var _this = this;\n\n      // Collect variables\n      var variables = [];\n      sparqlResponseStream.pipe(XmlNode({\n        strict: true,\n        tag: 'variable'\n      })).on('data', function (node) {\n        return variables.push(_this.dataFactory.variable(node.attribs.name));\n      }).on('error', function () {\n        return;\n      }) // Ignore errors, they will emitted in the results\n      .on('finish', function () {\n        return resultStream.emit('variables', variables);\n      }); // Collect results\n\n      var resultStream = sparqlResponseStream.pipe(XmlNode({\n        strict: true,\n        tag: 'result'\n      })).on('error', function (error) {\n        return resultStream.emit('error', error);\n      }).pipe(new SparqlXmlBindingsTransformer_1.SparqlXmlBindingsTransformer(this)); // Propagate errors\n\n      sparqlResponseStream.on('error', function (error) {\n        return resultStream.emit('error', error);\n      });\n      return resultStream;\n    }\n    /**\n     * Convert a SPARQL XML result binding to a bindings object.\n     * @param rawBindings A SPARQL XML result binding.\n     * @return {IBindings} A bindings object.\n     */\n\n  }, {\n    key: \"parseXmlBindings\",\n    value: function parseXmlBindings(rawBindings) {\n      var bindings = {};\n\n      if (rawBindings.children) {\n        var bindingsArray = Array.isArray(rawBindings.children.binding) ? rawBindings.children.binding : [rawBindings.children.binding];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = bindingsArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var binding = _step.value;\n\n            if (binding.attribs && binding.children) {\n              var key = binding.attribs.name;\n              var term = null;\n\n              if (binding.children.bnode) {\n                term = this.dataFactory.blankNode(binding.children.bnode.value);\n              } else if (binding.children.literal) {\n                var value = binding.children.literal.value || \"\";\n                var attribs = binding.children.literal.attribs;\n\n                if (attribs && attribs['xml:lang']) {\n                  term = this.dataFactory.literal(value, attribs['xml:lang']);\n                } else if (attribs && attribs.datatype) {\n                  term = this.dataFactory.literal(value, this.dataFactory.namedNode(attribs.datatype));\n                } else {\n                  term = this.dataFactory.literal(value);\n                }\n              } else {\n                term = this.dataFactory.namedNode(binding.children.uri.value);\n              }\n\n              bindings[this.prefixVariableQuestionMark ? '?' + key : key] = term;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return bindings;\n    }\n    /**\n     * Convert a SPARQL XML boolean response stream to a promise resolving to a boolean.\n     * This will reject if the given response was not a valid boolean response.\n     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n     * @return {NodeJS.ReadableStream} A stream of bindings.\n     */\n\n  }, {\n    key: \"parseXmlBooleanStream\",\n    value: function parseXmlBooleanStream(sparqlResponseStream) {\n      return new Promise(function (resolve, reject) {\n        sparqlResponseStream.on('error', reject);\n        sparqlResponseStream.pipe(XmlNode({\n          strict: true,\n          tag: 'boolean'\n        })).on('error', reject).on('data', function (node) {\n          return resolve(node.value === 'true');\n        }).on('end', function () {\n          return reject(new Error('No valid ASK response was found.'));\n        });\n      });\n    }\n  }]);\n\n  return SparqlXmlParser;\n}();\n\nexports.SparqlXmlParser = SparqlXmlParser;","map":null,"metadata":{},"sourceType":"script"}