{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _definitions2;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar immutable_1 = require(\"immutable\");\n\nvar Err = require(\"../util/Errors\");\n\nvar Consts_1 = require(\"../util/Consts\");\n\nvar Parsing_1 = require(\"../util/Parsing\");\n\nvar Helpers_1 = require(\"./Helpers\"); // ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// Begin definitions.\n// ----------------------------------------------------------------------------\n// XPath Constructor functions\n// https://www.w3.org/TR/sparql11-query/#\n// https://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive\n// ----------------------------------------------------------------------------\n\n\nvar toString = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(function (term) {\n    return Helpers_1.string(term.str());\n  }).collect()\n};\nvar toFloat = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (val) {\n    return Helpers_1.number(val.typedValue);\n  }).onBoolean1Typed(function (val) {\n    return Helpers_1.number(val ? 1 : 0);\n  }).onUnary('string', function (val) {\n    var result = Parsing_1.parseXSDFloat(val.str());\n\n    if (!result) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_FLOAT);\n    }\n\n    return Helpers_1.number(result);\n  }).copy({\n    from: ['string'],\n    to: ['nonlexical']\n  }).collect()\n};\nvar toDouble = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (val) {\n    return Helpers_1.number(val.typedValue, Consts_1.TypeURL.XSD_DOUBLE);\n  }).onBoolean1Typed(function (val) {\n    return Helpers_1.number(val ? 1 : 0, Consts_1.TypeURL.XSD_DOUBLE);\n  }).onUnary('string', function (val) {\n    var result = Parsing_1.parseXSDFloat(val.str());\n\n    if (!result) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_DOUBLE);\n    }\n\n    return Helpers_1.number(result, Consts_1.TypeURL.XSD_DOUBLE);\n  }).copy({\n    from: ['string'],\n    to: ['nonlexical']\n  }).collect()\n};\nvar toDecimal = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (val) {\n    var result = Parsing_1.parseXSDDecimal(val.str());\n\n    if (!result) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_DECIMAL);\n    }\n\n    return Helpers_1.number(result, Consts_1.TypeURL.XSD_DECIMAL);\n  }).copy({\n    from: ['integer'],\n    to: ['string']\n  }).copy({\n    from: ['integer'],\n    to: ['nonlexical']\n  }).onBoolean1Typed(function (val) {\n    return Helpers_1.number(val ? 1 : 0, Consts_1.TypeURL.XSD_DECIMAL);\n  }).collect()\n};\nvar toInteger = {\n  arity: 1,\n  overloads: Helpers_1.declare().onBoolean1Typed(function (val) {\n    return Helpers_1.number(val ? 1 : 0, Consts_1.TypeURL.XSD_INTEGER);\n  }).onNumeric1(function (val) {\n    var result = Parsing_1.parseXSDInteger(val.str());\n\n    if (!result) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_INTEGER);\n    }\n\n    return Helpers_1.number(result, Consts_1.TypeURL.XSD_INTEGER);\n  }).copy({\n    from: ['integer'],\n    to: ['string']\n  }).copy({\n    from: ['integer'],\n    to: ['nonlexical']\n  }).collect()\n};\nvar toDatetime = {\n  arity: 1,\n  overloads: Helpers_1.declare().onUnary('date', function (val) {\n    return val;\n  }).onUnary('string', function (val) {\n    var date = new Date(val.str());\n\n    if (isNaN(date.getTime())) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_DATE_TIME);\n    }\n\n    return Helpers_1.dateTime(date, val.str());\n  }).copy({\n    from: ['string'],\n    to: ['nonlexical']\n  }).collect()\n};\nvar toBoolean = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(function (val) {\n    return Helpers_1.bool(val.coerceEBV());\n  }).onUnary('boolean', function (val) {\n    return val;\n  }).onUnary('string', function (val) {\n    var str = val.str();\n\n    if (str !== 'true' && str !== 'false') {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_BOOLEAN);\n    }\n\n    return Helpers_1.bool(str === 'true');\n  }).copy({\n    from: ['string'],\n    to: ['nonlexical']\n  }).collect()\n}; // End definitions.\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\nvar _definitions = (_definitions2 = {}, _defineProperty(_definitions2, Consts_1.TypeURL.XSD_STRING, toString), _defineProperty(_definitions2, Consts_1.TypeURL.XSD_FLOAT, toFloat), _defineProperty(_definitions2, Consts_1.TypeURL.XSD_DOUBLE, toDouble), _defineProperty(_definitions2, Consts_1.TypeURL.XSD_DECIMAL, toDecimal), _defineProperty(_definitions2, Consts_1.TypeURL.XSD_INTEGER, toInteger), _defineProperty(_definitions2, Consts_1.TypeURL.XSD_DATE_TIME, toDatetime), _defineProperty(_definitions2, Consts_1.TypeURL.XSD_BOOLEAN, toBoolean), _definitions2);\n\nexports.namedDefinitions = immutable_1.Map(_definitions);","map":null,"metadata":{},"sourceType":"script"}