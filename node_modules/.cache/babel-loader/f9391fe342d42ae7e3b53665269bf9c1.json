{"ast":null,"code":"var _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar AsyncIterator = require('asynciterator'); // https://en.wikipedia.org/wiki/Symmetric_Hash_Join\n\n\nvar SymmetricHashJoin =\n/*#__PURE__*/\nfunction (_AsyncIterator) {\n  \"use strict\";\n\n  _inherits(SymmetricHashJoin, _AsyncIterator);\n\n  function SymmetricHashJoin(left, right, funHash, funJoin) {\n    var _this;\n\n    _classCallCheck(this, SymmetricHashJoin);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SymmetricHashJoin).call(this));\n    _this.left = left;\n    _this.right = right;\n    _this.funHash = funHash;\n    _this.funJoin = funJoin;\n    _this.usedLeft = false;\n    _this.leftMap = new Map();\n    _this.rightMap = new Map();\n\n    _this.on('end', function () {\n      return _this._cleanup();\n    });\n\n    _this.match = null;\n    _this.matches = [];\n    _this.matchIdx = 0;\n\n    _this.left.on('readable', function () {\n      return _this.readable = true;\n    });\n\n    _this.right.on('readable', function () {\n      return _this.readable = true;\n    }); // this needs to be here since it's possible the left/right streams only get ended after there are no more results left\n\n\n    _this.left.on('end', function () {\n      if (!_this.hasResults()) _this._end();\n    });\n\n    _this.right.on('end', function () {\n      if (!_this.hasResults()) _this._end();\n    });\n\n    return _this;\n  }\n\n  _createClass(SymmetricHashJoin, [{\n    key: \"hasResults\",\n    value: function hasResults() {\n      return !this.left.ended || !this.right.ended || this.matchIdx < this.matches.length;\n    }\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      // motivate garbage collector to remove these\n      this.leftMap = null;\n      this.rightMap = null;\n      this.matches = null;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      _get(_getPrototypeOf(SymmetricHashJoin.prototype), \"close\", this).call(this);\n\n      this.left.close();\n      this.right.close();\n    }\n  }, {\n    key: \"read\",\n    value: function read() {\n      if (this.ended) return null;\n\n      while (this.matchIdx < this.matches.length) {\n        var _item = this.matches[this.matchIdx++];\n        var result = this.usedLeft ? this.funJoin(this.match, _item) : this.funJoin(_item, this.match);\n        if (result !== null) return result;\n      }\n\n      if (!this.hasResults()) this._end();\n      var item = null; // try both streams if the first one has no value\n\n      for (var i = 0; i < 2; ++i) {\n        item = this.usedLeft ? this.right.read() : this.left.read();\n        this.usedLeft = !this.usedLeft; // try other stream next time\n        // found a result, no need to check the other stream this run\n\n        if (item !== null) break;\n      }\n\n      if (item === null) {\n        this.readable = false;\n        return null;\n      }\n\n      var hash = this.funHash(item);\n      var map = this.usedLeft ? this.leftMap : this.rightMap;\n      if (!map.has(hash)) map.set(hash, []);\n      var arr = map.get(hash);\n      arr.push(item);\n      this.match = item;\n      this.matches = (this.usedLeft ? this.rightMap : this.leftMap).get(hash) || [];\n      this.matchIdx = 0; // array is filled again so recursive call can have results\n\n      return this.read();\n    }\n  }]);\n\n  return SymmetricHashJoin;\n}(AsyncIterator);\n\nmodule.exports = SymmetricHashJoin;","map":null,"metadata":{},"sourceType":"script"}