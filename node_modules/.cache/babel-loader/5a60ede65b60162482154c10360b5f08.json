{"ast":null,"code":"!function (f) {\n  if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = f();else if (\"function\" == typeof define && define.amd) define([], f);else {\n    var g;\n    g = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : this, g.default = f();\n  }\n}(function () {\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = \"function\" == typeof require && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    for (var i = \"function\" == typeof require && require, o = 0; o < r.length; o++) {\n      s(r[o]);\n    }\n\n    return s;\n  }({\n    1: [function (require, module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: !0\n      });\n\n      var _require = require(\"./spec/reference-implementation/lib/readable-stream\"),\n          ReadableStream = _require.ReadableStream,\n          _require2 = require(\"./spec/reference-implementation/lib/writable-stream\"),\n          WritableStream = _require2.WritableStream,\n          ByteLengthQueuingStrategy = require(\"./spec/reference-implementation/lib/byte-length-queuing-strategy\"),\n          CountQueuingStrategy = require(\"./spec/reference-implementation/lib/count-queuing-strategy\"),\n          TransformStream = require(\"./spec/reference-implementation/lib/transform-stream\");\n\n      exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports.CountQueuingStrategy = CountQueuingStrategy, exports.TransformStream = TransformStream, exports.ReadableStream = ReadableStream, exports.WritableStream = WritableStream;\n      var interfaces = {\n        ReadableStream: ReadableStream,\n        WritableStream: WritableStream,\n        ByteLengthQueuingStrategy: ByteLengthQueuingStrategy,\n        CountQueuingStrategy: CountQueuingStrategy,\n        TransformStream: TransformStream\n      };\n      exports.default = interfaces, \"undefined\" != typeof window && Object.assign(window, interfaces);\n    }, {\n      \"./spec/reference-implementation/lib/byte-length-queuing-strategy\": 7,\n      \"./spec/reference-implementation/lib/count-queuing-strategy\": 8,\n      \"./spec/reference-implementation/lib/readable-stream\": 11,\n      \"./spec/reference-implementation/lib/transform-stream\": 12,\n      \"./spec/reference-implementation/lib/writable-stream\": 14\n    }],\n    2: [function (require, module, exports) {\n      function replacer(key, value) {\n        return util.isUndefined(value) ? \"\" + value : util.isNumber(value) && !isFinite(value) ? value.toString() : util.isFunction(value) || util.isRegExp(value) ? value.toString() : value;\n      }\n\n      function truncate(s, n) {\n        return util.isString(s) ? s.length < n ? s : s.slice(0, n) : s;\n      }\n\n      function getMessage(self) {\n        return truncate(JSON.stringify(self.actual, replacer), 128) + \" \" + self.operator + \" \" + truncate(JSON.stringify(self.expected, replacer), 128);\n      }\n\n      function fail(actual, expected, message, operator, stackStartFunction) {\n        throw new assert.AssertionError({\n          message: message,\n          actual: actual,\n          expected: expected,\n          operator: operator,\n          stackStartFunction: stackStartFunction\n        });\n      }\n\n      function ok(value, message) {\n        value || fail(value, !0, message, \"==\", assert.ok);\n      }\n\n      function _deepEqual(actual, expected) {\n        if (actual === expected) return !0;\n\n        if (util.isBuffer(actual) && util.isBuffer(expected)) {\n          if (actual.length != expected.length) return !1;\n\n          for (var i = 0; i < actual.length; i++) {\n            if (actual[i] !== expected[i]) return !1;\n          }\n\n          return !0;\n        }\n\n        return util.isDate(actual) && util.isDate(expected) ? actual.getTime() === expected.getTime() : util.isRegExp(actual) && util.isRegExp(expected) ? actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase : util.isObject(actual) || util.isObject(expected) ? objEquiv(actual, expected) : actual == expected;\n      }\n\n      function isArguments(object) {\n        return \"[object Arguments]\" == Object.prototype.toString.call(object);\n      }\n\n      function objEquiv(a, b) {\n        if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b)) return !1;\n        if (a.prototype !== b.prototype) return !1;\n        if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;\n        var aIsArgs = isArguments(a),\n            bIsArgs = isArguments(b);\n        if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return !1;\n        if (aIsArgs) return a = pSlice.call(a), b = pSlice.call(b), _deepEqual(a, b);\n        var key,\n            i,\n            ka = objectKeys(a),\n            kb = objectKeys(b);\n        if (ka.length != kb.length) return !1;\n\n        for (ka.sort(), kb.sort(), i = ka.length - 1; i >= 0; i--) {\n          if (ka[i] != kb[i]) return !1;\n        }\n\n        for (i = ka.length - 1; i >= 0; i--) {\n          if (key = ka[i], !_deepEqual(a[key], b[key])) return !1;\n        }\n\n        return !0;\n      }\n\n      function expectedException(actual, expected) {\n        return !(!actual || !expected) && (\"[object RegExp]\" == Object.prototype.toString.call(expected) ? expected.test(actual) : actual instanceof expected || expected.call({}, actual) === !0);\n      }\n\n      function _throws(shouldThrow, block, expected, message) {\n        var actual;\n        util.isString(expected) && (message = expected, expected = null);\n\n        try {\n          block();\n        } catch (e) {\n          actual = e;\n        }\n\n        if (message = (expected && expected.name ? \" (\" + expected.name + \").\" : \".\") + (message ? \" \" + message : \".\"), shouldThrow && !actual && fail(actual, expected, \"Missing expected exception\" + message), !shouldThrow && expectedException(actual, expected) && fail(actual, expected, \"Got unwanted exception\" + message), shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) throw actual;\n      }\n\n      var util = require(\"util/\"),\n          pSlice = Array.prototype.slice,\n          hasOwn = Object.prototype.hasOwnProperty,\n          assert = module.exports = ok;\n\n      assert.AssertionError = function (options) {\n        this.name = \"AssertionError\", this.actual = options.actual, this.expected = options.expected, this.operator = options.operator, options.message ? (this.message = options.message, this.generatedMessage = !1) : (this.message = getMessage(this), this.generatedMessage = !0);\n        var stackStartFunction = options.stackStartFunction || fail;\n        if (Error.captureStackTrace) Error.captureStackTrace(this, stackStartFunction);else {\n          var err = new Error();\n\n          if (err.stack) {\n            var out = err.stack,\n                fn_name = stackStartFunction.name,\n                idx = out.indexOf(\"\\n\" + fn_name);\n\n            if (idx >= 0) {\n              var next_line = out.indexOf(\"\\n\", idx + 1);\n              out = out.substring(next_line + 1);\n            }\n\n            this.stack = out;\n          }\n        }\n      }, util.inherits(assert.AssertionError, Error), assert.fail = fail, assert.ok = ok, assert.equal = function (actual, expected, message) {\n        actual != expected && fail(actual, expected, message, \"==\", assert.equal);\n      }, assert.notEqual = function (actual, expected, message) {\n        actual == expected && fail(actual, expected, message, \"!=\", assert.notEqual);\n      }, assert.deepEqual = function (actual, expected, message) {\n        _deepEqual(actual, expected) || fail(actual, expected, message, \"deepEqual\", assert.deepEqual);\n      }, assert.notDeepEqual = function (actual, expected, message) {\n        _deepEqual(actual, expected) && fail(actual, expected, message, \"notDeepEqual\", assert.notDeepEqual);\n      }, assert.strictEqual = function (actual, expected, message) {\n        actual !== expected && fail(actual, expected, message, \"===\", assert.strictEqual);\n      }, assert.notStrictEqual = function (actual, expected, message) {\n        actual === expected && fail(actual, expected, message, \"!==\", assert.notStrictEqual);\n      }, assert.throws = function (block, error, message) {\n        _throws.apply(this, [!0].concat(pSlice.call(arguments)));\n      }, assert.doesNotThrow = function (block, message) {\n        _throws.apply(this, [!1].concat(pSlice.call(arguments)));\n      }, assert.ifError = function (err) {\n        if (err) throw err;\n      };\n\n      var objectKeys = Object.keys || function (obj) {\n        var keys = [];\n\n        for (var key in obj) {\n          hasOwn.call(obj, key) && keys.push(key);\n        }\n\n        return keys;\n      };\n    }, {\n      \"util/\": 6\n    }],\n    3: [function (require, module, exports) {\n      \"function\" == typeof Object.create ? module.exports = function (ctor, superCtor) {\n        ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {\n          constructor: {\n            value: ctor,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        });\n      } : module.exports = function (ctor, superCtor) {\n        ctor.super_ = superCtor;\n\n        var TempCtor = function TempCtor() {};\n\n        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;\n      };\n    }, {}],\n    4: [function (require, module, exports) {\n      function cleanUpNextTick() {\n        draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());\n      }\n\n      function drainQueue() {\n        if (!draining) {\n          var timeout = cachedSetTimeout(cleanUpNextTick);\n          draining = !0;\n\n          for (var len = queue.length; len;) {\n            for (currentQueue = queue, queue = []; ++queueIndex < len;) {\n              currentQueue && currentQueue[queueIndex].run();\n            }\n\n            queueIndex = -1, len = queue.length;\n          }\n\n          currentQueue = null, draining = !1, cachedClearTimeout(timeout);\n        }\n      }\n\n      function Item(fun, array) {\n        this.fun = fun, this.array = array;\n      }\n\n      function noop() {}\n\n      var cachedSetTimeout,\n          cachedClearTimeout,\n          process = module.exports = {};\n      !function () {\n        try {\n          cachedSetTimeout = setTimeout;\n        } catch (e) {\n          cachedSetTimeout = function cachedSetTimeout() {\n            throw new Error(\"setTimeout is not defined\");\n          };\n        }\n\n        try {\n          cachedClearTimeout = clearTimeout;\n        } catch (e) {\n          cachedClearTimeout = function cachedClearTimeout() {\n            throw new Error(\"clearTimeout is not defined\");\n          };\n        }\n      }();\n      var currentQueue,\n          queue = [],\n          draining = !1,\n          queueIndex = -1;\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) {\n          args[i - 1] = arguments[i];\n        }\n        queue.push(new Item(fun, args)), 1 !== queue.length || draining || cachedSetTimeout(drainQueue, 0);\n      }, Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      }, process.title = \"browser\", process.browser = !0, process.env = {}, process.argv = [], process.version = \"\", process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.binding = function (name) {\n        throw new Error(\"process.binding is not supported\");\n      }, process.cwd = function () {\n        return \"/\";\n      }, process.chdir = function (dir) {\n        throw new Error(\"process.chdir is not supported\");\n      }, process.umask = function () {\n        return 0;\n      };\n    }, {}],\n    5: [function (require, module, exports) {\n      module.exports = function (arg) {\n        return arg && \"object\" == typeof arg && \"function\" == typeof arg.copy && \"function\" == typeof arg.fill && \"function\" == typeof arg.readUInt8;\n      };\n    }, {}],\n    6: [function (require, module, exports) {\n      (function (process, global) {\n        function inspect(obj, opts) {\n          var ctx = {\n            seen: [],\n            stylize: stylizeNoColor\n          };\n          return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), isBoolean(opts) ? ctx.showHidden = opts : opts && exports._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), formatValue(ctx, obj, ctx.depth);\n        }\n\n        function stylizeWithColor(str, styleType) {\n          var style = inspect.styles[styleType];\n          return style ? \"\u001b[\" + inspect.colors[style][0] + \"m\" + str + \"\u001b[\" + inspect.colors[style][1] + \"m\" : str;\n        }\n\n        function stylizeNoColor(str, styleType) {\n          return str;\n        }\n\n        function arrayToHash(array) {\n          var hash = {};\n          return array.forEach(function (val, idx) {\n            hash[val] = !0;\n          }), hash;\n        }\n\n        function formatValue(ctx, value, recurseTimes) {\n          if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && (!value.constructor || value.constructor.prototype !== value)) {\n            var ret = value.inspect(recurseTimes, ctx);\n            return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret;\n          }\n\n          var primitive = formatPrimitive(ctx, value);\n          if (primitive) return primitive;\n          var keys = Object.keys(value),\n              visibleKeys = arrayToHash(keys);\n          if (ctx.showHidden && (keys = Object.getOwnPropertyNames(value)), isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)) return formatError(value);\n\n          if (0 === keys.length) {\n            if (isFunction(value)) {\n              var name = value.name ? \": \" + value.name : \"\";\n              return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n            }\n\n            if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n            if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n            if (isError(value)) return formatError(value);\n          }\n\n          var base = \"\",\n              array = !1,\n              braces = [\"{\", \"}\"];\n\n          if (isArray(value) && (array = !0, braces = [\"[\", \"]\"]), isFunction(value)) {\n            var n = value.name ? \": \" + value.name : \"\";\n            base = \" [Function\" + n + \"]\";\n          }\n\n          if (isRegExp(value) && (base = \" \" + RegExp.prototype.toString.call(value)), isDate(value) && (base = \" \" + Date.prototype.toUTCString.call(value)), isError(value) && (base = \" \" + formatError(value)), 0 === keys.length && (!array || 0 == value.length)) return braces[0] + base + braces[1];\n          if (recurseTimes < 0) return isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\") : ctx.stylize(\"[Object]\", \"special\");\n          ctx.seen.push(value);\n          var output;\n          return output = array ? formatArray(ctx, value, recurseTimes, visibleKeys, keys) : keys.map(function (key) {\n            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n          }), ctx.seen.pop(), reduceToSingleString(output, base, braces);\n        }\n\n        function formatPrimitive(ctx, value) {\n          if (isUndefined(value)) return ctx.stylize(\"undefined\", \"undefined\");\n\n          if (isString(value)) {\n            var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n            return ctx.stylize(simple, \"string\");\n          }\n\n          return isNumber(value) ? ctx.stylize(\"\" + value, \"number\") : isBoolean(value) ? ctx.stylize(\"\" + value, \"boolean\") : isNull(value) ? ctx.stylize(\"null\", \"null\") : void 0;\n        }\n\n        function formatError(value) {\n          return \"[\" + Error.prototype.toString.call(value) + \"]\";\n        }\n\n        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n          for (var output = [], i = 0, l = value.length; i < l; ++i) {\n            hasOwnProperty(value, String(i)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0)) : output.push(\"\");\n          }\n\n          return keys.forEach(function (key) {\n            key.match(/^\\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));\n          }), output;\n        }\n\n        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n          var name, str, desc;\n\n          if (desc = Object.getOwnPropertyDescriptor(value, key) || {\n            value: value[key]\n          }, desc.get ? str = desc.set ? ctx.stylize(\"[Getter/Setter]\", \"special\") : ctx.stylize(\"[Getter]\", \"special\") : desc.set && (str = ctx.stylize(\"[Setter]\", \"special\")), hasOwnProperty(visibleKeys, key) || (name = \"[\" + key + \"]\"), str || (ctx.seen.indexOf(desc.value) < 0 ? (str = isNull(recurseTimes) ? formatValue(ctx, desc.value, null) : formatValue(ctx, desc.value, recurseTimes - 1), str.indexOf(\"\\n\") > -1 && (str = array ? str.split(\"\\n\").map(function (line) {\n            return \"  \" + line;\n          }).join(\"\\n\").substr(2) : \"\\n\" + str.split(\"\\n\").map(function (line) {\n            return \"   \" + line;\n          }).join(\"\\n\"))) : str = ctx.stylize(\"[Circular]\", \"special\")), isUndefined(name)) {\n            if (array && key.match(/^\\d+$/)) return str;\n            name = JSON.stringify(\"\" + key), name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/) ? (name = name.substr(1, name.length - 2), name = ctx.stylize(name, \"name\")) : (name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\"), name = ctx.stylize(name, \"string\"));\n          }\n\n          return name + \": \" + str;\n        }\n\n        function reduceToSingleString(output, base, braces) {\n          var numLinesEst = 0,\n              length = output.reduce(function (prev, cur) {\n            return numLinesEst++, cur.indexOf(\"\\n\") >= 0 && numLinesEst++, prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n          }, 0);\n          return length > 60 ? braces[0] + (\"\" === base ? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1] : braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n        }\n\n        function isArray(ar) {\n          return Array.isArray(ar);\n        }\n\n        function isBoolean(arg) {\n          return \"boolean\" == typeof arg;\n        }\n\n        function isNull(arg) {\n          return null === arg;\n        }\n\n        function isNullOrUndefined(arg) {\n          return null == arg;\n        }\n\n        function isNumber(arg) {\n          return \"number\" == typeof arg;\n        }\n\n        function isString(arg) {\n          return \"string\" == typeof arg;\n        }\n\n        function isSymbol(arg) {\n          return \"symbol\" == typeof arg;\n        }\n\n        function isUndefined(arg) {\n          return void 0 === arg;\n        }\n\n        function isRegExp(re) {\n          return isObject(re) && \"[object RegExp]\" === objectToString(re);\n        }\n\n        function isObject(arg) {\n          return \"object\" == typeof arg && null !== arg;\n        }\n\n        function isDate(d) {\n          return isObject(d) && \"[object Date]\" === objectToString(d);\n        }\n\n        function isError(e) {\n          return isObject(e) && (\"[object Error]\" === objectToString(e) || e instanceof Error);\n        }\n\n        function isFunction(arg) {\n          return \"function\" == typeof arg;\n        }\n\n        function isPrimitive(arg) {\n          return null === arg || \"boolean\" == typeof arg || \"number\" == typeof arg || \"string\" == typeof arg || \"symbol\" == typeof arg || \"undefined\" == typeof arg;\n        }\n\n        function objectToString(o) {\n          return Object.prototype.toString.call(o);\n        }\n\n        function pad(n) {\n          return n < 10 ? \"0\" + n.toString(10) : n.toString(10);\n        }\n\n        function timestamp() {\n          var d = new Date(),\n              time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(\":\");\n          return [d.getDate(), months[d.getMonth()], time].join(\" \");\n        }\n\n        function hasOwnProperty(obj, prop) {\n          return Object.prototype.hasOwnProperty.call(obj, prop);\n        }\n\n        var formatRegExp = /%[sdj%]/g;\n        exports.format = function (f) {\n          if (!isString(f)) {\n            for (var objects = [], i = 0; i < arguments.length; i++) {\n              objects.push(inspect(arguments[i]));\n            }\n\n            return objects.join(\" \");\n          }\n\n          for (var i = 1, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function (x) {\n            if (\"%%\" === x) return \"%\";\n            if (i >= len) return x;\n\n            switch (x) {\n              case \"%s\":\n                return String(args[i++]);\n\n              case \"%d\":\n                return Number(args[i++]);\n\n              case \"%j\":\n                try {\n                  return JSON.stringify(args[i++]);\n                } catch (_) {\n                  return \"[Circular]\";\n                }\n\n              default:\n                return x;\n            }\n          }), x = args[i]; i < len; x = args[++i]) {\n            str += isNull(x) || !isObject(x) ? \" \" + x : \" \" + inspect(x);\n          }\n\n          return str;\n        }, exports.deprecate = function (fn, msg) {\n          function deprecated() {\n            if (!warned) {\n              if (process.throwDeprecation) throw new Error(msg);\n              process.traceDeprecation ? console.trace(msg) : console.error(msg), warned = !0;\n            }\n\n            return fn.apply(this, arguments);\n          }\n\n          if (isUndefined(global.process)) return function () {\n            return exports.deprecate(fn, msg).apply(this, arguments);\n          };\n          if (process.noDeprecation === !0) return fn;\n          var warned = !1;\n          return deprecated;\n        };\n        var debugEnviron,\n            debugs = {};\n        exports.debuglog = function (set) {\n          if (isUndefined(debugEnviron) && (debugEnviron = process.env.NODE_DEBUG || \"\"), set = set.toUpperCase(), !debugs[set]) if (new RegExp(\"\\\\b\" + set + \"\\\\b\", \"i\").test(debugEnviron)) {\n            var pid = process.pid;\n\n            debugs[set] = function () {\n              var msg = exports.format.apply(exports, arguments);\n              console.error(\"%s %d: %s\", set, pid, msg);\n            };\n          } else debugs[set] = function () {};\n          return debugs[set];\n        }, exports.inspect = inspect, inspect.colors = {\n          bold: [1, 22],\n          italic: [3, 23],\n          underline: [4, 24],\n          inverse: [7, 27],\n          white: [37, 39],\n          grey: [90, 39],\n          black: [30, 39],\n          blue: [34, 39],\n          cyan: [36, 39],\n          green: [32, 39],\n          magenta: [35, 39],\n          red: [31, 39],\n          yellow: [33, 39]\n        }, inspect.styles = {\n          special: \"cyan\",\n          number: \"yellow\",\n          boolean: \"yellow\",\n          undefined: \"grey\",\n          null: \"bold\",\n          string: \"green\",\n          date: \"magenta\",\n          regexp: \"red\"\n        }, exports.isArray = isArray, exports.isBoolean = isBoolean, exports.isNull = isNull, exports.isNullOrUndefined = isNullOrUndefined, exports.isNumber = isNumber, exports.isString = isString, exports.isSymbol = isSymbol, exports.isUndefined = isUndefined, exports.isRegExp = isRegExp, exports.isObject = isObject, exports.isDate = isDate, exports.isError = isError, exports.isFunction = isFunction, exports.isPrimitive = isPrimitive, exports.isBuffer = require(\"./support/isBuffer\");\n        var months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n        exports.log = function () {\n          console.log(\"%s - %s\", timestamp(), exports.format.apply(exports, arguments));\n        }, exports.inherits = require(\"inherits\"), exports._extend = function (origin, add) {\n          if (!add || !isObject(add)) return origin;\n\n          for (var keys = Object.keys(add), i = keys.length; i--;) {\n            origin[keys[i]] = add[keys[i]];\n          }\n\n          return origin;\n        };\n      }).call(this, require(\"_process\"), \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {});\n    }, {\n      \"./support/isBuffer\": 5,\n      _process: 4,\n      inherits: 3\n    }],\n    7: [function (require, module, exports) {\n      \"use strict\";\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;\n        };\n      }(),\n          _require = require(\"./helpers.js\"),\n          createDataProperty = _require.createDataProperty;\n\n      module.exports = function () {\n        function ByteLengthQueuingStrategy(_ref) {\n          var highWaterMark = _ref.highWaterMark;\n          _classCallCheck(this, ByteLengthQueuingStrategy), createDataProperty(this, \"highWaterMark\", highWaterMark);\n        }\n\n        return _createClass(ByteLengthQueuingStrategy, [{\n          key: \"size\",\n          value: function value(chunk) {\n            return chunk.byteLength;\n          }\n        }]), ByteLengthQueuingStrategy;\n      }();\n    }, {\n      \"./helpers.js\": 9\n    }],\n    8: [function (require, module, exports) {\n      \"use strict\";\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;\n        };\n      }(),\n          _require = require(\"./helpers.js\"),\n          createDataProperty = _require.createDataProperty;\n\n      module.exports = function () {\n        function CountQueuingStrategy(_ref) {\n          var highWaterMark = _ref.highWaterMark;\n          _classCallCheck(this, CountQueuingStrategy), createDataProperty(this, \"highWaterMark\", highWaterMark);\n        }\n\n        return _createClass(CountQueuingStrategy, [{\n          key: \"size\",\n          value: function value(chunk) {\n            return 1;\n          }\n        }]), CountQueuingStrategy;\n      }();\n    }, {\n      \"./helpers.js\": 9\n    }],\n    9: [function (require, module, exports) {\n      \"use strict\";\n\n      var _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n      },\n          assert = require(\"assert\");\n\n      exports.promiseCall = function (func) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        try {\n          return Promise.resolve(func.apply(void 0, args));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }, exports.typeIsObject = function (x) {\n        return \"object\" === (\"undefined\" == typeof x ? \"undefined\" : _typeof(x)) && null !== x || \"function\" == typeof x;\n      }, exports.toInteger = function (v) {\n        return v = Number(v), isNaN(v) ? 0 : v < 0 ? -1 * Math.floor(Math.abs(v)) : Math.floor(Math.abs(v));\n      }, exports.createDataProperty = function (o, p, v) {\n        assert(exports.typeIsObject(o)), o[p] = v;\n      }, exports.createArrayFromList = function (elements) {\n        return elements.slice();\n      }, exports.ArrayBufferCopy = function (dest, destOffset, src, srcOffset, n) {\n        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n      }, exports.CreateIterResultObject = function (value, done) {\n        return assert(\"boolean\" == typeof done), {\n          value: value,\n          done: done\n        };\n      }, exports.IsFiniteNonNegativeNumber = function (v) {\n        return !Number.isNaN(v) && v !== +(1 / 0) && !(v < 0);\n      }, exports.InvokeOrNoop = function (O, P, args) {\n        var method = O[P];\n        if (void 0 !== method) return method.apply(O, args);\n      }, exports.PromiseInvokeOrNoop = function (O, P, args) {\n        var method = void 0;\n\n        try {\n          return method = O[P], void 0 === method ? Promise.resolve(void 0) : Promise.resolve(method.apply(O, args));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }, exports.PromiseInvokeOrFallbackOrNoop = function (O, P1, args1, P2, args2) {\n        var method = void 0;\n\n        try {\n          method = O[P1];\n        } catch (methodE) {\n          return Promise.reject(methodE);\n        }\n\n        if (void 0 === method) return exports.PromiseInvokeOrNoop(O, P2, args2);\n\n        try {\n          return Promise.resolve(method.apply(O, args1));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }, exports.SameRealmTransfer = function (O) {\n        return O;\n      }, exports.ValidateAndNormalizeHighWaterMark = function (highWaterMark) {\n        if (highWaterMark = Number(highWaterMark), Number.isNaN(highWaterMark) || highWaterMark < 0) throw new RangeError(\"highWaterMark property of a queuing strategy must be nonnegative and non-NaN\");\n        return highWaterMark;\n      }, exports.ValidateAndNormalizeQueuingStrategy = function (size, highWaterMark) {\n        if (void 0 !== size && \"function\" != typeof size) throw new TypeError(\"size property of a queuing strategy must be a function\");\n        return highWaterMark = exports.ValidateAndNormalizeHighWaterMark(highWaterMark), {\n          size: size,\n          highWaterMark: highWaterMark\n        };\n      };\n    }, {\n      assert: 2\n    }],\n    10: [function (require, module, exports) {\n      \"use strict\";\n\n      var assert = require(\"assert\"),\n          _require = require(\"./helpers.js\"),\n          IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber;\n\n      exports.DequeueValue = function (queue) {\n        assert(queue.length > 0, \"Spec-level failure: should never dequeue from an empty queue.\");\n        var pair = queue.shift();\n        return pair.value;\n      }, exports.EnqueueValueWithSize = function (queue, value, size) {\n        if (size = Number(size), !IsFiniteNonNegativeNumber(size)) throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n        queue.push({\n          value: value,\n          size: size\n        });\n      }, exports.GetTotalQueueSize = function (queue) {\n        var totalSize = 0;\n        return queue.forEach(function (pair) {\n          assert(\"number\" == typeof pair.size && !Number.isNaN(pair.size) && pair.size !== +(1 / 0) && pair.size !== -(1 / 0), \"Spec-level failure: should never find an invalid size in the queue.\"), totalSize += pair.size;\n        }), totalSize;\n      }, exports.PeekQueueValue = function (queue) {\n        assert(queue.length > 0, \"Spec-level failure: should never peek at an empty queue.\");\n        var pair = queue[0];\n        return pair.value;\n      };\n    }, {\n      \"./helpers.js\": 9,\n      assert: 2\n    }],\n    11: [function (require, module, exports) {\n      \"use strict\";\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      function AcquireReadableStreamBYOBReader(stream) {\n        return new ReadableStreamBYOBReader(stream);\n      }\n\n      function AcquireReadableStreamDefaultReader(stream) {\n        return new ReadableStreamDefaultReader(stream);\n      }\n\n      function IsReadableStream(x) {\n        return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, \"_readableStreamController\");\n      }\n\n      function IsReadableStreamDisturbed(stream) {\n        return assert(IsReadableStream(stream) === !0, \"IsReadableStreamDisturbed should only be used on known readable streams\"), stream._disturbed;\n      }\n\n      function IsReadableStreamLocked(stream) {\n        return assert(IsReadableStream(stream) === !0, \"IsReadableStreamLocked should only be used on known readable streams\"), void 0 !== stream._reader;\n      }\n\n      function ReadableStreamTee(stream, shouldClone) {\n        assert(IsReadableStream(stream) === !0), assert(\"boolean\" == typeof shouldClone);\n        var reader = AcquireReadableStreamDefaultReader(stream),\n            teeState = {\n          closedOrErrored: !1,\n          canceled1: !1,\n          canceled2: !1,\n          reason1: void 0,\n          reason2: void 0\n        };\n        teeState.promise = new Promise(function (resolve) {\n          return teeState._resolve = resolve;\n        });\n        var pull = create_ReadableStreamTeePullFunction();\n        pull._reader = reader, pull._teeState = teeState, pull._shouldClone = shouldClone;\n        var cancel1 = create_ReadableStreamTeeBranch1CancelFunction();\n        cancel1._stream = stream, cancel1._teeState = teeState;\n        var cancel2 = create_ReadableStreamTeeBranch2CancelFunction();\n        cancel2._stream = stream, cancel2._teeState = teeState;\n        var underlyingSource1 = Object.create(Object.prototype);\n        createDataProperty(underlyingSource1, \"pull\", pull), createDataProperty(underlyingSource1, \"cancel\", cancel1);\n        var branch1Stream = new ReadableStream(underlyingSource1),\n            underlyingSource2 = Object.create(Object.prototype);\n        createDataProperty(underlyingSource2, \"pull\", pull), createDataProperty(underlyingSource2, \"cancel\", cancel2);\n        var branch2Stream = new ReadableStream(underlyingSource2);\n        return pull._branch1 = branch1Stream._readableStreamController, pull._branch2 = branch2Stream._readableStreamController, reader._closedPromise.catch(function (r) {\n          teeState.closedOrErrored !== !0 && (ReadableStreamDefaultControllerError(pull._branch1, r), ReadableStreamDefaultControllerError(pull._branch2, r), teeState.closedOrErrored = !0);\n        }), [branch1Stream, branch2Stream];\n      }\n\n      function create_ReadableStreamTeePullFunction() {\n        var f = function f() {\n          var reader = f._reader,\n              branch1 = f._branch1,\n              branch2 = f._branch2,\n              teeState = f._teeState;\n          f._shouldClone;\n          return ReadableStreamDefaultReaderRead(reader).then(function (result) {\n            assert(typeIsObject(result));\n            var value = result.value,\n                done = result.done;\n\n            if (assert(\"boolean\" == typeof done), done === !0 && teeState.closedOrErrored === !1 && (teeState.canceled1 === !1 && ReadableStreamDefaultControllerClose(branch1), teeState.canceled2 === !1 && ReadableStreamDefaultControllerClose(branch2), teeState.closedOrErrored = !0), teeState.closedOrErrored !== !0) {\n              if (teeState.canceled1 === !1) {\n                var value1 = value;\n                ReadableStreamDefaultControllerEnqueue(branch1, value1);\n              }\n\n              if (teeState.canceled2 === !1) {\n                var value2 = value;\n                ReadableStreamDefaultControllerEnqueue(branch2, value2);\n              }\n            }\n          });\n        };\n\n        return f;\n      }\n\n      function create_ReadableStreamTeeBranch1CancelFunction() {\n        var f = function f(reason) {\n          var stream = f._stream,\n              teeState = f._teeState;\n\n          if (teeState.canceled1 = !0, teeState.reason1 = reason, teeState.canceled2 === !0) {\n            var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]),\n                cancelResult = ReadableStreamCancel(stream, compositeReason);\n\n            teeState._resolve(cancelResult);\n          }\n\n          return teeState.promise;\n        };\n\n        return f;\n      }\n\n      function create_ReadableStreamTeeBranch2CancelFunction() {\n        var f = function f(reason) {\n          var stream = f._stream,\n              teeState = f._teeState;\n\n          if (teeState.canceled2 = !0, teeState.reason2 = reason, teeState.canceled1 === !0) {\n            var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]),\n                cancelResult = ReadableStreamCancel(stream, compositeReason);\n\n            teeState._resolve(cancelResult);\n          }\n\n          return teeState.promise;\n        };\n\n        return f;\n      }\n\n      function ReadableStreamAddReadIntoRequest(stream) {\n        assert(IsReadableStreamBYOBReader(stream._reader) === !0), assert(\"readable\" === stream._state || \"closed\" === stream._state);\n        var promise = new Promise(function (resolve, reject) {\n          var readIntoRequest = {\n            _resolve: resolve,\n            _reject: reject\n          };\n\n          stream._reader._readIntoRequests.push(readIntoRequest);\n        });\n        return promise;\n      }\n\n      function ReadableStreamAddReadRequest(stream) {\n        assert(IsReadableStreamDefaultReader(stream._reader) === !0), assert(\"readable\" === stream._state);\n        var promise = new Promise(function (resolve, reject) {\n          var readRequest = {\n            _resolve: resolve,\n            _reject: reject\n          };\n\n          stream._reader._readRequests.push(readRequest);\n        });\n        return promise;\n      }\n\n      function ReadableStreamCancel(stream, reason) {\n        if (stream._disturbed = !0, \"closed\" === stream._state) return Promise.resolve(void 0);\n        if (\"errored\" === stream._state) return Promise.reject(stream._storedError);\n        ReadableStreamClose(stream);\n\n        var sourceCancelPromise = stream._readableStreamController[InternalCancel](reason);\n\n        return sourceCancelPromise.then(function () {});\n      }\n\n      function ReadableStreamClose(stream) {\n        assert(\"readable\" === stream._state), stream._state = \"closed\";\n        var reader = stream._reader;\n\n        if (void 0 !== reader) {\n          if (IsReadableStreamDefaultReader(reader) === !0) {\n            var _iteratorNormalCompletion = !0,\n                _didIteratorError = !1,\n                _iteratorError = void 0;\n\n            try {\n              for (var _step, _iterator = reader._readRequests[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {\n                var _resolve = _step.value._resolve;\n\n                _resolve(CreateIterResultObject(void 0, !0));\n              }\n            } catch (err) {\n              _didIteratorError = !0, _iteratorError = err;\n            } finally {\n              try {\n                !_iteratorNormalCompletion && _iterator.return && _iterator.return();\n              } finally {\n                if (_didIteratorError) throw _iteratorError;\n              }\n            }\n\n            reader._readRequests = [];\n          }\n\n          reader._closedPromise_resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0;\n        }\n      }\n\n      function ReadableStreamError(stream, e) {\n        assert(IsReadableStream(stream) === !0, \"stream must be ReadableStream\"), assert(\"readable\" === stream._state, \"state must be readable\"), stream._state = \"errored\", stream._storedError = e;\n        var reader = stream._reader;\n\n        if (void 0 !== reader) {\n          if (IsReadableStreamDefaultReader(reader) === !0) {\n            var _iteratorNormalCompletion2 = !0,\n                _didIteratorError2 = !1,\n                _iteratorError2 = void 0;\n\n            try {\n              for (var _step2, _iterator2 = reader._readRequests[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {\n                var readRequest = _step2.value;\n\n                readRequest._reject(e);\n              }\n            } catch (err) {\n              _didIteratorError2 = !0, _iteratorError2 = err;\n            } finally {\n              try {\n                !_iteratorNormalCompletion2 && _iterator2.return && _iterator2.return();\n              } finally {\n                if (_didIteratorError2) throw _iteratorError2;\n              }\n            }\n\n            reader._readRequests = [];\n          } else {\n            assert(IsReadableStreamBYOBReader(reader), \"reader must be ReadableStreamBYOBReader\");\n\n            var _iteratorNormalCompletion3 = !0,\n                _didIteratorError3 = !1,\n                _iteratorError3 = void 0;\n\n            try {\n              for (var _step3, _iterator3 = reader._readIntoRequests[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {\n                var readIntoRequest = _step3.value;\n\n                readIntoRequest._reject(e);\n              }\n            } catch (err) {\n              _didIteratorError3 = !0, _iteratorError3 = err;\n            } finally {\n              try {\n                !_iteratorNormalCompletion3 && _iterator3.return && _iterator3.return();\n              } finally {\n                if (_didIteratorError3) throw _iteratorError3;\n              }\n            }\n\n            reader._readIntoRequests = [];\n          }\n\n          reader._closedPromise_reject(e), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0;\n        }\n      }\n\n      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n        var reader = stream._reader;\n        assert(reader._readIntoRequests.length > 0);\n\n        var readIntoRequest = reader._readIntoRequests.shift();\n\n        readIntoRequest._resolve(CreateIterResultObject(chunk, done));\n      }\n\n      function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n        var reader = stream._reader;\n        assert(reader._readRequests.length > 0);\n\n        var readRequest = reader._readRequests.shift();\n\n        readRequest._resolve(CreateIterResultObject(chunk, done));\n      }\n\n      function ReadableStreamGetNumReadIntoRequests(stream) {\n        return stream._reader._readIntoRequests.length;\n      }\n\n      function ReadableStreamGetNumReadRequests(stream) {\n        return stream._reader._readRequests.length;\n      }\n\n      function ReadableStreamHasBYOBReader(stream) {\n        var reader = stream._reader;\n        return void 0 !== reader && IsReadableStreamBYOBReader(reader) !== !1;\n      }\n\n      function ReadableStreamHasDefaultReader(stream) {\n        var reader = stream._reader;\n        return void 0 !== reader && IsReadableStreamDefaultReader(reader) !== !1;\n      }\n\n      function IsReadableStreamBYOBReader(x) {\n        return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, \"_readIntoRequests\");\n      }\n\n      function IsReadableStreamDefaultReader(x) {\n        return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, \"_readRequests\");\n      }\n\n      function ReadableStreamReaderGenericInitialize(reader, stream) {\n        reader._ownerReadableStream = stream, stream._reader = reader, \"readable\" === stream._state ? reader._closedPromise = new Promise(function (resolve, reject) {\n          reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;\n        }) : \"closed\" === stream._state ? (reader._closedPromise = Promise.resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0) : (assert(\"errored\" === stream._state, \"state must be errored\"), reader._closedPromise = Promise.reject(stream._storedError), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);\n      }\n\n      function ReadableStreamReaderGenericCancel(reader, reason) {\n        var stream = reader._ownerReadableStream;\n        return assert(void 0 !== stream), ReadableStreamCancel(stream, reason);\n      }\n\n      function ReadableStreamReaderGenericRelease(reader) {\n        assert(void 0 !== reader._ownerReadableStream), assert(reader._ownerReadableStream._reader === reader), \"readable\" === reader._ownerReadableStream._state ? reader._closedPromise_reject(new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")) : reader._closedPromise = Promise.reject(new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")), reader._ownerReadableStream._reader = void 0, reader._ownerReadableStream = void 0;\n      }\n\n      function ReadableStreamBYOBReaderRead(reader, view) {\n        var stream = reader._ownerReadableStream;\n        return assert(void 0 !== stream), stream._disturbed = !0, \"errored\" === stream._state ? Promise.reject(stream._storedError) : ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\n      }\n\n      function ReadableStreamDefaultReaderRead(reader) {\n        var stream = reader._ownerReadableStream;\n        return assert(void 0 !== stream), stream._disturbed = !0, \"closed\" === stream._state ? Promise.resolve(CreateIterResultObject(void 0, !0)) : \"errored\" === stream._state ? Promise.reject(stream._storedError) : (assert(\"readable\" === stream._state), stream._readableStreamController[InternalPull]());\n      }\n\n      function IsReadableStreamDefaultController(x) {\n        return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, \"_underlyingSource\");\n      }\n\n      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n\n        if (shouldPull !== !1) {\n          if (controller._pulling === !0) return void (controller._pullAgain = !0);\n          controller._pulling = !0;\n          var pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, \"pull\", [controller]);\n          pullPromise.then(function () {\n            if (controller._pulling = !1, controller._pullAgain === !0) return controller._pullAgain = !1, ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n          }, function (e) {\n            if (\"readable\" === controller._controlledReadableStream._state) return ReadableStreamDefaultControllerError(controller, e);\n          }).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function ReadableStreamDefaultControllerShouldCallPull(controller) {\n        var stream = controller._controlledReadableStream;\n        if (\"closed\" === stream._state || \"errored\" === stream._state) return !1;\n        if (controller._closeRequested === !0) return !1;\n        if (controller._started === !1) return !1;\n        if (IsReadableStreamLocked(stream) === !0 && ReadableStreamGetNumReadRequests(stream) > 0) return !0;\n        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n        return desiredSize > 0;\n      }\n\n      function ReadableStreamDefaultControllerClose(controller) {\n        var stream = controller._controlledReadableStream;\n        assert(controller._closeRequested === !1), assert(\"readable\" === stream._state), controller._closeRequested = !0, 0 === controller._queue.length && ReadableStreamClose(stream);\n      }\n\n      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n        var stream = controller._controlledReadableStream;\n        if (assert(controller._closeRequested === !1), assert(\"readable\" === stream._state), IsReadableStreamLocked(stream) === !0 && ReadableStreamGetNumReadRequests(stream) > 0) ReadableStreamFulfillReadRequest(stream, chunk, !1);else {\n          var chunkSize = 1;\n          if (void 0 !== controller._strategySize) try {\n            chunkSize = controller._strategySize(chunk);\n          } catch (chunkSizeE) {\n            throw \"readable\" === stream._state && ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;\n          }\n\n          try {\n            EnqueueValueWithSize(controller._queue, chunk, chunkSize);\n          } catch (enqueueE) {\n            throw \"readable\" === stream._state && ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;\n          }\n        }\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n\n      function ReadableStreamDefaultControllerError(controller, e) {\n        var stream = controller._controlledReadableStream;\n        assert(\"readable\" === stream._state), controller._queue = [], ReadableStreamError(stream, e);\n      }\n\n      function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n        var queueSize = GetTotalQueueSize(controller._queue);\n        return controller._strategyHWM - queueSize;\n      }\n\n      function IsReadableByteStreamController(x) {\n        return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, \"_underlyingByteSource\");\n      }\n\n      function IsReadableStreamBYOBRequest(x) {\n        return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, \"_associatedReadableByteStreamController\");\n      }\n\n      function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n\n        if (shouldPull !== !1) {\n          if (controller._pulling === !0) return void (controller._pullAgain = !0);\n          controller._pullAgain = !1, controller._pulling = !0;\n          var pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, \"pull\", [controller]);\n          pullPromise.then(function () {\n            controller._pulling = !1, controller._pullAgain === !0 && (controller._pullAgain = !1, ReadableByteStreamControllerCallPullIfNeeded(controller));\n          }, function (e) {\n            \"readable\" === controller._controlledReadableStream._state && ReadableByteStreamControllerError(controller, e);\n          }).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = [];\n      }\n\n      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n        assert(\"errored\" !== stream._state, \"state must not be errored\");\n        var done = !1;\n        \"closed\" === stream._state && (assert(0 === pullIntoDescriptor.bytesFilled), done = !0);\n        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n        \"default\" === pullIntoDescriptor.readerType ? ReadableStreamFulfillReadRequest(stream, filledView, done) : (assert(\"byob\" === pullIntoDescriptor.readerType), ReadableStreamFulfillReadIntoRequest(stream, filledView, done));\n      }\n\n      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n        var bytesFilled = pullIntoDescriptor.bytesFilled,\n            elementSize = pullIntoDescriptor.elementSize;\n        return assert(bytesFilled <= pullIntoDescriptor.byteLength), assert(bytesFilled % elementSize === 0), new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n      }\n\n      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        controller._queue.push({\n          buffer: buffer,\n          byteOffset: byteOffset,\n          byteLength: byteLength\n        }), controller._totalQueuedBytes += byteLength;\n      }\n\n      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n        var elementSize = pullIntoDescriptor.elementSize,\n            currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize,\n            maxBytesToCopy = Math.min(controller._totalQueuedBytes, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled),\n            maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy,\n            maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize,\n            totalBytesToCopyRemaining = maxBytesToCopy,\n            ready = !1;\n        maxAlignedBytes > currentAlignedBytes && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, ready = !0);\n\n        for (var queue = controller._queue; totalBytesToCopyRemaining > 0;) {\n          var headOfQueue = queue[0],\n              bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength),\n              destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n          ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, headOfQueue.byteLength -= bytesToCopy), controller._totalQueuedBytes -= bytesToCopy, ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor), totalBytesToCopyRemaining -= bytesToCopy;\n        }\n\n        return ready === !1 && (assert(0 === controller._totalQueuedBytes, \"queue must be empty\"), assert(pullIntoDescriptor.bytesFilled > 0), assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)), ready;\n      }\n\n      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n        assert(0 === controller._pendingPullIntos.length || controller._pendingPullIntos[0] === pullIntoDescriptor), ReadableByteStreamControllerInvalidateBYOBRequest(controller), pullIntoDescriptor.bytesFilled += size;\n      }\n\n      function ReadableByteStreamControllerHandleQueueDrain(controller) {\n        assert(\"readable\" === controller._controlledReadableStream._state), 0 === controller._totalQueuedBytes && controller._closeRequested === !0 ? ReadableStreamClose(controller._controlledReadableStream) : ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n\n      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n        void 0 !== controller._byobRequest && (controller._byobRequest._associatedReadableByteStreamController = void 0, controller._byobRequest._view = void 0, controller._byobRequest = void 0);\n      }\n\n      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n        for (assert(controller._closeRequested === !1); controller._pendingPullIntos.length > 0;) {\n          if (0 === controller._totalQueuedBytes) return;\n          var pullIntoDescriptor = controller._pendingPullIntos[0];\n          ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === !0 && (ReadableByteStreamControllerShiftPendingPullInto(controller), ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor));\n        }\n      }\n\n      function ReadableByteStreamControllerPullInto(controller, view) {\n        var stream = controller._controlledReadableStream,\n            elementSize = 1;\n        view.constructor !== DataView && (elementSize = view.constructor.BYTES_PER_ELEMENT);\n        var ctor = view.constructor,\n            pullIntoDescriptor = {\n          buffer: view.buffer,\n          byteOffset: view.byteOffset,\n          byteLength: view.byteLength,\n          bytesFilled: 0,\n          elementSize: elementSize,\n          ctor: ctor,\n          readerType: \"byob\"\n        };\n        if (controller._pendingPullIntos.length > 0) return pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer), controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream);\n\n        if (\"closed\" === stream._state) {\n          var emptyView = new view.constructor(view.buffer, view.byteOffset, 0);\n          return Promise.resolve(CreateIterResultObject(emptyView, !0));\n        }\n\n        if (controller._totalQueuedBytes > 0) {\n          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === !0) {\n            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            return ReadableByteStreamControllerHandleQueueDrain(controller), Promise.resolve(CreateIterResultObject(filledView, !1));\n          }\n\n          if (controller._closeRequested === !0) {\n            var e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n            return ReadableByteStreamControllerError(controller, e), Promise.reject(e);\n          }\n        }\n\n        pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer), controller._pendingPullIntos.push(pullIntoDescriptor);\n        var promise = ReadableStreamAddReadIntoRequest(stream);\n        return ReadableByteStreamControllerCallPullIfNeeded(controller), promise;\n      }\n\n      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n        firstDescriptor.buffer = SameRealmTransfer(firstDescriptor.buffer), assert(0 === firstDescriptor.bytesFilled, \"bytesFilled must be 0\");\n\n        for (var stream = controller._controlledReadableStream; ReadableStreamGetNumReadIntoRequests(stream) > 0;) {\n          var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n          ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n        }\n      }\n\n      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n        if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) throw new RangeError(\"bytesWritten out of range\");\n\n        if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor), !(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)) {\n          ReadableByteStreamControllerShiftPendingPullInto(controller);\n          var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n\n          if (remainderSize > 0) {\n            var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled,\n                remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n          }\n\n          pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer), pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n        }\n      }\n\n      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n        var firstDescriptor = controller._pendingPullIntos[0],\n            stream = controller._controlledReadableStream;\n\n        if (\"closed\" === stream._state) {\n          if (0 !== bytesWritten) throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n          ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n        } else assert(\"readable\" === stream._state), ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n      }\n\n      function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n        var descriptor = controller._pendingPullIntos.shift();\n\n        return ReadableByteStreamControllerInvalidateBYOBRequest(controller), descriptor;\n      }\n\n      function ReadableByteStreamControllerShouldCallPull(controller) {\n        var stream = controller._controlledReadableStream;\n        return \"readable\" === stream._state && controller._closeRequested !== !0 && controller._started !== !1 && (!!(ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) || !!(ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) || ReadableByteStreamControllerGetDesiredSize(controller) > 0);\n      }\n\n      function ReadableByteStreamControllerClose(controller) {\n        var stream = controller._controlledReadableStream;\n        if (assert(controller._closeRequested === !1), assert(\"readable\" === stream._state), controller._totalQueuedBytes > 0) return void (controller._closeRequested = !0);\n\n        if (controller._pendingPullIntos.length > 0) {\n          var firstPendingPullInto = controller._pendingPullIntos[0];\n\n          if (firstPendingPullInto.bytesFilled > 0) {\n            var e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n            throw ReadableByteStreamControllerError(controller, e), e;\n          }\n        }\n\n        ReadableStreamClose(stream);\n      }\n\n      function ReadableByteStreamControllerEnqueue(controller, chunk) {\n        var stream = controller._controlledReadableStream;\n        assert(controller._closeRequested === !1), assert(\"readable\" === stream._state);\n        var buffer = chunk.buffer,\n            byteOffset = chunk.byteOffset,\n            byteLength = chunk.byteLength,\n            transferredBuffer = SameRealmTransfer(buffer);\n        if (ReadableStreamHasDefaultReader(stream) === !0) {\n          if (0 === ReadableStreamGetNumReadRequests(stream)) ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);else {\n            assert(0 === controller._queue.length);\n            var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, !1);\n          }\n        } else ReadableStreamHasBYOBReader(stream) === !0 ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : (assert(IsReadableStreamLocked(stream) === !1, \"stream must not be locked\"), ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength));\n      }\n\n      function ReadableByteStreamControllerError(controller, e) {\n        var stream = controller._controlledReadableStream;\n        assert(\"readable\" === stream._state), ReadableByteStreamControllerClearPendingPullIntos(controller), controller._queue = [], ReadableStreamError(stream, e);\n      }\n\n      function ReadableByteStreamControllerGetDesiredSize(controller) {\n        return controller._strategyHWM - controller._totalQueuedBytes;\n      }\n\n      function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n        if (bytesWritten = Number(bytesWritten), IsFiniteNonNegativeNumber(bytesWritten) === !1) throw new RangeError(\"bytesWritten must be a finite\");\n        assert(controller._pendingPullIntos.length > 0), ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n      }\n\n      function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n        assert(controller._pendingPullIntos.length > 0);\n        var firstDescriptor = controller._pendingPullIntos[0];\n        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) throw new RangeError(\"The region specified by view does not match byobRequest\");\n        if (firstDescriptor.byteLength !== view.byteLength) throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n        firstDescriptor.buffer = view.buffer, ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n      }\n\n      var _slicedToArray = function () {\n        function sliceIterator(arr, i) {\n          var _arr = [],\n              _n = !0,\n              _d = !1,\n              _e = void 0;\n\n          try {\n            for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i || _arr.length !== i); _n = !0) {\n              ;\n            }\n          } catch (err) {\n            _d = !0, _e = err;\n          } finally {\n            try {\n              !_n && _i.return && _i.return();\n            } finally {\n              if (_d) throw _e;\n            }\n          }\n\n          return _arr;\n        }\n\n        return function (arr, i) {\n          if (Array.isArray(arr)) return arr;\n          if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);\n          throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n        };\n      }(),\n          _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;\n        };\n      }(),\n          assert = require(\"assert\"),\n          _require = require(\"./helpers.js\"),\n          ArrayBufferCopy = _require.ArrayBufferCopy,\n          CreateIterResultObject = _require.CreateIterResultObject,\n          IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber,\n          InvokeOrNoop = _require.InvokeOrNoop,\n          PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop,\n          SameRealmTransfer = _require.SameRealmTransfer,\n          ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy,\n          ValidateAndNormalizeHighWaterMark = _require.ValidateAndNormalizeHighWaterMark,\n          _require2 = require(\"./helpers.js\"),\n          createArrayFromList = _require2.createArrayFromList,\n          createDataProperty = _require2.createDataProperty,\n          typeIsObject = _require2.typeIsObject,\n          _require3 = require(\"./utils.js\"),\n          rethrowAssertionErrorRejection = _require3.rethrowAssertionErrorRejection,\n          _require4 = require(\"./queue-with-sizes.js\"),\n          DequeueValue = _require4.DequeueValue,\n          EnqueueValueWithSize = _require4.EnqueueValueWithSize,\n          GetTotalQueueSize = _require4.GetTotalQueueSize,\n          InternalCancel = Symbol(\"[[Cancel]]\"),\n          InternalPull = Symbol(\"[[Pull]]\"),\n          ReadableStream = function () {\n        function ReadableStream() {\n          var underlyingSource = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],\n              _ref = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],\n              size = _ref.size,\n              highWaterMark = _ref.highWaterMark;\n\n          _classCallCheck(this, ReadableStream), this._state = \"readable\", this._reader = void 0, this._storedError = void 0, this._disturbed = !1, this._readableStreamController = void 0;\n          var type = underlyingSource.type,\n              typeString = String(type);\n          if (\"bytes\" === typeString) void 0 === highWaterMark && (highWaterMark = 0), this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);else {\n            if (void 0 !== type) throw new RangeError(\"Invalid type is specified\");\n            void 0 === highWaterMark && (highWaterMark = 1), this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark);\n          }\n        }\n\n        return _createClass(ReadableStream, [{\n          key: \"cancel\",\n          value: function value(reason) {\n            return IsReadableStream(this) === !1 ? Promise.reject(new TypeError(\"ReadableStream.prototype.cancel can only be used on a ReadableStream\")) : IsReadableStreamLocked(this) === !0 ? Promise.reject(new TypeError(\"Cannot cancel a stream that already has a reader\")) : ReadableStreamCancel(this, reason);\n          }\n        }, {\n          key: \"getReader\",\n          value: function value() {\n            var _ref2 = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],\n                mode = _ref2.mode;\n\n            if (IsReadableStream(this) === !1) throw new TypeError(\"ReadableStream.prototype.getReader can only be used on a ReadableStream\");\n\n            if (\"byob\" === mode) {\n              if (IsReadableByteStreamController(this._readableStreamController) === !1) throw new TypeError(\"Cannot get a ReadableStreamBYOBReader for a stream not constructed with a byte source\");\n              return AcquireReadableStreamBYOBReader(this);\n            }\n\n            if (void 0 === mode) return AcquireReadableStreamDefaultReader(this);\n            throw new RangeError(\"Invalid mode is specified\");\n          }\n        }, {\n          key: \"pipeThrough\",\n          value: function value(_ref3, options) {\n            var writable = _ref3.writable,\n                readable = _ref3.readable;\n            return this.pipeTo(writable, options), readable;\n          }\n        }, {\n          key: \"pipeTo\",\n          value: function value(dest) {\n            function doPipe() {\n              lastRead = reader.read(), Promise.all([lastRead, dest.ready]).then(function (_ref5) {\n                var _ref6 = _slicedToArray(_ref5, 1),\n                    _ref6$ = _ref6[0],\n                    value = _ref6$.value,\n                    done = _ref6$.done;\n\n                Boolean(done) === !0 ? closeDest() : \"writable\" === dest.state && (lastWrite = dest.write(value), doPipe());\n              }).catch(rethrowAssertionErrorRejection);\n            }\n\n            function cancelSource(reason) {\n              preventCancel === !1 ? (reader.cancel(reason), reader.releaseLock(), rejectPipeToPromise(reason)) : lastRead.then(function () {\n                reader.releaseLock(), rejectPipeToPromise(reason);\n              });\n            }\n\n            function closeDest() {\n              reader.releaseLock();\n              var destState = dest.state;\n              preventClose !== !1 || \"waiting\" !== destState && \"writable\" !== destState ? void 0 !== lastWrite ? lastWrite.then(resolvePipeToPromise, rejectPipeToPromise) : resolvePipeToPromise() : (closedPurposefully = !0, dest.close().then(resolvePipeToPromise, rejectPipeToPromise));\n            }\n\n            function abortDest(reason) {\n              reader.releaseLock(), preventAbort === !1 && dest.abort(reason), rejectPipeToPromise(reason);\n            }\n\n            var _ref4 = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],\n                preventClose = _ref4.preventClose,\n                preventAbort = _ref4.preventAbort,\n                preventCancel = _ref4.preventCancel;\n\n            preventClose = Boolean(preventClose), preventAbort = Boolean(preventAbort), preventCancel = Boolean(preventCancel);\n            var source = this,\n                reader = void 0,\n                lastRead = void 0,\n                lastWrite = void 0,\n                closedPurposefully = !1,\n                resolvePipeToPromise = void 0,\n                rejectPipeToPromise = void 0;\n            return new Promise(function (resolve, reject) {\n              resolvePipeToPromise = resolve, rejectPipeToPromise = reject, reader = source.getReader(), reader.closed.catch(abortDest), dest.closed.then(function () {\n                closedPurposefully || cancelSource(new TypeError(\"destination is closing or closed and cannot be piped to anymore\"));\n              }, cancelSource), doPipe();\n            });\n          }\n        }, {\n          key: \"tee\",\n          value: function value() {\n            if (IsReadableStream(this) === !1) throw new TypeError(\"ReadableStream.prototype.tee can only be used on a ReadableStream\");\n            var branches = ReadableStreamTee(this, !1);\n            return createArrayFromList(branches);\n          }\n        }, {\n          key: \"locked\",\n          get: function get() {\n            if (IsReadableStream(this) === !1) throw new TypeError(\"ReadableStream.prototype.locked can only be used on a ReadableStream\");\n            return IsReadableStreamLocked(this);\n          }\n        }]), ReadableStream;\n      }();\n\n      exports.ReadableStream = ReadableStream, exports.IsReadableStreamDisturbed = IsReadableStreamDisturbed;\n\n      var ReadableStreamDefaultReader = function () {\n        function ReadableStreamDefaultReader(stream) {\n          if (_classCallCheck(this, ReadableStreamDefaultReader), IsReadableStream(stream) === !1) throw new TypeError(\"ReadableStreamDefaultReader can only be constructed with a ReadableStream instance\");\n          if (IsReadableStreamLocked(stream) === !0) throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n          ReadableStreamReaderGenericInitialize(this, stream), this._readRequests = [];\n        }\n\n        return _createClass(ReadableStreamDefaultReader, [{\n          key: \"cancel\",\n          value: function value(reason) {\n            return IsReadableStreamDefaultReader(this) === !1 ? Promise.reject(new TypeError(\"ReadableStreamDefaultReader.prototype.cancel can only be used on a ReadableStreamDefaultReader\")) : void 0 === this._ownerReadableStream ? Promise.reject(new TypeError(\"Cannot cancel a stream using a released reader\")) : ReadableStreamReaderGenericCancel(this, reason);\n          }\n        }, {\n          key: \"read\",\n          value: function value() {\n            return IsReadableStreamDefaultReader(this) === !1 ? Promise.reject(new TypeError(\"ReadableStreamDefaultReader.prototype.read can only be used on a ReadableStreamDefaultReader\")) : void 0 === this._ownerReadableStream ? Promise.reject(new TypeError(\"Cannot read from a released reader\")) : ReadableStreamDefaultReaderRead(this);\n          }\n        }, {\n          key: \"releaseLock\",\n          value: function value() {\n            if (IsReadableStreamDefaultReader(this) === !1) throw new TypeError(\"ReadableStreamDefaultReader.prototype.releaseLock can only be used on a ReadableStreamDefaultReader\");\n\n            if (void 0 !== this._ownerReadableStream) {\n              if (this._readRequests.length > 0) throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n              ReadableStreamReaderGenericRelease(this);\n            }\n          }\n        }, {\n          key: \"closed\",\n          get: function get() {\n            return IsReadableStreamDefaultReader(this) === !1 ? Promise.reject(new TypeError(\"ReadableStreamDefaultReader.prototype.closed can only be used on a ReadableStreamDefaultReader\")) : this._closedPromise;\n          }\n        }]), ReadableStreamDefaultReader;\n      }(),\n          ReadableStreamBYOBReader = function () {\n        function ReadableStreamBYOBReader(stream) {\n          if (_classCallCheck(this, ReadableStreamBYOBReader), !IsReadableStream(stream)) throw new TypeError(\"ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source\");\n          if (IsReadableStreamLocked(stream)) throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n          ReadableStreamReaderGenericInitialize(this, stream), this._readIntoRequests = [];\n        }\n\n        return _createClass(ReadableStreamBYOBReader, [{\n          key: \"cancel\",\n          value: function value(reason) {\n            return IsReadableStreamBYOBReader(this) ? void 0 === this._ownerReadableStream ? Promise.reject(new TypeError(\"Cannot cancel a stream using a released reader\")) : ReadableStreamReaderGenericCancel(this, reason) : Promise.reject(new TypeError(\"ReadableStreamBYOBReader.prototype.cancel can only be used on a ReadableStreamBYOBReader\"));\n          }\n        }, {\n          key: \"read\",\n          value: function value(view) {\n            return IsReadableStreamBYOBReader(this) ? void 0 === this._ownerReadableStream ? Promise.reject(new TypeError(\"Cannot read from a released reader\")) : ArrayBuffer.isView(view) ? 0 === view.byteLength ? Promise.reject(new TypeError(\"view must have non-zero byteLength\")) : ReadableStreamBYOBReaderRead(this, view) : Promise.reject(new TypeError(\"view must be an array buffer view\")) : Promise.reject(new TypeError(\"ReadableStreamBYOBReader.prototype.read can only be used on a ReadableStreamBYOBReader\"));\n          }\n        }, {\n          key: \"releaseLock\",\n          value: function value() {\n            if (!IsReadableStreamBYOBReader(this)) throw new TypeError(\"ReadableStreamBYOBReader.prototype.releaseLock can only be used on a ReadableStreamBYOBReader\");\n\n            if (void 0 !== this._ownerReadableStream) {\n              if (this._readIntoRequests.length > 0) throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n              ReadableStreamReaderGenericRelease(this);\n            }\n          }\n        }, {\n          key: \"closed\",\n          get: function get() {\n            return IsReadableStreamBYOBReader(this) ? this._closedPromise : Promise.reject(new TypeError(\"ReadableStreamBYOBReader.prototype.closed can only be used on a ReadableStreamBYOBReader\"));\n          }\n        }]), ReadableStreamBYOBReader;\n      }(),\n          ReadableStreamDefaultController = function () {\n        function ReadableStreamDefaultController(stream, underlyingSource, size, highWaterMark) {\n          if (_classCallCheck(this, ReadableStreamDefaultController), IsReadableStream(stream) === !1) throw new TypeError(\"ReadableStreamDefaultController can only be constructed with a ReadableStream instance\");\n          if (void 0 !== stream._readableStreamController) throw new TypeError(\"ReadableStreamDefaultController instances can only be created by the ReadableStream constructor\");\n          this._controlledReadableStream = stream, this._underlyingSource = underlyingSource, this._queue = [], this._started = !1, this._closeRequested = !1, this._pullAgain = !1, this._pulling = !1;\n          var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);\n          this._strategySize = normalizedStrategy.size, this._strategyHWM = normalizedStrategy.highWaterMark;\n          var controller = this,\n              startResult = InvokeOrNoop(underlyingSource, \"start\", [this]);\n          Promise.resolve(startResult).then(function () {\n            controller._started = !0, ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n          }, function (r) {\n            \"readable\" === stream._state && ReadableStreamDefaultControllerError(controller, r);\n          }).catch(rethrowAssertionErrorRejection);\n        }\n\n        return _createClass(ReadableStreamDefaultController, [{\n          key: \"close\",\n          value: function value() {\n            if (IsReadableStreamDefaultController(this) === !1) throw new TypeError(\"ReadableStreamDefaultController.prototype.close can only be used on a ReadableStreamDefaultController\");\n            if (this._closeRequested === !0) throw new TypeError(\"The stream has already been closed; do not close it again!\");\n            var state = this._controlledReadableStream._state;\n            if (\"readable\" !== state) throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be closed\");\n            ReadableStreamDefaultControllerClose(this);\n          }\n        }, {\n          key: \"enqueue\",\n          value: function value(chunk) {\n            if (IsReadableStreamDefaultController(this) === !1) throw new TypeError(\"ReadableStreamDefaultController.prototype.enqueue can only be used on a ReadableStreamDefaultController\");\n            if (this._closeRequested === !0) throw new TypeError(\"stream is closed or draining\");\n            var state = this._controlledReadableStream._state;\n            if (\"readable\" !== state) throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be enqueued to\");\n            return ReadableStreamDefaultControllerEnqueue(this, chunk);\n          }\n        }, {\n          key: \"error\",\n          value: function value(e) {\n            if (IsReadableStreamDefaultController(this) === !1) throw new TypeError(\"ReadableStreamDefaultController.prototype.error can only be used on a ReadableStreamDefaultController\");\n            var stream = this._controlledReadableStream;\n            if (\"readable\" !== stream._state) throw new TypeError(\"The stream is \" + stream._state + \" and so cannot be errored\");\n            ReadableStreamDefaultControllerError(this, e);\n          }\n        }, {\n          key: InternalCancel,\n          value: function value(reason) {\n            return this._queue = [], PromiseInvokeOrNoop(this._underlyingSource, \"cancel\", [reason]);\n          }\n        }, {\n          key: InternalPull,\n          value: function value() {\n            var stream = this._controlledReadableStream;\n\n            if (this._queue.length > 0) {\n              var chunk = DequeueValue(this._queue);\n              return this._closeRequested === !0 && 0 === this._queue.length ? ReadableStreamClose(stream) : ReadableStreamDefaultControllerCallPullIfNeeded(this), Promise.resolve(CreateIterResultObject(chunk, !1));\n            }\n\n            var pendingPromise = ReadableStreamAddReadRequest(stream);\n            return ReadableStreamDefaultControllerCallPullIfNeeded(this), pendingPromise;\n          }\n        }, {\n          key: \"desiredSize\",\n          get: function get() {\n            if (IsReadableStreamDefaultController(this) === !1) throw new TypeError(\"ReadableStreamDefaultController.prototype.desiredSize can only be used on a ReadableStreamDefaultController\");\n            return ReadableStreamDefaultControllerGetDesiredSize(this);\n          }\n        }]), ReadableStreamDefaultController;\n      }(),\n          ReadableStreamBYOBRequest = function () {\n        function ReadableStreamBYOBRequest(controller, view) {\n          _classCallCheck(this, ReadableStreamBYOBRequest), this._associatedReadableByteStreamController = controller, this._view = view;\n        }\n\n        return _createClass(ReadableStreamBYOBRequest, [{\n          key: \"respond\",\n          value: function value(bytesWritten) {\n            if (IsReadableStreamBYOBRequest(this) === !1) throw new TypeError(\"ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController\");\n            if (void 0 === this._associatedReadableByteStreamController) throw new TypeError(\"This BYOB request has been invalidated\");\n            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n          }\n        }, {\n          key: \"respondWithNewView\",\n          value: function value(view) {\n            if (IsReadableStreamBYOBRequest(this) === !1) throw new TypeError(\"ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController\");\n            if (void 0 === this._associatedReadableByteStreamController) throw new TypeError(\"This BYOB request has been invalidated\");\n            if (!ArrayBuffer.isView(view)) throw new TypeError(\"You can only respond with array buffer views\");\n            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n          }\n        }, {\n          key: \"view\",\n          get: function get() {\n            return this._view;\n          }\n        }]), ReadableStreamBYOBRequest;\n      }(),\n          ReadableByteStreamController = function () {\n        function ReadableByteStreamController(stream, underlyingByteSource, highWaterMark) {\n          if (_classCallCheck(this, ReadableByteStreamController), IsReadableStream(stream) === !1) throw new TypeError(\"ReadableByteStreamController can only be constructed with a ReadableStream instance given a byte source\");\n          if (void 0 !== stream._readableStreamController) throw new TypeError(\"ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte source\");\n          this._controlledReadableStream = stream, this._underlyingByteSource = underlyingByteSource, this._pullAgain = !1, this._pulling = !1, ReadableByteStreamControllerClearPendingPullIntos(this), this._queue = [], this._totalQueuedBytes = 0, this._closeRequested = !1, this._started = !1, this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n          var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n          if (void 0 !== autoAllocateChunkSize && (Number.isInteger(autoAllocateChunkSize) === !1 || autoAllocateChunkSize < 0)) throw new RangeError(\"autoAllocateChunkSize must be a non negative integer\");\n          this._autoAllocateChunkSize = autoAllocateChunkSize, this._pendingPullIntos = [];\n          var controller = this,\n              startResult = InvokeOrNoop(underlyingByteSource, \"start\", [this]);\n          Promise.resolve(startResult).then(function () {\n            controller._started = !0, assert(controller._pulling === !1), assert(controller._pullAgain === !1), ReadableByteStreamControllerCallPullIfNeeded(controller);\n          }, function (r) {\n            \"readable\" === stream._state && ReadableByteStreamControllerError(controller, r);\n          }).catch(rethrowAssertionErrorRejection);\n        }\n\n        return _createClass(ReadableByteStreamController, [{\n          key: \"close\",\n          value: function value() {\n            if (IsReadableByteStreamController(this) === !1) throw new TypeError(\"ReadableByteStreamController.prototype.close can only be used on a ReadableByteStreamController\");\n            if (this._closeRequested === !0) throw new TypeError(\"The stream has already been closed; do not close it again!\");\n            var state = this._controlledReadableStream._state;\n            if (\"readable\" !== state) throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be closed\");\n            ReadableByteStreamControllerClose(this);\n          }\n        }, {\n          key: \"enqueue\",\n          value: function value(chunk) {\n            if (IsReadableByteStreamController(this) === !1) throw new TypeError(\"ReadableByteStreamController.prototype.enqueue can only be used on a ReadableByteStreamController\");\n            if (this._closeRequested === !0) throw new TypeError(\"stream is closed or draining\");\n            var state = this._controlledReadableStream._state;\n            if (\"readable\" !== state) throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be enqueued to\");\n            if (!ArrayBuffer.isView(chunk)) throw new TypeError(\"You can only enqueue array buffer views when using a ReadableByteStreamController\");\n            ReadableByteStreamControllerEnqueue(this, chunk);\n          }\n        }, {\n          key: \"error\",\n          value: function value(e) {\n            if (IsReadableByteStreamController(this) === !1) throw new TypeError(\"ReadableByteStreamController.prototype.error can only be used on a ReadableByteStreamController\");\n            var stream = this._controlledReadableStream;\n            if (\"readable\" !== stream._state) throw new TypeError(\"The stream is \" + stream._state + \" and so cannot be errored\");\n            ReadableByteStreamControllerError(this, e);\n          }\n        }, {\n          key: InternalCancel,\n          value: function value(reason) {\n            if (this._pendingPullIntos.length > 0) {\n              var firstDescriptor = this._pendingPullIntos[0];\n              firstDescriptor.bytesFilled = 0;\n            }\n\n            return this._queue = [], this._totalQueuedBytes = 0, PromiseInvokeOrNoop(this._underlyingByteSource, \"cancel\", [reason]);\n          }\n        }, {\n          key: InternalPull,\n          value: function value() {\n            var stream = this._controlledReadableStream;\n\n            if (0 === ReadableStreamGetNumReadRequests(stream)) {\n              if (this._totalQueuedBytes > 0) {\n                var entry = this._queue.shift();\n\n                this._totalQueuedBytes -= entry.byteLength, ReadableByteStreamControllerHandleQueueDrain(this);\n                var view = void 0;\n\n                try {\n                  view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n                } catch (viewE) {\n                  return Promise.reject(viewE);\n                }\n\n                return Promise.resolve(CreateIterResultObject(view, !1));\n              }\n\n              var autoAllocateChunkSize = this._autoAllocateChunkSize;\n\n              if (void 0 !== autoAllocateChunkSize) {\n                var buffer = void 0;\n\n                try {\n                  buffer = new ArrayBuffer(autoAllocateChunkSize);\n                } catch (bufferE) {\n                  return Promise.reject(bufferE);\n                }\n\n                var pullIntoDescriptor = {\n                  buffer: buffer,\n                  byteOffset: 0,\n                  byteLength: autoAllocateChunkSize,\n                  bytesFilled: 0,\n                  elementSize: 1,\n                  ctor: Uint8Array,\n                  readerType: \"default\"\n                };\n\n                this._pendingPullIntos.push(pullIntoDescriptor);\n              }\n            } else assert(void 0 === this._autoAllocateChunkSize);\n\n            var promise = ReadableStreamAddReadRequest(stream);\n            return ReadableByteStreamControllerCallPullIfNeeded(this), promise;\n          }\n        }, {\n          key: \"byobRequest\",\n          get: function get() {\n            if (IsReadableByteStreamController(this) === !1) throw new TypeError(\"ReadableByteStreamController.prototype.byobRequest can only be used on a ReadableByteStreamController\");\n\n            if (void 0 === this._byobRequest && this._pendingPullIntos.length > 0) {\n              var firstDescriptor = this._pendingPullIntos[0],\n                  view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n              this._byobRequest = new ReadableStreamBYOBRequest(this, view);\n            }\n\n            return this._byobRequest;\n          }\n        }, {\n          key: \"desiredSize\",\n          get: function get() {\n            if (IsReadableByteStreamController(this) === !1) throw new TypeError(\"ReadableByteStreamController.prototype.desiredSize can only be used on a ReadableByteStreamController\");\n            return ReadableByteStreamControllerGetDesiredSize(this);\n          }\n        }]), ReadableByteStreamController;\n      }();\n    }, {\n      \"./helpers.js\": 9,\n      \"./queue-with-sizes.js\": 10,\n      \"./utils.js\": 13,\n      assert: 2\n    }],\n    12: [function (require, module, exports) {\n      \"use strict\";\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      var _require = require(\"./readable-stream.js\"),\n          ReadableStream = _require.ReadableStream,\n          _require2 = require(\"./writable-stream.js\"),\n          WritableStream = _require2.WritableStream;\n\n      module.exports = function TransformStream(transformer) {\n        function maybeDoTransform() {\n          if (transforming === !1) {\n            transforming = !0;\n\n            try {\n              transformer.transform(writeChunk, enqueueInReadable, transformDone), writeChunk = void 0, chunkWrittenButNotYetTransformed = !1;\n            } catch (e) {\n              transforming = !1, errorWritable(e), errorReadable(e);\n            }\n          }\n        }\n\n        function transformDone() {\n          transforming = !1, writeDone();\n        }\n\n        if (_classCallCheck(this, TransformStream), void 0 === transformer.flush && (transformer.flush = function (enqueue, close) {\n          return close();\n        }), \"function\" != typeof transformer.transform) throw new TypeError(\"transform must be a function\");\n        var writeChunk = void 0,\n            writeDone = void 0,\n            errorWritable = void 0,\n            transforming = !1,\n            chunkWrittenButNotYetTransformed = !1;\n        this.writable = new WritableStream({\n          start: function start(error) {\n            errorWritable = error;\n          },\n          write: function write(chunk) {\n            writeChunk = chunk, chunkWrittenButNotYetTransformed = !0;\n            var p = new Promise(function (resolve) {\n              return writeDone = resolve;\n            });\n            return maybeDoTransform(), p;\n          },\n          close: function close() {\n            try {\n              transformer.flush(enqueueInReadable, closeReadable);\n            } catch (e) {\n              errorWritable(e), errorReadable(e);\n            }\n          }\n        }, transformer.writableStrategy);\n        var enqueueInReadable = void 0,\n            closeReadable = void 0,\n            errorReadable = void 0;\n        this.readable = new ReadableStream({\n          start: function start(c) {\n            enqueueInReadable = c.enqueue.bind(c), closeReadable = c.close.bind(c), errorReadable = c.error.bind(c);\n          },\n          pull: function pull() {\n            chunkWrittenButNotYetTransformed === !0 && maybeDoTransform();\n          }\n        }, transformer.readableStrategy);\n      };\n    }, {\n      \"./readable-stream.js\": 11,\n      \"./writable-stream.js\": 14\n    }],\n    13: [function (require, module, exports) {\n      \"use strict\";\n\n      var assert = require(\"assert\");\n\n      exports.rethrowAssertionErrorRejection = function (e) {\n        e && e.constructor === assert.AssertionError && setTimeout(function () {\n          throw e;\n        }, 0);\n      };\n    }, {\n      assert: 2\n    }],\n    14: [function (require, module, exports) {\n      \"use strict\";\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      function closure_WritableStreamErrorFunction() {\n        var f = function f(e) {\n          return ErrorWritableStream(f._stream, e);\n        };\n\n        return f;\n      }\n\n      function CallOrScheduleWritableStreamAdvanceQueue(stream) {\n        return stream._started === !1 ? void stream._startedPromise.then(function () {\n          WritableStreamAdvanceQueue(stream);\n        }).catch(rethrowAssertionErrorRejection) : stream._started === !0 ? WritableStreamAdvanceQueue(stream) : void 0;\n      }\n\n      function CloseWritableStream(stream) {\n        assert(\"closing\" === stream._state, \"stream must be in closing state while calling CloseWritableStream\");\n        var sinkClosePromise = PromiseInvokeOrNoop(stream._underlyingSink, \"close\");\n        sinkClosePromise.then(function () {\n          \"errored\" !== stream._state && (assert(\"closing\" === stream._state), stream._closedPromise_resolve(void 0), stream._closedPromise_resolve = void 0, stream._closedPromise_reject = void 0, stream._state = \"closed\");\n        }, function (r) {\n          return ErrorWritableStream(stream, r);\n        }).catch(rethrowAssertionErrorRejection);\n      }\n\n      function ErrorWritableStream(stream, e) {\n        if (\"closed\" !== stream._state && \"errored\" !== stream._state) {\n          for (; stream._queue.length > 0;) {\n            var writeRecord = DequeueValue(stream._queue);\n            \"close\" !== writeRecord && writeRecord._reject(e);\n          }\n\n          stream._storedError = e, \"waiting\" === stream._state && stream._readyPromise_resolve(void 0), stream._closedPromise_reject(e), stream._closedPromise_resolve = void 0, stream._closedPromise_reject = void 0, stream._state = \"errored\";\n        }\n      }\n\n      function IsWritableStream(x) {\n        return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, \"_underlyingSink\");\n      }\n\n      function SyncWritableStreamStateWithQueue(stream) {\n        if (\"closing\" !== stream._state) {\n          assert(\"writable\" === stream._state || \"waiting\" === stream._state, \"stream must be in a writable or waiting state while calling SyncWritableStreamStateWithQueue\");\n          var queueSize = GetTotalQueueSize(stream._queue),\n              shouldApplyBackpressure = queueSize > stream._strategyHWM;\n          shouldApplyBackpressure === !0 && \"writable\" === stream._state && (stream._state = \"waiting\", stream._readyPromise = new Promise(function (resolve, reject) {\n            stream._readyPromise_resolve = resolve;\n          })), shouldApplyBackpressure === !1 && \"waiting\" === stream._state && (stream._state = \"writable\", stream._readyPromise_resolve(void 0));\n        }\n      }\n\n      function WritableStreamAdvanceQueue(stream) {\n        if (0 !== stream._queue.length && stream._writing !== !0) {\n          var writeRecord = PeekQueueValue(stream._queue);\n          return \"close\" === writeRecord ? (assert(\"closing\" === stream._state, \"can't process final write record unless already closing\"), DequeueValue(stream._queue), assert(0 === stream._queue.length, \"queue must be empty once the final write record is dequeued\"), CloseWritableStream(stream)) : (stream._writing = !0, void PromiseInvokeOrNoop(stream._underlyingSink, \"write\", [writeRecord.chunk]).then(function () {\n            \"errored\" !== stream._state && (stream._writing = !1, writeRecord._resolve(void 0), DequeueValue(stream._queue), SyncWritableStreamStateWithQueue(stream), WritableStreamAdvanceQueue(stream));\n          }, function (r) {\n            return ErrorWritableStream(stream, r);\n          }).catch(rethrowAssertionErrorRejection));\n        }\n      }\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;\n        };\n      }(),\n          assert = require(\"assert\"),\n          _require = require(\"./helpers.js\"),\n          InvokeOrNoop = _require.InvokeOrNoop,\n          PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop,\n          PromiseInvokeOrFallbackOrNoop = _require.PromiseInvokeOrFallbackOrNoop,\n          ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy,\n          typeIsObject = _require.typeIsObject,\n          _require2 = require(\"./utils.js\"),\n          rethrowAssertionErrorRejection = _require2.rethrowAssertionErrorRejection,\n          _require3 = require(\"./queue-with-sizes.js\"),\n          DequeueValue = _require3.DequeueValue,\n          EnqueueValueWithSize = _require3.EnqueueValueWithSize,\n          GetTotalQueueSize = _require3.GetTotalQueueSize,\n          PeekQueueValue = _require3.PeekQueueValue,\n          WritableStream = (require(\"./count-queuing-strategy.js\"), function () {\n        function WritableStream() {\n          var _this = this,\n              underlyingSink = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],\n              _ref = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],\n              size = _ref.size,\n              _ref$highWaterMark = _ref.highWaterMark,\n              highWaterMark = void 0 === _ref$highWaterMark ? 0 : _ref$highWaterMark;\n\n          _classCallCheck(this, WritableStream), this._underlyingSink = underlyingSink, this._closedPromise = new Promise(function (resolve, reject) {\n            _this._closedPromise_resolve = resolve, _this._closedPromise_reject = reject;\n          }), this._readyPromise = Promise.resolve(void 0), this._readyPromise_resolve = null, this._queue = [], this._state = \"writable\", this._started = !1, this._writing = !1;\n          var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);\n          this._strategySize = normalizedStrategy.size, this._strategyHWM = normalizedStrategy.highWaterMark, SyncWritableStreamStateWithQueue(this);\n          var error = closure_WritableStreamErrorFunction();\n          error._stream = this;\n          var startResult = InvokeOrNoop(underlyingSink, \"start\", [error]);\n          this._startedPromise = Promise.resolve(startResult), this._startedPromise.then(function () {\n            _this._started = !0, _this._startedPromise = void 0;\n          }), this._startedPromise.catch(function (r) {\n            return ErrorWritableStream(_this, r);\n          }).catch(rethrowAssertionErrorRejection);\n        }\n\n        return _createClass(WritableStream, [{\n          key: \"abort\",\n          value: function value(reason) {\n            if (!IsWritableStream(this)) return Promise.reject(new TypeError(\"WritableStream.prototype.abort can only be used on a WritableStream\"));\n            if (\"closed\" === this._state) return Promise.resolve(void 0);\n            if (\"errored\" === this._state) return Promise.reject(this._storedError);\n            ErrorWritableStream(this, reason);\n            var sinkAbortPromise = PromiseInvokeOrFallbackOrNoop(this._underlyingSink, \"abort\", [reason], \"close\", []);\n            return sinkAbortPromise.then(function () {});\n          }\n        }, {\n          key: \"close\",\n          value: function value() {\n            return IsWritableStream(this) ? \"closing\" === this._state ? Promise.reject(new TypeError(\"cannot close an already-closing stream\")) : \"closed\" === this._state ? Promise.reject(new TypeError(\"cannot close an already-closed stream\")) : \"errored\" === this._state ? Promise.reject(this._storedError) : (\"waiting\" === this._state && this._readyPromise_resolve(void 0), this._state = \"closing\", EnqueueValueWithSize(this._queue, \"close\", 0), CallOrScheduleWritableStreamAdvanceQueue(this), this._closedPromise) : Promise.reject(new TypeError(\"WritableStream.prototype.close can only be used on a WritableStream\"));\n          }\n        }, {\n          key: \"write\",\n          value: function value(chunk) {\n            if (!IsWritableStream(this)) return Promise.reject(new TypeError(\"WritableStream.prototype.write can only be used on a WritableStream\"));\n            if (\"closing\" === this._state) return Promise.reject(new TypeError(\"cannot write while stream is closing\"));\n            if (\"closed\" === this._state) return Promise.reject(new TypeError(\"cannot write after stream is closed\"));\n            if (\"errored\" === this._state) return Promise.reject(this._storedError);\n            assert(\"waiting\" === this._state || \"writable\" === this._state);\n            var chunkSize = 1;\n            if (void 0 !== this._strategySize) try {\n              chunkSize = this._strategySize(chunk);\n            } catch (chunkSizeE) {\n              return ErrorWritableStream(this, chunkSizeE), Promise.reject(chunkSizeE);\n            }\n            var resolver = void 0,\n                rejecter = void 0,\n                promise = new Promise(function (resolve, reject) {\n              resolver = resolve, rejecter = reject;\n            }),\n                writeRecord = {\n              promise: promise,\n              chunk: chunk,\n              _resolve: resolver,\n              _reject: rejecter\n            };\n\n            try {\n              EnqueueValueWithSize(this._queue, writeRecord, chunkSize);\n            } catch (enqueueResultE) {\n              return ErrorWritableStream(this, enqueueResultE), Promise.reject(enqueueResultE);\n            }\n\n            return SyncWritableStreamStateWithQueue(this), CallOrScheduleWritableStreamAdvanceQueue(this), promise;\n          }\n        }, {\n          key: \"closed\",\n          get: function get() {\n            return IsWritableStream(this) ? this._closedPromise : Promise.reject(new TypeError(\"WritableStream.prototype.closed can only be used on a WritableStream\"));\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            if (!IsWritableStream(this)) throw new TypeError(\"WritableStream.prototype.state can only be used on a WritableStream\");\n            return this._state;\n          }\n        }, {\n          key: \"ready\",\n          get: function get() {\n            return IsWritableStream(this) ? this._readyPromise : Promise.reject(new TypeError(\"WritableStream.prototype.ready can only be used on a WritableStream\"));\n          }\n        }]), WritableStream;\n      }());\n\n      exports.WritableStream = WritableStream, exports.IsWritableStream = IsWritableStream;\n    }, {\n      \"./count-queuing-strategy.js\": 8,\n      \"./helpers.js\": 9,\n      \"./queue-with-sizes.js\": 10,\n      \"./utils.js\": 13,\n      assert: 2\n    }]\n  }, {}, [1])(1);\n});","map":null,"metadata":{},"sourceType":"script"}