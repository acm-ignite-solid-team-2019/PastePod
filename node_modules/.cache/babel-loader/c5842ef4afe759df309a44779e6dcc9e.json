{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/evan/Documents/Solid/solid-app/solid-ignite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar EMPTY = Object.create(null);\n/**\n * A PathProxy creates path expressions,\n * to which functionality can be attached.\n *\n * To users, these paths act as regular JavaScript objects\n * (such as `path.foo.bar.prop`) thanks to Proxy.\n * Behind the scenes, they carry around internal data\n * that can be used to influence their functionality.\n *\n * A path's functionality is realized by:\n * - handlers, which handle a specific named property\n * - resolvers, which can handle arbitrary properties\n * Only handlers and resolvers see the internal data.\n *\n * A path can have arbitrary internal data fields, but these are reserved:\n * - settings, an object that is passed on as-is to child paths\n * - proxy, a reference to the proxied object the user sees\n * - parent, a reference to the parent path\n * - extendPath, a method to create a child path with this path as parent\n */\n\nvar PathProxy =\n/*#__PURE__*/\nfunction () {\n  function PathProxy() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$handlers = _ref.handlers,\n        handlers = _ref$handlers === void 0 ? EMPTY : _ref$handlers,\n        _ref$resolvers = _ref.resolvers,\n        resolvers = _ref$resolvers === void 0 ? [] : _ref$resolvers;\n\n    _classCallCheck(this, PathProxy);\n\n    this._handlers = handlers;\n    this._resolvers = resolvers;\n  }\n  /**\n   * Creates a path Proxy with the given settings and internal data fields.\n   */\n\n\n  _createClass(PathProxy, [{\n    key: \"createPath\",\n    value: function createPath() {\n      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var data = arguments.length > 1 ? arguments[1] : undefined;\n\n      // The settings parameter is optional\n      if (data === undefined) {\n        var _ref2 = [settings, {}];\n        data = _ref2[0];\n        settings = _ref2[1];\n      } // Create the path's internal data object and the proxy that wraps it\n\n\n      var path = (0, _objectSpread2.default)({\n        settings: settings\n      }, data);\n      var proxy = path.proxy = new Proxy(path, this); // Add an extendPath method to create child paths\n\n      if (!path.extendPath) {\n        var pathProxy = this;\n\n        path.extendPath = function extendPath(newData) {\n          var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n          return pathProxy.createPath(settings, (0, _objectSpread2.default)({\n            parent: parent,\n            extendPath: extendPath\n          }, newData));\n        };\n      } // Return the proxied path\n\n\n      return proxy;\n    }\n    /**\n     * Handles access to a property\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(pathData, property) {\n      // Handlers provide functionality for a specific property,\n      // so check if we find a handler first\n      var handler = this._handlers[property];\n      if (handler && typeof handler.handle === 'function') return handler.handle(pathData, pathData.proxy); // Resolvers provide functionality for arbitrary properties,\n      // so find a resolver that can handle this property\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._resolvers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var resolver = _step.value;\n          if (resolver.supports(property)) return resolver.resolve(property, pathData, pathData.proxy);\n        } // Otherwise, the property does not exist\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return PathProxy;\n}();\n\nexports.default = PathProxy;","map":null,"metadata":{},"sourceType":"script"}